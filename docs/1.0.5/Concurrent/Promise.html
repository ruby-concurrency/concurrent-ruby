<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>
  Class: Concurrent::Promise
  
    &mdash; Concurrent
  
</title>

  <link rel="stylesheet" href="../css/style.css" type="text/css" charset="utf-8" />

  <link rel="stylesheet" href="../css/common.css" type="text/css" charset="utf-8" />

<script type="text/javascript" charset="utf-8">
  hasFrames = window.top.frames.main ? true : false;
  relpath = '../';
  framesUrl = "../frames.html#!Concurrent/Promise.html";
</script>


  <script type="text/javascript" charset="utf-8" src="../js/jquery.js"></script>

  <script type="text/javascript" charset="utf-8" src="../js/app.js"></script>


  </head>
  <body>
    <div id="header">
      <div id="menu">
  
    <a href="../_index.html">Index (P)</a> &raquo;
    <span class='title'><span class='object_link'><a href="../root/Concurrent.html" title="Concurrent (module)">Concurrent</a></span></span>
     &raquo; 
    <span class="title">Promise</span>
  

  <div class="noframes"><span class="title">(</span><a href="." target="_top">no frames</a><span class="title">)</span></div>
</div>

      <div id="search">
  
    <a class="full_list_link" id="class_list_link"
        href="../class_list.html">
      Class List
    </a>
  
    <a class="full_list_link" id="method_list_link"
        href="../method_list.html">
      Method List
    </a>
  
    <a class="full_list_link" id="file_list_link"
        href="../file_list.html">
      File List
    </a>
  
</div>
      <div class="clear"></div>
    </div>

    <iframe id="search_frame"></iframe>

    <div id="content"><h1>Class: Concurrent::Promise
  
  
  
</h1>

<dl class="box">
  
    <dt class="r1">Inherits:</dt>
    <dd class="r1">
      <span class="inheritName"><span class='object_link'><a href="IVar.html" title="Concurrent::IVar (class)">IVar</a></span></span>
      
        <ul class="fullTree">
          <li>Object</li>
          
            <li class="next"><span class='object_link'>Synchronization::LockableObject</span></li>
          
            <li class="next"><span class='object_link'><a href="IVar.html" title="Concurrent::IVar (class)">IVar</a></span></li>
          
            <li class="next">Concurrent::Promise</li>
          
        </ul>
        <a href="#" class="inheritanceTree">show all</a>
      
      </dd>
    
  
  
    
  
    
  
  
  
    <dt class="r2 last">Defined in:</dt>
    <dd class="r2 last">lib/concurrent/promise.rb</dd>
  
</dl>
<div class="clear"></div>

<h2>Overview</h2><div class="docstring">
  <div class="discussion">
    <p>Promises are inspired by the JavaScript <a href="http://wiki.commonjs.org/wiki/Promises/A">Promises/A</a>
and <a href="http://promises-aplus.github.io/promises-spec/">Promises/A+</a> specifications.</p>

<blockquote>
<p>A promise represents the eventual value returned from the single
completion of an operation.</p>
</blockquote>

<p>Promises are similar to futures and share many of the same behaviours.
Promises are far more robust, however. Promises can be chained in a tree
structure where each promise may have zero or more children. Promises are
chained using the <code>then</code> method. The result of a call to <code>then</code> is always
another promise. Promises are resolved asynchronously (with respect to the
main thread) but in a strict order: parents are guaranteed to be resolved
before their children, children before their younger siblings. The <code>then</code>
method takes two parameters: an optional block to be executed upon parent
resolution and an optional callable to be executed upon parent failure. The
result of each promise is passed to each of its children upon resolution.
When a promise is rejected all its children will be summarily rejected and
will receive the reason.</p>

<p>Promises have several possible states: <em>:unscheduled</em>, <em>:pending</em>,
<em>:processing</em>, <em>:rejected</em>, or <em>:fulfilled</em>. These are also aggregated as
<code>#incomplete?</code> and <code>#complete?</code>. When a Promise is created it is set to
<em>:unscheduled</em>. Once the <code>#execute</code> method is called the state becomes
<em>:pending</em>. Once a job is pulled from the thread pool&#39;s queue and is given
to a thread for processing (often immediately upon <code>#post</code>) the state
becomes <em>:processing</em>. The future will remain in this state until processing
is complete. A future that is in the <em>:unscheduled</em>, <em>:pending</em>, or
<em>:processing</em> is considered <code>#incomplete?</code>. A <code>#complete?</code> Promise is either
<em>:rejected</em>, indicating that an exception was thrown during processing, or
<em>:fulfilled</em>, indicating success. If a Promise is <em>:fulfilled</em> its <code>#value</code>
will be updated to reflect the result of the operation. If <em>:rejected</em> the
<code>reason</code> will be updated with a reference to the thrown exception. The
predicate methods <code>#unscheduled?</code>, <code>#pending?</code>, <code>#rejected?</code>, and
<code>#fulfilled?</code> can be called at any time to obtain the state of the Promise,
as can the <code>#state</code> method, which returns a symbol.</p>

<p>Retrieving the value of a promise is done through the <code>value</code> (alias:
<code>deref</code>) method. Obtaining the value of a promise is a potentially blocking
operation. When a promise is <em>rejected</em> a call to <code>value</code> will return <code>nil</code>
immediately. When a promise is <em>fulfilled</em> a call to <code>value</code> will
immediately return the current value. When a promise is <em>pending</em> a call to
<code>value</code> will block until the promise is either <em>rejected</em> or <em>fulfilled</em>. A
<em>timeout</em> value can be passed to <code>value</code> to limit how long the call will
block. If <code>nil</code> the call will block indefinitely. If <code>0</code> the call will not
block. Any other integer or float value will indicate the maximum number of
seconds to block.</p>

<p>Promises run on the global thread pool.</p>

<h2>Copy Options</h2>

<p>Object references in Ruby are mutable. This can lead to serious
problems when the <span class='object_link'><a href="Concern/Obligation.html#value-instance_method" title="Concurrent::Concern::Obligation#value (method)">Concern::Obligation#value</a></span> of an object is a mutable reference. Which
is always the case unless the value is a <code>Fixnum</code>, <code>Symbol</code>, or similar
&quot;primitive&quot; data type. Each instance can be configured with a few
options that can help protect the program from potentially dangerous
operations. Each of these options can be optionally set when the object
instance is created:</p>

<ul>
<li><code>:dup_on_deref</code> When true the object will call the <code>#dup</code> method on
the <code>value</code> object every time the <code>#value</code> method is called
(default: false)</li>
<li><code>:freeze_on_deref</code> When true the object will call the <code>#freeze</code>
method on the <code>value</code> object every time the <code>#value</code> method is called
(default: false)</li>
<li><code>:copy_on_deref</code> When given a <code>Proc</code> object the <code>Proc</code> will be run
every time   the <code>#value</code> method is called. The <code>Proc</code> will be given
the current <code>value</code> as its only argument and the result returned by
the block will be the return   value of the <code>#value</code> call. When <code>nil</code>
this option will be ignored (default: nil)</li>
</ul>

<p>When multiple deref options are set the order of operations is strictly defined.
The order of deref operations is:</p>

<ul>
<li><code>:copy_on_deref</code></li>
<li><code>:dup_on_deref</code></li>
<li><code>:freeze_on_deref</code></li>
</ul>

<p>Because of this ordering there is no need to <code>#freeze</code> an object created by a
provided <code>:copy_on_deref</code> block. Simply set <code>:freeze_on_deref</code> to <code>true</code>.
Setting both <code>:dup_on_deref</code> to <code>true</code> and <code>:freeze_on_deref</code> to <code>true</code> is
as close to the behavior of a &quot;pure&quot; functional language (like Erlang, Clojure,
or Haskell) as we are likely to get in Ruby.</p>

<h3>Examples</h3>

<p>Start by requiring promises</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_require'>require</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>concurrent</span><span class='tstring_end'>&#39;</span></span>
</code></pre>

<p>Then create one</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_p'>p</span> <span class='op'>=</span> <span class='const'>Concurrent</span><span class='op'>::</span><span class='const'>Promise</span><span class='period'>.</span><span class='id identifier rubyid_execute'>execute</span> <span class='kw'>do</span>
      <span class='comment'># do something
</span>      <span class='int'>42</span>
    <span class='kw'>end</span>
</code></pre>

<p>Promises can be chained using the <code>then</code> method. The <code>then</code> method accepts a
block and an executor, to be executed on fulfillment, and a callable argument to be executed
on rejection. The result of the each promise is passed as the block argument
to chained promises.</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_p'>p</span> <span class='op'>=</span> <span class='const'>Concurrent</span><span class='op'>::</span><span class='const'>Promise</span><span class='period'>.</span><span class='id identifier rubyid_new'>new</span><span class='lbrace'>{</span><span class='int'>10</span><span class='rbrace'>}</span><span class='period'>.</span><span class='id identifier rubyid_then'>then</span><span class='lbrace'>{</span><span class='op'>|</span><span class='id identifier rubyid_x'>x</span><span class='op'>|</span> <span class='id identifier rubyid_x'>x</span> <span class='op'>*</span> <span class='int'>2</span><span class='rbrace'>}</span><span class='period'>.</span><span class='id identifier rubyid_then'>then</span><span class='lbrace'>{</span><span class='op'>|</span><span class='id identifier rubyid_result'>result</span><span class='op'>|</span> <span class='id identifier rubyid_result'>result</span> <span class='op'>-</span> <span class='int'>10</span> <span class='rbrace'>}</span><span class='period'>.</span><span class='id identifier rubyid_execute'>execute</span>
</code></pre>

<p>And so on, and so on, and so on...</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_p'>p</span> <span class='op'>=</span> <span class='const'>Concurrent</span><span class='op'>::</span><span class='const'>Promise</span><span class='period'>.</span><span class='id identifier rubyid_fulfill'>fulfill</span><span class='lparen'>(</span><span class='int'>20</span><span class='rparen'>)</span><span class='period'>.</span>
    <span class='id identifier rubyid_then'>then</span><span class='lbrace'>{</span><span class='op'>|</span><span class='id identifier rubyid_result'>result</span><span class='op'>|</span> <span class='id identifier rubyid_result'>result</span> <span class='op'>-</span> <span class='int'>10</span> <span class='rbrace'>}</span><span class='period'>.</span>
    <span class='id identifier rubyid_then'>then</span><span class='lbrace'>{</span><span class='op'>|</span><span class='id identifier rubyid_result'>result</span><span class='op'>|</span> <span class='id identifier rubyid_result'>result</span> <span class='op'>*</span> <span class='int'>3</span> <span class='rbrace'>}</span><span class='period'>.</span>
    <span class='id identifier rubyid_then'>then</span><span class='lparen'>(</span><span class='label'>executor:</span> <span class='id identifier rubyid_different_executor'>different_executor</span><span class='rparen'>)</span><span class='lbrace'>{</span><span class='op'>|</span><span class='id identifier rubyid_result'>result</span><span class='op'>|</span> <span class='id identifier rubyid_result'>result</span> <span class='op'>%</span> <span class='int'>5</span> <span class='rbrace'>}</span><span class='period'>.</span><span class='id identifier rubyid_execute'>execute</span>
</code></pre>

<p>The initial state of a newly created Promise depends on the state of its parent:</p>

<ul>
<li>if parent is <em>unscheduled</em> the child will be <em>unscheduled</em></li>
<li>if parent is <em>pending</em> the child will be <em>pending</em></li>
<li>if parent is <em>fulfilled</em> the child will be <em>pending</em></li>
<li>if parent is <em>rejected</em> the child will be <em>pending</em> (but will ultimately be <em>rejected</em>)</li>
</ul>

<p>Promises are executed asynchronously from the main thread. By the time a
child Promise finishes intialization it may be in a different state than its
parent (by the time a child is created its parent may have completed
execution and changed state). Despite being asynchronous, however, the order
of execution of Promise objects in a chain (or tree) is strictly defined.</p>

<p>There are multiple ways to create and execute a new <code>Promise</code>. Both ways
provide identical behavior:</p>

<pre class="code ruby"><code class="ruby"><span class='comment'># create, operate, then execute
</span><span class='id identifier rubyid_p1'>p1</span> <span class='op'>=</span> <span class='const'>Concurrent</span><span class='op'>::</span><span class='const'>Promise</span><span class='period'>.</span><span class='id identifier rubyid_new'>new</span><span class='lbrace'>{</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>Hello World!</span><span class='tstring_end'>&quot;</span></span> <span class='rbrace'>}</span>
<span class='id identifier rubyid_p1'>p1</span><span class='period'>.</span><span class='id identifier rubyid_state'>state</span> <span class='comment'>#=&gt; :unscheduled
</span><span class='id identifier rubyid_p1'>p1</span><span class='period'>.</span><span class='id identifier rubyid_execute'>execute</span>

<span class='comment'># create and immediately execute
</span><span class='id identifier rubyid_p2'>p2</span> <span class='op'>=</span> <span class='const'>Concurrent</span><span class='op'>::</span><span class='const'>Promise</span><span class='period'>.</span><span class='id identifier rubyid_new'>new</span><span class='lbrace'>{</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>Hello World!</span><span class='tstring_end'>&quot;</span></span> <span class='rbrace'>}</span><span class='period'>.</span><span class='id identifier rubyid_execute'>execute</span>

<span class='comment'># execute during creation
</span><span class='id identifier rubyid_p3'>p3</span> <span class='op'>=</span> <span class='const'>Concurrent</span><span class='op'>::</span><span class='const'>Promise</span><span class='period'>.</span><span class='id identifier rubyid_execute'>execute</span><span class='lbrace'>{</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>Hello World!</span><span class='tstring_end'>&quot;</span></span> <span class='rbrace'>}</span>
</code></pre>

<p>Once the <code>execute</code> method is called a <code>Promise</code> becomes <code>pending</code>:</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_p'>p</span> <span class='op'>=</span> <span class='const'>Concurrent</span><span class='op'>::</span><span class='const'>Promise</span><span class='period'>.</span><span class='id identifier rubyid_execute'>execute</span><span class='lbrace'>{</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>Hello, world!</span><span class='tstring_end'>&quot;</span></span> <span class='rbrace'>}</span>
<span class='id identifier rubyid_p'>p</span><span class='period'>.</span><span class='id identifier rubyid_state'>state</span>    <span class='comment'>#=&gt; :pending
</span><span class='id identifier rubyid_p'>p</span><span class='period'>.</span><span class='id identifier rubyid_pending?'>pending?</span> <span class='comment'>#=&gt; true
</span></code></pre>

<p>Wait a little bit, and the promise will resolve and provide a value:</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_p'>p</span> <span class='op'>=</span> <span class='const'>Concurrent</span><span class='op'>::</span><span class='const'>Promise</span><span class='period'>.</span><span class='id identifier rubyid_execute'>execute</span><span class='lbrace'>{</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>Hello, world!</span><span class='tstring_end'>&quot;</span></span> <span class='rbrace'>}</span>
<span class='id identifier rubyid_sleep'>sleep</span><span class='lparen'>(</span><span class='float'>0.1</span><span class='rparen'>)</span>

<span class='id identifier rubyid_p'>p</span><span class='period'>.</span><span class='id identifier rubyid_state'>state</span>      <span class='comment'>#=&gt; :fulfilled
</span><span class='id identifier rubyid_p'>p</span><span class='period'>.</span><span class='id identifier rubyid_fulfilled?'>fulfilled?</span> <span class='comment'>#=&gt; true
</span><span class='id identifier rubyid_p'>p</span><span class='period'>.</span><span class='id identifier rubyid_value'>value</span>      <span class='comment'>#=&gt; &quot;Hello, world!&quot;
</span></code></pre>

<p>If an exception occurs, the promise will be rejected and will provide
a reason for the rejection:</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_p'>p</span> <span class='op'>=</span> <span class='const'>Concurrent</span><span class='op'>::</span><span class='const'>Promise</span><span class='period'>.</span><span class='id identifier rubyid_execute'>execute</span><span class='lbrace'>{</span> <span class='id identifier rubyid_raise'>raise</span> <span class='const'>StandardError</span><span class='period'>.</span><span class='id identifier rubyid_new'>new</span><span class='lparen'>(</span><span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>Here comes the Boom!</span><span class='tstring_end'>&quot;</span></span><span class='rparen'>)</span> <span class='rbrace'>}</span>
<span class='id identifier rubyid_sleep'>sleep</span><span class='lparen'>(</span><span class='float'>0.1</span><span class='rparen'>)</span>

<span class='id identifier rubyid_p'>p</span><span class='period'>.</span><span class='id identifier rubyid_state'>state</span>     <span class='comment'>#=&gt; :rejected
</span><span class='id identifier rubyid_p'>p</span><span class='period'>.</span><span class='id identifier rubyid_rejected?'>rejected?</span> <span class='comment'>#=&gt; true
</span><span class='id identifier rubyid_p'>p</span><span class='period'>.</span><span class='id identifier rubyid_reason'>reason</span>    <span class='comment'>#=&gt; &quot;#&lt;StandardError: Here comes the Boom!&gt;&quot;
</span></code></pre>

<h4>Rejection</h4>

<p>When a promise is rejected all its children will be rejected and will
receive the rejection <code>reason</code> as the rejection callable parameter:</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_p'>p</span> <span class='op'>=</span> <span class='lbracket'>[</span> <span class='const'>Concurrent</span><span class='op'>::</span><span class='const'>Promise</span><span class='period'>.</span><span class='id identifier rubyid_execute'>execute</span><span class='lbrace'>{</span> <span class='const'>Thread</span><span class='period'>.</span><span class='id identifier rubyid_pass'>pass</span><span class='semicolon'>;</span> <span class='id identifier rubyid_raise'>raise</span> <span class='const'>StandardError</span> <span class='rbrace'>}</span> <span class='rbracket'>]</span>

<span class='id identifier rubyid_c1'>c1</span> <span class='op'>=</span> <span class='id identifier rubyid_p'>p</span><span class='period'>.</span><span class='id identifier rubyid_then'>then</span><span class='lparen'>(</span><span class='const'>Proc</span><span class='period'>.</span><span class='id identifier rubyid_new'>new</span><span class='lbrace'>{</span> <span class='op'>|</span><span class='id identifier rubyid_reason'>reason</span><span class='op'>|</span> <span class='int'>42</span> <span class='rbrace'>}</span><span class='rparen'>)</span>
<span class='id identifier rubyid_c2'>c2</span> <span class='op'>=</span> <span class='id identifier rubyid_p'>p</span><span class='period'>.</span><span class='id identifier rubyid_then'>then</span><span class='lparen'>(</span><span class='const'>Proc</span><span class='period'>.</span><span class='id identifier rubyid_new'>new</span><span class='lbrace'>{</span> <span class='op'>|</span><span class='id identifier rubyid_reason'>reason</span><span class='op'>|</span> <span class='id identifier rubyid_raise'>raise</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>Boom!</span><span class='tstring_end'>&#39;</span></span> <span class='rbrace'>}</span><span class='rparen'>)</span>

<span class='id identifier rubyid_sleep'>sleep</span><span class='lparen'>(</span><span class='float'>0.1</span><span class='rparen'>)</span>

<span class='id identifier rubyid_c1'>c1</span><span class='period'>.</span><span class='id identifier rubyid_state'>state</span>  <span class='comment'>#=&gt; :rejected
</span><span class='id identifier rubyid_c2'>c2</span><span class='period'>.</span><span class='id identifier rubyid_state'>state</span>  <span class='comment'>#=&gt; :rejected
</span></code></pre>

<p>Once a promise is rejected it will continue to accept children that will
receive immediately rejection (they will be executed asynchronously).</p>

<h4>Aliases</h4>

<p>The <code>then</code> method is the most generic alias: it accepts a block to be
executed upon parent fulfillment and a callable to be executed upon parent
rejection. At least one of them should be passed. The default block is <code>{
|result| result }</code> that fulfills the child with the parent value. The
default callable is <code>{ |reason| raise reason }</code> that rejects the child with
the parent reason.</p>

<ul>
<li><code>on_success { |result| ... }</code> is the same as <code>then {|result| ... }</code></li>
<li><code>rescue { |reason| ... }</code> is the same as <code>then(Proc.new { |reason| ... } )</code></li>
<li><code>rescue</code> is aliased by <code>catch</code> and <code>on_error</code></li>
</ul>


  </div>
</div>
<div class="tags">
  

</div>






  
    <h2>
      Class Method Summary
      <small>(<a href="#" class="summary_toggle">collapse</a>)</small>
    </h2>

    <ul class="summary">
      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#all%3F-class_method" title="all? (class method)">+ (Boolean) <strong>all?</strong>(*promises) </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>Aggregates a collection of promises and executes the <code>then</code> condition if all aggregated promises succeed.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#any%3F-class_method" title="any? (class method)">+ (Promise) <strong>any?</strong>(*promises) </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>Aggregates a collection of promises and executes the <code>then</code> condition if any aggregated promises succeed.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#execute-class_method" title="execute (class method)">+ (Promise) <strong>execute</strong>(opts = {}, &amp;block) </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>Create a new <code>Promise</code> object with the given block, execute it, and return the <code>:pending</code> object.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#fulfill-class_method" title="fulfill (class method)">+ (Promise) <strong>fulfill</strong>(value, opts = {}) </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>Create a new <code>Promise</code> and fulfill it immediately.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#reject-class_method" title="reject (class method)">+ (Promise) <strong>reject</strong>(reason, opts = {}) </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>Create a new <code>Promise</code> and reject it immediately.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#zip-class_method" title="zip (class method)">+ (Promise&lt;Array&gt;) <strong>zip</strong>(*promises) </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>Builds a promise that produces the result of promises in an Array and fails if any of them fails.</p>
</div></span>
  
</li>

      
    </ul>
  
    <h2>
      Instance Method Summary
      <small>(<a href="#" class="summary_toggle">collapse</a>)</small>
    </h2>

    <ul class="summary">
      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#execute-instance_method" title="#execute (instance method)">- (Promise) <strong>execute</strong> </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>Execute an <code>:unscheduled</code> <code>Promise</code>.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#fail-instance_method" title="#fail (instance method)">- (IVar) <strong>fail</strong>(reason = StandardError.new) </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>Set the <code>IVar</code> to failed due to some error and wake or notify all threads waiting on it.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#flat_map-instance_method" title="#flat_map (instance method)">- (Promise) <strong>flat_map</strong>(&amp;block) </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>Yield the successful result to the block that returns a promise.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#initialize-instance_method" title="#initialize (instance method)">- (Promise) <strong>initialize</strong>(opts = {}) { ... }</a>
    

    
  </span>
  
  
    <span class="note title constructor">constructor</span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>Initialize a new Promise with the provided options.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#on_success-instance_method" title="#on_success (instance method)">- (Promise) <strong>on_success</strong> { ... }</a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>Chain onto this promise an action to be undertaken on success (fulfillment).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#rescue-instance_method" title="#rescue (instance method)">- (Promise) <strong>rescue</strong> { ... }</a>
    

    
      (also: #catch, #on_error)
    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>Chain onto this promise an action to be undertaken on failure (rejection).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#set-instance_method" title="#set (instance method)">- (IVar) <strong>set</strong>(value = NULL) { ... }</a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>Set the <code>IVar</code> to a value and wake or notify all threads waiting on it.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#then-instance_method" title="#then (instance method)">- (Promise) <strong>then</strong>(rescuer = nil, executor = @executor) { ... }</a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>Chain a new promise off the current promise.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#zip-instance_method" title="#zip (instance method)">- (Promise&lt;Array&gt;) <strong>zip</strong>(*others) </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>Builds a promise that produces the result of self and others in an Array and fails if any of them fails.</p>
</div></span>
  
</li>

      
    </ul>
  


  
  
  
  
  
  
  
  
  
  <div id="constructor_details" class="method_details_list">
  <h2>Constructor Details</h2>
  
    <div class="method_details first">
  <h3 class="signature first" id="initialize-instance_method">
  
    - (<tt><span class='object_link'><a href="" title="Concurrent::Promise (class)">Promise</a></span></tt>) <strong>initialize</strong>(opts = {}) { ... }
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>Initialize a new Promise with the provided options.</p>


  </div>
</div>
<div class="tags">
  <p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>opts</span>
      
      
        <span class='type'>(<tt><span class='object_link'><a href="Hash.html" title="Concurrent::Hash (class)">Hash</a></span></tt>)</span>
      
      
        <em class="default">(defaults to: <tt>{}</tt>)</em>
      
      
        &mdash;
        <div class='inline'><p>the options used to define the behavior at update and deref
and to specify the executor on which to perform actions</p>
</div>
      
    </li>
  
</ul>

  
    
    
    <p class="tag_title">Options Hash (<tt>opts</tt>):</p>
    <ul class="option">
      
        <li>
          <span class="name">:executor</span>
          <span class="type">(<tt>Executor</tt>)</span>
          <span class="default">
            
          </span>
          
            &mdash; <div class='inline'><p>when set use the given <code>Executor</code> instance.
Three special values are also supported: <code>:task</code> returns the global task pool,
<code>:operation</code> returns the global operation pool, and <code>:immediate</code> returns a new
<code>ImmediateExecutor</code> object.</p>
</div>
          
        </li>
      
        <li>
          <span class="name">:dup_on_deref</span>
          <span class="type">(<tt>Boolean</tt>)</span>
          <span class="default">
            
              &mdash; default:
              <tt>false</tt>
            
          </span>
          
            &mdash; <div class='inline'><p>Call <code>#dup</code> before
returning the data from <span class='object_link'><a href="Concern/Obligation.html#value-instance_method" title="Concurrent::Concern::Obligation#value (method)">Concern::Obligation#value</a></span></p>
</div>
          
        </li>
      
        <li>
          <span class="name">:freeze_on_deref</span>
          <span class="type">(<tt>Boolean</tt>)</span>
          <span class="default">
            
              &mdash; default:
              <tt>false</tt>
            
          </span>
          
            &mdash; <div class='inline'><p>Call <code>#freeze</code> before
returning the data from <span class='object_link'><a href="Concern/Obligation.html#value-instance_method" title="Concurrent::Concern::Obligation#value (method)">Concern::Obligation#value</a></span></p>
</div>
          
        </li>
      
        <li>
          <span class="name">:copy_on_deref</span>
          <span class="type">(<tt>Proc</tt>)</span>
          <span class="default">
            
              &mdash; default:
              <tt>nil</tt>
            
          </span>
          
            &mdash; <div class='inline'><p>When calling the <span class='object_link'><a href="Concern/Obligation.html#value-instance_method" title="Concurrent::Concern::Obligation#value (method)">Concern::Obligation#value</a></span>
method, call the given proc passing the internal value as the sole
argument then return the new value returned from the proc.</p>
</div>
          
        </li>
      
        <li>
          <span class="name">:parent</span>
          <span class="type">(<tt><span class='object_link'><a href="" title="Concurrent::Promise (class)">Promise</a></span></tt>)</span>
          <span class="default">
            
          </span>
          
            &mdash; <div class='inline'><p>the parent <code>Promise</code> when building a chain/tree</p>
</div>
          
        </li>
      
        <li>
          <span class="name">:on_fulfill</span>
          <span class="type">(<tt>Proc</tt>)</span>
          <span class="default">
            
          </span>
          
            &mdash; <div class='inline'><p>fulfillment handler</p>
</div>
          
        </li>
      
        <li>
          <span class="name">:on_reject</span>
          <span class="type">(<tt>Proc</tt>)</span>
          <span class="default">
            
          </span>
          
            &mdash; <div class='inline'><p>rejection handler</p>
</div>
          
        </li>
      
        <li>
          <span class="name">:args</span>
          <span class="type">(<tt>object</tt>, <tt><span class='object_link'><a href="Array.html" title="Concurrent::Array (class)">Array</a></span></tt>)</span>
          <span class="default">
            
          </span>
          
            &mdash; <div class='inline'><p>zero or more arguments to be passed
the task block on execution</p>
</div>
          
        </li>
      
    </ul>
  

<p class="tag_title">Yields:</p>
<ul class="yield">
  
    <li>
      
      
        <span class='type'></span>
      
      
      
        
        <div class='inline'><p>The block operation to be performed asynchronously.</p>
</div>
      
    </li>
  
</ul>
<p class="tag_title">Raises:</p>
<ul class="raise">
  
    <li>
      
      
        <span class='type'>(<tt>ArgumentError</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>if no block is given</p>
</div>
      
    </li>
  
</ul>

  <p class="tag_title">See Also:</p>
  <ul class="see">
    
      <li><a href="http://wiki.commonjs.org/wiki/Promises/A" target="_parent" title="http://wiki.commonjs.org/wiki/Promises/A">http://wiki.commonjs.org/wiki/Promises/A</a></li>
    
      <li><a href="http://promises-aplus.github.io/promises-spec/" target="_parent" title="http://promises-aplus.github.io/promises-spec/">http://promises-aplus.github.io/promises-spec/</a></li>
    
  </ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


210
211
212
213</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'lib/concurrent/promise.rb', line 210</span>

<span class='kw'>def</span> <span class='id identifier rubyid_initialize'>initialize</span><span class='lparen'>(</span><span class='id identifier rubyid_opts'>opts</span> <span class='op'>=</span> <span class='lbrace'>{</span><span class='rbrace'>}</span><span class='comma'>,</span> <span class='op'>&amp;</span><span class='id identifier rubyid_block'>block</span><span class='rparen'>)</span>
  <span class='id identifier rubyid_opts'>opts</span><span class='period'>.</span><span class='id identifier rubyid_delete_if'>delete_if</span> <span class='lbrace'>{</span> <span class='op'>|</span><span class='id identifier rubyid_k'>k</span><span class='comma'>,</span> <span class='id identifier rubyid_v'>v</span><span class='op'>|</span> <span class='id identifier rubyid_v'>v</span><span class='period'>.</span><span class='id identifier rubyid_nil?'>nil?</span> <span class='rbrace'>}</span>
  <span class='kw'>super</span><span class='lparen'>(</span><span class='const'>NULL</span><span class='comma'>,</span> <span class='id identifier rubyid_opts'>opts</span><span class='period'>.</span><span class='id identifier rubyid_merge'>merge</span><span class='lparen'>(</span><span class='label'>__promise_body_from_block__:</span> <span class='id identifier rubyid_block'>block</span><span class='rparen'>)</span><span class='comma'>,</span> <span class='op'>&amp;</span><span class='kw'>nil</span><span class='rparen'>)</span>
<span class='kw'>end</span></pre>
    </td>
  </tr>
</table>
</div>
  
</div>


  <div id="class_method_details" class="method_details_list">
    <h2>Class Method Details</h2>

    
      <div class="method_details first">
  <h3 class="signature first" id="all?-class_method">
  
    + (<tt>Boolean</tt>) <strong>all?</strong>(*promises) 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>Aggregates a collection of promises and executes the <code>then</code> condition
if all aggregated promises succeed. Executes the <code>rescue</code> handler with
a <code>Concurrent::PromiseExecutionError</code> if any of the aggregated promises
fail. Upon execution will execute any of the aggregate promises that
were not already executed.</p>


  </div>
</div>
<div class="tags">
  
<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Boolean</tt>)</span>
      
      
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


431
432
433</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'lib/concurrent/promise.rb', line 431</span>

<span class='kw'>def</span> <span class='kw'>self</span><span class='period'>.</span><span class='id identifier rubyid_all?'>all?</span><span class='lparen'>(</span><span class='op'>*</span><span class='id identifier rubyid_promises'>promises</span><span class='rparen'>)</span>
  <span class='id identifier rubyid_aggregate'>aggregate</span><span class='lparen'>(</span><span class='symbol'>:all?</span><span class='comma'>,</span> <span class='op'>*</span><span class='id identifier rubyid_promises'>promises</span><span class='rparen'>)</span>
<span class='kw'>end</span></pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="any?-class_method">
  
    + (<tt><span class='object_link'><a href="" title="Concurrent::Promise (class)">Promise</a></span></tt>) <strong>any?</strong>(*promises) 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>Aggregates a collection of promises and executes the <code>then</code> condition
if any aggregated promises succeed. Executes the <code>rescue</code> handler with
a <code>Concurrent::PromiseExecutionError</code> if any of the aggregated promises
fail. Upon execution will execute any of the aggregate promises that
were not already executed.</p>

<p>The returned promise will not yet have been executed. Additional <code>#then</code>
and <code>#rescue</code> handlers may still be provided. Once the returned promise
is execute the aggregate promises will be also be executed (if they have
not been executed already). The results of the aggregate promises will
be checked upon completion. The necessary <code>#then</code> and <code>#rescue</code> blocks
on the aggregating promise will then be executed as appropriate. If the
<code>#rescue</code> handlers are executed the raises exception will be
<code>Concurrent::PromiseExecutionError</code>.</p>


  </div>
</div>
<div class="tags">
  <p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>promises</span>
      
      
        <span class='type'>(<tt><span class='object_link'><a href="Array.html" title="Concurrent::Array (class)">Array</a></span></tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>Zero or more promises to aggregate</p>
</div>
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt><span class='object_link'><a href="" title="Concurrent::Promise (class)">Promise</a></span></tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>an unscheduled (not executed) promise that aggregates
the promises given as arguments</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


442
443
444</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'lib/concurrent/promise.rb', line 442</span>

<span class='kw'>def</span> <span class='kw'>self</span><span class='period'>.</span><span class='id identifier rubyid_any?'>any?</span><span class='lparen'>(</span><span class='op'>*</span><span class='id identifier rubyid_promises'>promises</span><span class='rparen'>)</span>
  <span class='id identifier rubyid_aggregate'>aggregate</span><span class='lparen'>(</span><span class='symbol'>:any?</span><span class='comma'>,</span> <span class='op'>*</span><span class='id identifier rubyid_promises'>promises</span><span class='rparen'>)</span>
<span class='kw'>end</span></pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="execute-class_method">
  
    + (<tt><span class='object_link'><a href="" title="Concurrent::Promise (class)">Promise</a></span></tt>) <strong>execute</strong>(opts = {}, &amp;block) 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>Create a new <code>Promise</code> object with the given block, execute it, and return the
<code>:pending</code> object.</p>


  </div>
</div>
<div class="tags">
  
  <div class="examples">
    <p class="tag_title">Examples:</p>
    
      
      <pre class="example code"><code><span class='id identifier rubyid_promise'>promise</span> <span class='op'>=</span> <span class='const'>Concurrent</span><span class='op'>::</span><span class='const'>Promise</span><span class='period'>.</span><span class='id identifier rubyid_execute'>execute</span><span class='lbrace'>{</span> <span class='id identifier rubyid_sleep'>sleep</span><span class='lparen'>(</span><span class='int'>1</span><span class='rparen'>)</span><span class='semicolon'>;</span> <span class='int'>42</span> <span class='rbrace'>}</span>
<span class='id identifier rubyid_promise'>promise</span><span class='period'>.</span><span class='id identifier rubyid_state'>state</span> <span class='comment'>#=&gt; :pending</span></code></pre>
    
  </div>
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>opts</span>
      
      
        <span class='type'>(<tt><span class='object_link'><a href="Hash.html" title="Concurrent::Hash (class)">Hash</a></span></tt>)</span>
      
      
        <em class="default">(defaults to: <tt>{}</tt>)</em>
      
      
        &mdash;
        <div class='inline'><p>the options used to define the behavior at update and deref
and to specify the executor on which to perform actions</p>
</div>
      
    </li>
  
</ul>

  
    
    
    <p class="tag_title">Options Hash (<tt>opts</tt>):</p>
    <ul class="option">
      
        <li>
          <span class="name">:executor</span>
          <span class="type">(<tt>Executor</tt>)</span>
          <span class="default">
            
          </span>
          
            &mdash; <div class='inline'><p>when set use the given <code>Executor</code> instance.
Three special values are also supported: <code>:task</code> returns the global task pool,
<code>:operation</code> returns the global operation pool, and <code>:immediate</code> returns a new
<code>ImmediateExecutor</code> object.</p>
</div>
          
        </li>
      
        <li>
          <span class="name">:dup_on_deref</span>
          <span class="type">(<tt>Boolean</tt>)</span>
          <span class="default">
            
              &mdash; default:
              <tt>false</tt>
            
          </span>
          
            &mdash; <div class='inline'><p>Call <code>#dup</code> before
returning the data from <span class='object_link'><a href="Concern/Obligation.html#value-instance_method" title="Concurrent::Concern::Obligation#value (method)">Concern::Obligation#value</a></span></p>
</div>
          
        </li>
      
        <li>
          <span class="name">:freeze_on_deref</span>
          <span class="type">(<tt>Boolean</tt>)</span>
          <span class="default">
            
              &mdash; default:
              <tt>false</tt>
            
          </span>
          
            &mdash; <div class='inline'><p>Call <code>#freeze</code> before
returning the data from <span class='object_link'><a href="Concern/Obligation.html#value-instance_method" title="Concurrent::Concern::Obligation#value (method)">Concern::Obligation#value</a></span></p>
</div>
          
        </li>
      
        <li>
          <span class="name">:copy_on_deref</span>
          <span class="type">(<tt>Proc</tt>)</span>
          <span class="default">
            
              &mdash; default:
              <tt>nil</tt>
            
          </span>
          
            &mdash; <div class='inline'><p>When calling the <span class='object_link'><a href="Concern/Obligation.html#value-instance_method" title="Concurrent::Concern::Obligation#value (method)">Concern::Obligation#value</a></span>
method, call the given proc passing the internal value as the sole
argument then return the new value returned from the proc.</p>
</div>
          
        </li>
      
        <li>
          <span class="name">:parent</span>
          <span class="type">(<tt><span class='object_link'><a href="" title="Concurrent::Promise (class)">Promise</a></span></tt>)</span>
          <span class="default">
            
          </span>
          
            &mdash; <div class='inline'><p>the parent <code>Promise</code> when building a chain/tree</p>
</div>
          
        </li>
      
        <li>
          <span class="name">:on_fulfill</span>
          <span class="type">(<tt>Proc</tt>)</span>
          <span class="default">
            
          </span>
          
            &mdash; <div class='inline'><p>fulfillment handler</p>
</div>
          
        </li>
      
        <li>
          <span class="name">:on_reject</span>
          <span class="type">(<tt>Proc</tt>)</span>
          <span class="default">
            
          </span>
          
            &mdash; <div class='inline'><p>rejection handler</p>
</div>
          
        </li>
      
        <li>
          <span class="name">:args</span>
          <span class="type">(<tt>object</tt>, <tt><span class='object_link'><a href="Array.html" title="Concurrent::Array (class)">Array</a></span></tt>)</span>
          <span class="default">
            
          </span>
          
            &mdash; <div class='inline'><p>zero or more arguments to be passed
the task block on execution</p>
</div>
          
        </li>
      
    </ul>
  
    
    

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt><span class='object_link'><a href="" title="Concurrent::Promise (class)">Promise</a></span></tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>the newly created <code>Promise</code> in the <code>:pending</code> state</p>
</div>
      
    </li>
  
</ul>
<p class="tag_title">Raises:</p>
<ul class="raise">
  
    <li>
      
      
        <span class='type'>(<tt>ArgumentError</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>if no block is given</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


295
296
297</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'lib/concurrent/promise.rb', line 295</span>

<span class='kw'>def</span> <span class='kw'>self</span><span class='period'>.</span><span class='id identifier rubyid_execute'>execute</span><span class='lparen'>(</span><span class='id identifier rubyid_opts'>opts</span> <span class='op'>=</span> <span class='lbrace'>{</span><span class='rbrace'>}</span><span class='comma'>,</span> <span class='op'>&amp;</span><span class='id identifier rubyid_block'>block</span><span class='rparen'>)</span>
  <span class='id identifier rubyid_new'>new</span><span class='lparen'>(</span><span class='id identifier rubyid_opts'>opts</span><span class='comma'>,</span> <span class='op'>&amp;</span><span class='id identifier rubyid_block'>block</span><span class='rparen'>)</span><span class='period'>.</span><span class='id identifier rubyid_execute'>execute</span>
<span class='kw'>end</span></pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="fulfill-class_method">
  
    + (<tt><span class='object_link'><a href="" title="Concurrent::Promise (class)">Promise</a></span></tt>) <strong>fulfill</strong>(value, opts = {}) 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>Create a new <code>Promise</code> and fulfill it immediately.</p>


  </div>
</div>
<div class="tags">
  <p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>opts</span>
      
      
        <span class='type'>(<tt><span class='object_link'><a href="Hash.html" title="Concurrent::Hash (class)">Hash</a></span></tt>)</span>
      
      
        <em class="default">(defaults to: <tt>{}</tt>)</em>
      
      
        &mdash;
        <div class='inline'><p>the options used to define the behavior at update and deref
and to specify the executor on which to perform actions</p>
</div>
      
    </li>
  
</ul>

  
    
    
    
    
    <p class="tag_title">Options Hash (<tt>opts</tt>):</p>
    <ul class="option">
      
        <li>
          <span class="name">:executor</span>
          <span class="type">(<tt>Executor</tt>)</span>
          <span class="default">
            
          </span>
          
            &mdash; <div class='inline'><p>when set use the given <code>Executor</code> instance.
Three special values are also supported: <code>:task</code> returns the global task pool,
<code>:operation</code> returns the global operation pool, and <code>:immediate</code> returns a new
<code>ImmediateExecutor</code> object.</p>
</div>
          
        </li>
      
        <li>
          <span class="name">:dup_on_deref</span>
          <span class="type">(<tt>Boolean</tt>)</span>
          <span class="default">
            
              &mdash; default:
              <tt>false</tt>
            
          </span>
          
            &mdash; <div class='inline'><p>Call <code>#dup</code> before
returning the data from <span class='object_link'><a href="Concern/Obligation.html#value-instance_method" title="Concurrent::Concern::Obligation#value (method)">Concern::Obligation#value</a></span></p>
</div>
          
        </li>
      
        <li>
          <span class="name">:freeze_on_deref</span>
          <span class="type">(<tt>Boolean</tt>)</span>
          <span class="default">
            
              &mdash; default:
              <tt>false</tt>
            
          </span>
          
            &mdash; <div class='inline'><p>Call <code>#freeze</code> before
returning the data from <span class='object_link'><a href="Concern/Obligation.html#value-instance_method" title="Concurrent::Concern::Obligation#value (method)">Concern::Obligation#value</a></span></p>
</div>
          
        </li>
      
        <li>
          <span class="name">:copy_on_deref</span>
          <span class="type">(<tt>Proc</tt>)</span>
          <span class="default">
            
              &mdash; default:
              <tt>nil</tt>
            
          </span>
          
            &mdash; <div class='inline'><p>When calling the <span class='object_link'><a href="Concern/Obligation.html#value-instance_method" title="Concurrent::Concern::Obligation#value (method)">Concern::Obligation#value</a></span>
method, call the given proc passing the internal value as the sole
argument then return the new value returned from the proc.</p>
</div>
          
        </li>
      
        <li>
          <span class="name">:parent</span>
          <span class="type">(<tt><span class='object_link'><a href="" title="Concurrent::Promise (class)">Promise</a></span></tt>)</span>
          <span class="default">
            
          </span>
          
            &mdash; <div class='inline'><p>the parent <code>Promise</code> when building a chain/tree</p>
</div>
          
        </li>
      
        <li>
          <span class="name">:on_fulfill</span>
          <span class="type">(<tt>Proc</tt>)</span>
          <span class="default">
            
          </span>
          
            &mdash; <div class='inline'><p>fulfillment handler</p>
</div>
          
        </li>
      
        <li>
          <span class="name">:on_reject</span>
          <span class="type">(<tt>Proc</tt>)</span>
          <span class="default">
            
          </span>
          
            &mdash; <div class='inline'><p>rejection handler</p>
</div>
          
        </li>
      
        <li>
          <span class="name">:args</span>
          <span class="type">(<tt>object</tt>, <tt><span class='object_link'><a href="Array.html" title="Concurrent::Array (class)">Array</a></span></tt>)</span>
          <span class="default">
            
          </span>
          
            &mdash; <div class='inline'><p>zero or more arguments to be passed
the task block on execution</p>
</div>
          
        </li>
      
    </ul>
  

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt><span class='object_link'><a href="" title="Concurrent::Promise (class)">Promise</a></span></tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>the newly created <code>Promise</code></p>
</div>
      
    </li>
  
</ul>
<p class="tag_title">Raises:</p>
<ul class="raise">
  
    <li>
      
      
        <span class='type'>(<tt>ArgumentError</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>if no block is given</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


224
225
226</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'lib/concurrent/promise.rb', line 224</span>

<span class='kw'>def</span> <span class='kw'>self</span><span class='period'>.</span><span class='id identifier rubyid_fulfill'>fulfill</span><span class='lparen'>(</span><span class='id identifier rubyid_value'>value</span><span class='comma'>,</span> <span class='id identifier rubyid_opts'>opts</span> <span class='op'>=</span> <span class='lbrace'>{</span><span class='rbrace'>}</span><span class='rparen'>)</span>
  <span class='const'>Promise</span><span class='period'>.</span><span class='id identifier rubyid_new'>new</span><span class='lparen'>(</span><span class='id identifier rubyid_opts'>opts</span><span class='rparen'>)</span><span class='period'>.</span><span class='id identifier rubyid_tap'>tap</span> <span class='lbrace'>{</span> <span class='op'>|</span><span class='id identifier rubyid_p'>p</span><span class='op'>|</span> <span class='id identifier rubyid_p'>p</span><span class='period'>.</span><span class='id identifier rubyid_send'>send</span><span class='lparen'>(</span><span class='symbol'>:synchronized_set_state!</span><span class='comma'>,</span> <span class='kw'>true</span><span class='comma'>,</span> <span class='id identifier rubyid_value'>value</span><span class='comma'>,</span> <span class='kw'>nil</span><span class='rparen'>)</span> <span class='rbrace'>}</span>
<span class='kw'>end</span></pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="reject-class_method">
  
    + (<tt><span class='object_link'><a href="" title="Concurrent::Promise (class)">Promise</a></span></tt>) <strong>reject</strong>(reason, opts = {}) 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>Create a new <code>Promise</code> and reject it immediately.</p>


  </div>
</div>
<div class="tags">
  <p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>opts</span>
      
      
        <span class='type'>(<tt><span class='object_link'><a href="Hash.html" title="Concurrent::Hash (class)">Hash</a></span></tt>)</span>
      
      
        <em class="default">(defaults to: <tt>{}</tt>)</em>
      
      
        &mdash;
        <div class='inline'><p>the options used to define the behavior at update and deref
and to specify the executor on which to perform actions</p>
</div>
      
    </li>
  
</ul>

  
    
    
    
    
    <p class="tag_title">Options Hash (<tt>opts</tt>):</p>
    <ul class="option">
      
        <li>
          <span class="name">:executor</span>
          <span class="type">(<tt>Executor</tt>)</span>
          <span class="default">
            
          </span>
          
            &mdash; <div class='inline'><p>when set use the given <code>Executor</code> instance.
Three special values are also supported: <code>:task</code> returns the global task pool,
<code>:operation</code> returns the global operation pool, and <code>:immediate</code> returns a new
<code>ImmediateExecutor</code> object.</p>
</div>
          
        </li>
      
        <li>
          <span class="name">:dup_on_deref</span>
          <span class="type">(<tt>Boolean</tt>)</span>
          <span class="default">
            
              &mdash; default:
              <tt>false</tt>
            
          </span>
          
            &mdash; <div class='inline'><p>Call <code>#dup</code> before
returning the data from <span class='object_link'><a href="Concern/Obligation.html#value-instance_method" title="Concurrent::Concern::Obligation#value (method)">Concern::Obligation#value</a></span></p>
</div>
          
        </li>
      
        <li>
          <span class="name">:freeze_on_deref</span>
          <span class="type">(<tt>Boolean</tt>)</span>
          <span class="default">
            
              &mdash; default:
              <tt>false</tt>
            
          </span>
          
            &mdash; <div class='inline'><p>Call <code>#freeze</code> before
returning the data from <span class='object_link'><a href="Concern/Obligation.html#value-instance_method" title="Concurrent::Concern::Obligation#value (method)">Concern::Obligation#value</a></span></p>
</div>
          
        </li>
      
        <li>
          <span class="name">:copy_on_deref</span>
          <span class="type">(<tt>Proc</tt>)</span>
          <span class="default">
            
              &mdash; default:
              <tt>nil</tt>
            
          </span>
          
            &mdash; <div class='inline'><p>When calling the <span class='object_link'><a href="Concern/Obligation.html#value-instance_method" title="Concurrent::Concern::Obligation#value (method)">Concern::Obligation#value</a></span>
method, call the given proc passing the internal value as the sole
argument then return the new value returned from the proc.</p>
</div>
          
        </li>
      
        <li>
          <span class="name">:parent</span>
          <span class="type">(<tt><span class='object_link'><a href="" title="Concurrent::Promise (class)">Promise</a></span></tt>)</span>
          <span class="default">
            
          </span>
          
            &mdash; <div class='inline'><p>the parent <code>Promise</code> when building a chain/tree</p>
</div>
          
        </li>
      
        <li>
          <span class="name">:on_fulfill</span>
          <span class="type">(<tt>Proc</tt>)</span>
          <span class="default">
            
          </span>
          
            &mdash; <div class='inline'><p>fulfillment handler</p>
</div>
          
        </li>
      
        <li>
          <span class="name">:on_reject</span>
          <span class="type">(<tt>Proc</tt>)</span>
          <span class="default">
            
          </span>
          
            &mdash; <div class='inline'><p>rejection handler</p>
</div>
          
        </li>
      
        <li>
          <span class="name">:args</span>
          <span class="type">(<tt>object</tt>, <tt><span class='object_link'><a href="Array.html" title="Concurrent::Array (class)">Array</a></span></tt>)</span>
          <span class="default">
            
          </span>
          
            &mdash; <div class='inline'><p>zero or more arguments to be passed
the task block on execution</p>
</div>
          
        </li>
      
    </ul>
  

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt><span class='object_link'><a href="" title="Concurrent::Promise (class)">Promise</a></span></tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>the newly created <code>Promise</code></p>
</div>
      
    </li>
  
</ul>
<p class="tag_title">Raises:</p>
<ul class="raise">
  
    <li>
      
      
        <span class='type'>(<tt>ArgumentError</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>if no block is given</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


237
238
239</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'lib/concurrent/promise.rb', line 237</span>

<span class='kw'>def</span> <span class='kw'>self</span><span class='period'>.</span><span class='id identifier rubyid_reject'>reject</span><span class='lparen'>(</span><span class='id identifier rubyid_reason'>reason</span><span class='comma'>,</span> <span class='id identifier rubyid_opts'>opts</span> <span class='op'>=</span> <span class='lbrace'>{</span><span class='rbrace'>}</span><span class='rparen'>)</span>
  <span class='const'>Promise</span><span class='period'>.</span><span class='id identifier rubyid_new'>new</span><span class='lparen'>(</span><span class='id identifier rubyid_opts'>opts</span><span class='rparen'>)</span><span class='period'>.</span><span class='id identifier rubyid_tap'>tap</span> <span class='lbrace'>{</span> <span class='op'>|</span><span class='id identifier rubyid_p'>p</span><span class='op'>|</span> <span class='id identifier rubyid_p'>p</span><span class='period'>.</span><span class='id identifier rubyid_send'>send</span><span class='lparen'>(</span><span class='symbol'>:synchronized_set_state!</span><span class='comma'>,</span> <span class='kw'>false</span><span class='comma'>,</span> <span class='kw'>nil</span><span class='comma'>,</span> <span class='id identifier rubyid_reason'>reason</span><span class='rparen'>)</span> <span class='rbrace'>}</span>
<span class='kw'>end</span></pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="zip-class_method">
  
    + (<tt><span class='object_link'><a href="" title="Concurrent::Promise (class)">Promise</a></span>&lt;<span class='object_link'><a href="Array.html" title="Concurrent::Array (class)">Array</a></span>&gt;</tt>) <strong>zip</strong>(*promises) 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>Builds a promise that produces the result of promises in an Array
and fails if any of them fails.</p>


  </div>
</div>
<div class="tags">
  <p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>promises</span>
      
      
        <span class='type'>(<tt><span class='object_link'><a href="Array.html" title="Concurrent::Array (class)">Array</a></span>&lt;<span class='object_link'><a href="" title="Concurrent::Promise (class)">Promise</a></span>&gt;</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt><span class='object_link'><a href="" title="Concurrent::Promise (class)">Promise</a></span>&lt;<span class='object_link'><a href="Array.html" title="Concurrent::Array (class)">Array</a></span>&gt;</tt>)</span>
      
      
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


389
390
391
392
393
394
395
396
397
398
399</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'lib/concurrent/promise.rb', line 389</span>

<span class='kw'>def</span> <span class='kw'>self</span><span class='period'>.</span><span class='id identifier rubyid_zip'>zip</span><span class='lparen'>(</span><span class='op'>*</span><span class='id identifier rubyid_promises'>promises</span><span class='rparen'>)</span>
  <span class='id identifier rubyid_zero'>zero</span> <span class='op'>=</span> <span class='id identifier rubyid_fulfill'>fulfill</span><span class='lparen'>(</span><span class='lbracket'>[</span><span class='rbracket'>]</span><span class='comma'>,</span> <span class='label'>executor:</span> <span class='const'>ImmediateExecutor</span><span class='period'>.</span><span class='id identifier rubyid_new'>new</span><span class='rparen'>)</span>

  <span class='id identifier rubyid_promises'>promises</span><span class='period'>.</span><span class='id identifier rubyid_reduce'>reduce</span><span class='lparen'>(</span><span class='id identifier rubyid_zero'>zero</span><span class='rparen'>)</span> <span class='kw'>do</span> <span class='op'>|</span><span class='id identifier rubyid_p1'>p1</span><span class='comma'>,</span> <span class='id identifier rubyid_p2'>p2</span><span class='op'>|</span>
    <span class='id identifier rubyid_p1'>p1</span><span class='period'>.</span><span class='id identifier rubyid_flat_map'>flat_map</span> <span class='kw'>do</span> <span class='op'>|</span><span class='id identifier rubyid_results'>results</span><span class='op'>|</span>
      <span class='id identifier rubyid_p2'>p2</span><span class='period'>.</span><span class='id identifier rubyid_then'>then</span> <span class='kw'>do</span> <span class='op'>|</span><span class='id identifier rubyid_next_result'>next_result</span><span class='op'>|</span>
        <span class='id identifier rubyid_results'>results</span> <span class='op'>&lt;&lt;</span> <span class='id identifier rubyid_next_result'>next_result</span>
      <span class='kw'>end</span>
    <span class='kw'>end</span>
  <span class='kw'>end</span>
<span class='kw'>end</span></pre>
    </td>
  </tr>
</table>
</div>
    
  </div>

  <div id="instance_method_details" class="method_details_list">
    <h2>Instance Method Details</h2>

    
      <div class="method_details first">
  <h3 class="signature first" id="execute-instance_method">
  
    - (<tt><span class='object_link'><a href="" title="Concurrent::Promise (class)">Promise</a></span></tt>) <strong>execute</strong> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>Execute an <code>:unscheduled</code> <code>Promise</code>. Immediately sets the state to <code>:pending</code> and
passes the block to a new thread/thread pool for eventual execution.
Does nothing if the <code>Promise</code> is in any state other than <code>:unscheduled</code>.</p>


  </div>
</div>
<div class="tags">
  
<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt><span class='object_link'><a href="" title="Concurrent::Promise (class)">Promise</a></span></tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>a reference to <code>self</code></p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


246
247
248
249
250
251
252
253
254
255
256</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'lib/concurrent/promise.rb', line 246</span>

<span class='kw'>def</span> <span class='id identifier rubyid_execute'>execute</span>
  <span class='kw'>if</span> <span class='id identifier rubyid_root?'>root?</span>
    <span class='kw'>if</span> <span class='id identifier rubyid_compare_and_set_state'>compare_and_set_state</span><span class='lparen'>(</span><span class='symbol'>:pending</span><span class='comma'>,</span> <span class='symbol'>:unscheduled</span><span class='rparen'>)</span>
      <span class='id identifier rubyid_set_pending'>set_pending</span>
      <span class='id identifier rubyid_realize'>realize</span><span class='lparen'>(</span><span class='ivar'>@promise_body</span><span class='rparen'>)</span>
    <span class='kw'>end</span>
  <span class='kw'>else</span>
    <span class='ivar'>@parent</span><span class='period'>.</span><span class='id identifier rubyid_execute'>execute</span>
  <span class='kw'>end</span>
  <span class='kw'>self</span>
<span class='kw'>end</span></pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="fail-instance_method">
  
    - (<tt><span class='object_link'><a href="IVar.html" title="Concurrent::IVar (class)">IVar</a></span></tt>) <strong>fail</strong>(reason = StandardError.new) 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>Set the <code>IVar</code> to failed due to some error and wake or notify all threads waiting on it.</p>


  </div>
</div>
<div class="tags">
  <p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>reason</span>
      
      
        <span class='type'>(<tt>Object</tt>)</span>
      
      
        <em class="default">(defaults to: <tt>StandardError.new</tt>)</em>
      
      
        &mdash;
        <div class='inline'><p>for the failure</p>
</div>
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt><span class='object_link'><a href="IVar.html" title="Concurrent::IVar (class)">IVar</a></span></tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>self</p>
</div>
      
    </li>
  
</ul>
<p class="tag_title">Raises:</p>
<ul class="raise">
  
    <li>
      
      
        <span class='type'>(<tt><span class='object_link'><a href="MultipleAssignmentError.html" title="Concurrent::MultipleAssignmentError (class)">Concurrent::MultipleAssignmentError</a></span></tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>if the <code>IVar</code> has already
been set or otherwise completed</p>
</div>
      
    </li>
  
    <li>
      
      
        <span class='type'>(<tt><span class='object_link'><a href="../root/Concurrent.html#PromiseExecutionError-constant" title="Concurrent::PromiseExecutionError (constant)">Concurrent::PromiseExecutionError</a></span></tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>if not the root promise</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


277
278
279</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'lib/concurrent/promise.rb', line 277</span>

<span class='kw'>def</span> <span class='id identifier rubyid_fail'>fail</span><span class='lparen'>(</span><span class='id identifier rubyid_reason'>reason</span> <span class='op'>=</span> <span class='const'>StandardError</span><span class='period'>.</span><span class='id identifier rubyid_new'>new</span><span class='rparen'>)</span>
  <span class='id identifier rubyid_set'>set</span> <span class='lbrace'>{</span> <span class='id identifier rubyid_raise'>raise</span> <span class='id identifier rubyid_reason'>reason</span> <span class='rbrace'>}</span>
<span class='kw'>end</span></pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="flat_map-instance_method">
  
    - (<tt><span class='object_link'><a href="" title="Concurrent::Promise (class)">Promise</a></span></tt>) <strong>flat_map</strong>(&amp;block) 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>Yield the successful result to the block that returns a promise. If that
promise is also successful the result is the result of the yielded promise.
If either part fails the whole also fails.</p>


  </div>
</div>
<div class="tags">
  
  <div class="examples">
    <p class="tag_title">Examples:</p>
    
      
      <pre class="example code"><code><span class='const'>Promise</span><span class='period'>.</span><span class='id identifier rubyid_execute'>execute</span> <span class='lbrace'>{</span> <span class='int'>1</span> <span class='rbrace'>}</span><span class='period'>.</span><span class='id identifier rubyid_flat_map'>flat_map</span> <span class='lbrace'>{</span> <span class='op'>|</span><span class='id identifier rubyid_v'>v</span><span class='op'>|</span> <span class='const'>Promise</span><span class='period'>.</span><span class='id identifier rubyid_execute'>execute</span> <span class='lbrace'>{</span> <span class='id identifier rubyid_v'>v</span> <span class='op'>+</span> <span class='int'>2</span> <span class='rbrace'>}</span> <span class='rbrace'>}</span><span class='period'>.</span><span class='id identifier rubyid_value!'>value!</span> <span class='comment'>#=&gt; 3</span></code></pre>
    
  </div>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt><span class='object_link'><a href="" title="Concurrent::Promise (class)">Promise</a></span></tt>)</span>
      
      
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


362
363
364
365
366
367
368
369
370
371
372
373
374
375
376
377
378
379
380
381</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'lib/concurrent/promise.rb', line 362</span>

<span class='kw'>def</span> <span class='id identifier rubyid_flat_map'>flat_map</span><span class='lparen'>(</span><span class='op'>&amp;</span><span class='id identifier rubyid_block'>block</span><span class='rparen'>)</span>
  <span class='id identifier rubyid_child'>child</span> <span class='op'>=</span> <span class='const'>Promise</span><span class='period'>.</span><span class='id identifier rubyid_new'>new</span><span class='lparen'>(</span>
    <span class='label'>parent:</span> <span class='kw'>self</span><span class='comma'>,</span>
    <span class='label'>executor:</span> <span class='const'>ImmediateExecutor</span><span class='period'>.</span><span class='id identifier rubyid_new'>new</span><span class='comma'>,</span>
  <span class='rparen'>)</span>

  <span class='id identifier rubyid_on_error'>on_error</span> <span class='lbrace'>{</span> <span class='op'>|</span><span class='id identifier rubyid_e'>e</span><span class='op'>|</span> <span class='id identifier rubyid_child'>child</span><span class='period'>.</span><span class='id identifier rubyid_on_reject'>on_reject</span><span class='lparen'>(</span><span class='id identifier rubyid_e'>e</span><span class='rparen'>)</span> <span class='rbrace'>}</span>
  <span class='id identifier rubyid_on_success'>on_success</span> <span class='kw'>do</span> <span class='op'>|</span><span class='id identifier rubyid_result1'>result1</span><span class='op'>|</span>
    <span class='kw'>begin</span>
      <span class='id identifier rubyid_inner'>inner</span> <span class='op'>=</span> <span class='id identifier rubyid_block'>block</span><span class='period'>.</span><span class='id identifier rubyid_call'>call</span><span class='lparen'>(</span><span class='id identifier rubyid_result1'>result1</span><span class='rparen'>)</span>
      <span class='id identifier rubyid_inner'>inner</span><span class='period'>.</span><span class='id identifier rubyid_execute'>execute</span>
      <span class='id identifier rubyid_inner'>inner</span><span class='period'>.</span><span class='id identifier rubyid_on_success'>on_success</span> <span class='lbrace'>{</span> <span class='op'>|</span><span class='id identifier rubyid_result2'>result2</span><span class='op'>|</span> <span class='id identifier rubyid_child'>child</span><span class='period'>.</span><span class='id identifier rubyid_on_fulfill'>on_fulfill</span><span class='lparen'>(</span><span class='id identifier rubyid_result2'>result2</span><span class='rparen'>)</span> <span class='rbrace'>}</span>
      <span class='id identifier rubyid_inner'>inner</span><span class='period'>.</span><span class='id identifier rubyid_on_error'>on_error</span> <span class='lbrace'>{</span> <span class='op'>|</span><span class='id identifier rubyid_e'>e</span><span class='op'>|</span> <span class='id identifier rubyid_child'>child</span><span class='period'>.</span><span class='id identifier rubyid_on_reject'>on_reject</span><span class='lparen'>(</span><span class='id identifier rubyid_e'>e</span><span class='rparen'>)</span> <span class='rbrace'>}</span>
    <span class='kw'>rescue</span> <span class='op'>=&gt;</span> <span class='id identifier rubyid_e'>e</span>
      <span class='id identifier rubyid_child'>child</span><span class='period'>.</span><span class='id identifier rubyid_on_reject'>on_reject</span><span class='lparen'>(</span><span class='id identifier rubyid_e'>e</span><span class='rparen'>)</span>
    <span class='kw'>end</span>
  <span class='kw'>end</span>

  <span class='id identifier rubyid_child'>child</span>
<span class='kw'>end</span></pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="on_success-instance_method">
  
    - (<tt><span class='object_link'><a href="" title="Concurrent::Promise (class)">Promise</a></span></tt>) <strong>on_success</strong> { ... }
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>Chain onto this promise an action to be undertaken on success
(fulfillment).</p>


  </div>
</div>
<div class="tags">
  
<p class="tag_title">Yields:</p>
<ul class="yield">
  
    <li>
      
      
        <span class='type'></span>
      
      
      
        
        <div class='inline'><p>The block to execute</p>
</div>
      
    </li>
  
</ul>
<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt><span class='object_link'><a href="" title="Concurrent::Promise (class)">Promise</a></span></tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>self</p>
</div>
      
    </li>
  
</ul>
<p class="tag_title">Raises:</p>
<ul class="raise">
  
    <li>
      
      
        <span class='type'>(<tt>ArgumentError</tt>)</span>
      
      
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


336
337
338
339</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'lib/concurrent/promise.rb', line 336</span>

<span class='kw'>def</span> <span class='id identifier rubyid_on_success'>on_success</span><span class='lparen'>(</span><span class='op'>&amp;</span><span class='id identifier rubyid_block'>block</span><span class='rparen'>)</span>
  <span class='id identifier rubyid_raise'>raise</span> <span class='const'>ArgumentError</span><span class='period'>.</span><span class='id identifier rubyid_new'>new</span><span class='lparen'>(</span><span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>no block given</span><span class='tstring_end'>&#39;</span></span><span class='rparen'>)</span> <span class='kw'>unless</span> <span class='id identifier rubyid_block_given?'>block_given?</span>
  <span class='kw'>self</span><span class='period'>.</span><span class='id identifier rubyid_then'>then</span><span class='lparen'>(</span><span class='op'>&amp;</span><span class='id identifier rubyid_block'>block</span><span class='rparen'>)</span>
<span class='kw'>end</span></pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="rescue-instance_method">
  
    - (<tt><span class='object_link'><a href="" title="Concurrent::Promise (class)">Promise</a></span></tt>) <strong>rescue</strong> { ... }
  

  
    <span class="aliases">Also known as:
    <span class="names"><span id='catch-instance_method'>catch</span>, <span id='on_error-instance_method'>on_error</span></span>
    </span>
  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>Chain onto this promise an action to be undertaken on failure
(rejection).</p>


  </div>
</div>
<div class="tags">
  
<p class="tag_title">Yields:</p>
<ul class="yield">
  
    <li>
      
      
        <span class='type'></span>
      
      
      
        
        <div class='inline'><p>The block to execute</p>
</div>
      
    </li>
  
</ul>
<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt><span class='object_link'><a href="" title="Concurrent::Promise (class)">Promise</a></span></tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>self</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


347
348
349</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'lib/concurrent/promise.rb', line 347</span>

<span class='kw'>def</span> <span class='kw'>rescue</span><span class='lparen'>(</span><span class='op'>&amp;</span><span class='id identifier rubyid_block'>block</span><span class='rparen'>)</span>
  <span class='kw'>self</span><span class='period'>.</span><span class='id identifier rubyid_then'>then</span><span class='lparen'>(</span><span class='id identifier rubyid_block'>block</span><span class='rparen'>)</span>
<span class='kw'>end</span></pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="set-instance_method">
  
    - (<tt><span class='object_link'><a href="IVar.html" title="Concurrent::IVar (class)">IVar</a></span></tt>) <strong>set</strong>(value = NULL) { ... }
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>Set the <code>IVar</code> to a value and wake or notify all threads waiting on it.</p>


  </div>
</div>
<div class="tags">
  <p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>value</span>
      
      
        <span class='type'>(<tt>Object</tt>)</span>
      
      
        <em class="default">(defaults to: <tt>NULL</tt>)</em>
      
      
        &mdash;
        <div class='inline'><p>the value to store in the <code>IVar</code></p>
</div>
      
    </li>
  
</ul>

<p class="tag_title">Yields:</p>
<ul class="yield">
  
    <li>
      
      
        <span class='type'></span>
      
      
      
        
        <div class='inline'><p>A block operation to use for setting the value</p>
</div>
      
    </li>
  
</ul>
<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt><span class='object_link'><a href="IVar.html" title="Concurrent::IVar (class)">IVar</a></span></tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>self</p>
</div>
      
    </li>
  
</ul>
<p class="tag_title">Raises:</p>
<ul class="raise">
  
    <li>
      
      
        <span class='type'>(<tt>ArgumentError</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>if both a value and a block are given</p>
</div>
      
    </li>
  
    <li>
      
      
        <span class='type'>(<tt><span class='object_link'><a href="MultipleAssignmentError.html" title="Concurrent::MultipleAssignmentError (class)">Concurrent::MultipleAssignmentError</a></span></tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>if the <code>IVar</code> has already
been set or otherwise completed</p>
</div>
      
    </li>
  
    <li>
      
      
        <span class='type'>(<tt><span class='object_link'><a href="../root/Concurrent.html#PromiseExecutionError-constant" title="Concurrent::PromiseExecutionError (constant)">Concurrent::PromiseExecutionError</a></span></tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>if not the root promise</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


261
262
263
264
265
266
267
268
269
270
271
272</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'lib/concurrent/promise.rb', line 261</span>

<span class='kw'>def</span> <span class='id identifier rubyid_set'>set</span><span class='lparen'>(</span><span class='id identifier rubyid_value'>value</span> <span class='op'>=</span> <span class='const'>NULL</span><span class='comma'>,</span> <span class='op'>&amp;</span><span class='id identifier rubyid_block'>block</span><span class='rparen'>)</span>
  <span class='id identifier rubyid_raise'>raise</span> <span class='const'>PromiseExecutionError</span><span class='period'>.</span><span class='id identifier rubyid_new'>new</span><span class='lparen'>(</span><span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>supported only on root promise</span><span class='tstring_end'>&#39;</span></span><span class='rparen'>)</span> <span class='kw'>unless</span> <span class='id identifier rubyid_root?'>root?</span>
  <span class='id identifier rubyid_check_for_block_or_value!'>check_for_block_or_value!</span><span class='lparen'>(</span><span class='id identifier rubyid_block_given?'>block_given?</span><span class='comma'>,</span> <span class='id identifier rubyid_value'>value</span><span class='rparen'>)</span>
  <span class='id identifier rubyid_synchronize'>synchronize</span> <span class='kw'>do</span>
    <span class='kw'>if</span> <span class='ivar'>@state</span> <span class='op'>!=</span> <span class='symbol'>:unscheduled</span>
      <span class='id identifier rubyid_raise'>raise</span> <span class='const'>MultipleAssignmentError</span>
    <span class='kw'>else</span>
      <span class='ivar'>@promise_body</span> <span class='op'>=</span> <span class='id identifier rubyid_block'>block</span> <span class='op'>||</span> <span class='const'>Proc</span><span class='period'>.</span><span class='id identifier rubyid_new'>new</span> <span class='lbrace'>{</span> <span class='op'>|</span><span class='id identifier rubyid_result'>result</span><span class='op'>|</span> <span class='id identifier rubyid_value'>value</span> <span class='rbrace'>}</span>
    <span class='kw'>end</span>
  <span class='kw'>end</span>
  <span class='id identifier rubyid_execute'>execute</span>
<span class='kw'>end</span></pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="then-instance_method">
  
    - (<tt><span class='object_link'><a href="" title="Concurrent::Promise (class)">Promise</a></span></tt>) <strong>then</strong>(rescuer = nil, executor = @executor) { ... }
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>Chain a new promise off the current promise.</p>

<p>in the new Promise</p>


  </div>
</div>
<div class="tags">
  <p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>rescuer</span>
      
      
        <span class='type'>(<tt>Proc</tt>)</span>
      
      
        <em class="default">(defaults to: <tt>nil</tt>)</em>
      
      
        &mdash;
        <div class='inline'><p>An optional rescue block to be executed if the
promise is rejected.</p>
</div>
      
    </li>
  
    <li>
      
        <span class='name'>executor</span>
      
      
        <span class='type'>(<tt>ThreadPool</tt>)</span>
      
      
        <em class="default">(defaults to: <tt>@executor</tt>)</em>
      
      
        &mdash;
        <div class='inline'><p>An optional thread pool executor to be used</p>
</div>
      
    </li>
  
</ul>

<p class="tag_title">Yields:</p>
<ul class="yield">
  
    <li>
      
      
        <span class='type'></span>
      
      
      
        
        <div class='inline'><p>The block operation to be performed asynchronously.</p>
</div>
      
    </li>
  
</ul>
<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt><span class='object_link'><a href="" title="Concurrent::Promise (class)">Promise</a></span></tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>the new promise</p>
</div>
      
    </li>
  
</ul>
<p class="tag_title">Raises:</p>
<ul class="raise">
  
    <li>
      
      
        <span class='type'>(<tt>ArgumentError</tt>)</span>
      
      
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


310
311
312
313
314
315
316
317
318
319
320
321
322
323
324
325
326
327
328</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'lib/concurrent/promise.rb', line 310</span>

<span class='kw'>def</span> <span class='kw'>then</span><span class='lparen'>(</span><span class='id identifier rubyid_rescuer'>rescuer</span> <span class='op'>=</span> <span class='kw'>nil</span><span class='comma'>,</span> <span class='id identifier rubyid_executor'>executor</span> <span class='op'>=</span> <span class='ivar'>@executor</span><span class='comma'>,</span> <span class='op'>&amp;</span><span class='id identifier rubyid_block'>block</span><span class='rparen'>)</span>
  <span class='id identifier rubyid_raise'>raise</span> <span class='const'>ArgumentError</span><span class='period'>.</span><span class='id identifier rubyid_new'>new</span><span class='lparen'>(</span><span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>rescuers and block are both missing</span><span class='tstring_end'>&#39;</span></span><span class='rparen'>)</span> <span class='kw'>if</span> <span class='id identifier rubyid_rescuer'>rescuer</span><span class='period'>.</span><span class='id identifier rubyid_nil?'>nil?</span> <span class='op'>&amp;&amp;</span> <span class='op'>!</span><span class='id identifier rubyid_block_given?'>block_given?</span>
  <span class='id identifier rubyid_block'>block</span> <span class='op'>=</span> <span class='const'>Proc</span><span class='period'>.</span><span class='id identifier rubyid_new'>new</span> <span class='lbrace'>{</span> <span class='op'>|</span><span class='id identifier rubyid_result'>result</span><span class='op'>|</span> <span class='id identifier rubyid_result'>result</span> <span class='rbrace'>}</span> <span class='kw'>unless</span> <span class='id identifier rubyid_block_given?'>block_given?</span>
  <span class='id identifier rubyid_child'>child</span> <span class='op'>=</span> <span class='const'>Promise</span><span class='period'>.</span><span class='id identifier rubyid_new'>new</span><span class='lparen'>(</span>
    <span class='label'>parent:</span> <span class='kw'>self</span><span class='comma'>,</span>
    <span class='label'>executor:</span> <span class='id identifier rubyid_executor'>executor</span><span class='comma'>,</span>
    <span class='label'>on_fulfill:</span> <span class='id identifier rubyid_block'>block</span><span class='comma'>,</span>
    <span class='label'>on_reject:</span> <span class='id identifier rubyid_rescuer'>rescuer</span>
  <span class='rparen'>)</span>

  <span class='id identifier rubyid_synchronize'>synchronize</span> <span class='kw'>do</span>
    <span class='id identifier rubyid_child'>child</span><span class='period'>.</span><span class='id identifier rubyid_state'>state</span> <span class='op'>=</span> <span class='symbol'>:pending</span> <span class='kw'>if</span> <span class='ivar'>@state</span> <span class='op'>==</span> <span class='symbol'>:pending</span>
    <span class='id identifier rubyid_child'>child</span><span class='period'>.</span><span class='id identifier rubyid_on_fulfill'>on_fulfill</span><span class='lparen'>(</span><span class='id identifier rubyid_apply_deref_options'>apply_deref_options</span><span class='lparen'>(</span><span class='ivar'>@value</span><span class='rparen'>)</span><span class='rparen'>)</span> <span class='kw'>if</span> <span class='ivar'>@state</span> <span class='op'>==</span> <span class='symbol'>:fulfilled</span>
    <span class='id identifier rubyid_child'>child</span><span class='period'>.</span><span class='id identifier rubyid_on_reject'>on_reject</span><span class='lparen'>(</span><span class='ivar'>@reason</span><span class='rparen'>)</span> <span class='kw'>if</span> <span class='ivar'>@state</span> <span class='op'>==</span> <span class='symbol'>:rejected</span>
    <span class='ivar'>@children</span> <span class='op'>&lt;&lt;</span> <span class='id identifier rubyid_child'>child</span>
  <span class='kw'>end</span>

  <span class='id identifier rubyid_child'>child</span>
<span class='kw'>end</span></pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="zip-instance_method">
  
    - (<tt><span class='object_link'><a href="" title="Concurrent::Promise (class)">Promise</a></span>&lt;<span class='object_link'><a href="Array.html" title="Concurrent::Array (class)">Array</a></span>&gt;</tt>) <strong>zip</strong>(*others) 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>Builds a promise that produces the result of self and others in an Array
and fails if any of them fails.</p>


  </div>
</div>
<div class="tags">
  <p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>others</span>
      
      
        <span class='type'>(<tt><span class='object_link'><a href="Array.html" title="Concurrent::Array (class)">Array</a></span>&lt;<span class='object_link'><a href="" title="Concurrent::Promise (class)">Promise</a></span>&gt;</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt><span class='object_link'><a href="" title="Concurrent::Promise (class)">Promise</a></span>&lt;<span class='object_link'><a href="Array.html" title="Concurrent::Array (class)">Array</a></span>&gt;</tt>)</span>
      
      
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


407
408
409</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'lib/concurrent/promise.rb', line 407</span>

<span class='kw'>def</span> <span class='id identifier rubyid_zip'>zip</span><span class='lparen'>(</span><span class='op'>*</span><span class='id identifier rubyid_others'>others</span><span class='rparen'>)</span>
  <span class='kw'>self</span><span class='period'>.</span><span class='id identifier rubyid_class'>class</span><span class='period'>.</span><span class='id identifier rubyid_zip'>zip</span><span class='lparen'>(</span><span class='kw'>self</span><span class='comma'>,</span> <span class='op'>*</span><span class='id identifier rubyid_others'>others</span><span class='rparen'>)</span>
<span class='kw'>end</span></pre>
    </td>
  </tr>
</table>
</div>
    
  </div>

</div>

    <div id="footer">
  Generated on Wed Aug 15 13:38:43 2018 by
  <a href="http://yardoc.org" title="Yay! A Ruby Documentation Tool" target="_parent">yard</a>
  0.8.7.6 (ruby-2.4.3).
</div>

<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
          m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-57940973-1', 'auto');
  ga('send', 'pageview');

</script>

  </body>
</html>