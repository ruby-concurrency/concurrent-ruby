<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<title>
  File: promises.out
  
    &mdash; Concurrent
  
</title>

  <link rel="stylesheet" href="css/style.css" type="text/css" charset="utf-8" />

  <link rel="stylesheet" href="css/common.css" type="text/css" charset="utf-8" />

<script type="text/javascript" charset="utf-8">
  hasFrames = window.top.frames.main ? true : false;
  relpath = '';
  framesUrl = "frames.html#!file.promises.out.html";
</script>


  <script type="text/javascript" charset="utf-8" src="js/jquery.js"></script>

  <script type="text/javascript" charset="utf-8" src="js/app.js"></script>


  </head>
  <body>
    <div id="header">
      <div id="menu">
  
    <a href="_index.html">Index</a> &raquo; 
    <span class="title">File: promises.out</span>
  

  <div class="noframes"><span class="title">(</span><a href="." target="_top">no frames</a><span class="title">)</span></div>
</div>

      <div id="search">
  
    <a class="full_list_link" id="class_list_link"
        href="class_list.html">
      Class List
    </a>
  
    <a class="full_list_link" id="method_list_link"
        href="method_list.html">
      Method List
    </a>
  
    <a class="full_list_link" id="file_list_link"
        href="file_list.html">
      File List
    </a>
  
</div>
      <div class="clear"></div>
    </div>

    <iframe id="search_frame"></iframe>

    <div id="content"><div id='filecontents'><h1>Basics</h1>

<h2>Factory methods</h2>

<p>Future and Event are created indirectly with constructor methods in
FactoryMethods. They are not designed for inheritance but rather for
composition.</p>

<pre class="code ruby"><code class="ruby"><span class='const'>Concurrent</span><span class='op'>::</span><span class='const'>Promises</span><span class='op'>::</span><span class='const'>FactoryMethods</span><span class='period'>.</span><span class='id identifier rubyid_instance_methods'>instance_methods</span><span class='lparen'>(</span><span class='kw'>false</span><span class='rparen'>)</span>
<span class='comment'># =&gt; [:zip,
</span><span class='comment'>#     :create,
</span><span class='comment'>#     :delay,
</span><span class='comment'>#     :future,
</span><span class='comment'>#     :resolvable_future,
</span><span class='comment'>#     :resolvable_event,
</span><span class='comment'>#     :resolvable_event_on,
</span><span class='comment'>#     :resolvable_future_on,
</span><span class='comment'>#     :future_on,
</span><span class='comment'>#     :resolved_future,
</span><span class='comment'>#     :fulfilled_future,
</span><span class='comment'>#     :rejected_future,
</span><span class='comment'>#     :resolved_event,
</span><span class='comment'>#     :delay_on,
</span><span class='comment'>#     :schedule,
</span><span class='comment'>#     :schedule_on,
</span><span class='comment'>#     :zip_futures,
</span><span class='comment'>#     :zip_futures_on,
</span><span class='comment'>#     :zip_events,
</span><span class='comment'>#     :zip_events_on,
</span><span class='comment'>#     :any_resolved_future,
</span><span class='comment'>#     :any_resolved_future_on,
</span><span class='comment'>#     :any,
</span><span class='comment'>#     :any_fulfilled_future,
</span><span class='comment'>#     :any_fulfilled_future_on,
</span><span class='comment'>#     :any_event,
</span><span class='comment'>#     :any_event_on]
</span></code></pre>

<p>The module can be included or extended where needed.</p>

<pre class="code ruby"><code class="ruby"><span class='const'>Class</span><span class='period'>.</span><span class='id identifier rubyid_new'>new</span> <span class='kw'>do</span>
  <span class='id identifier rubyid_include'>include</span> <span class='const'>Concurrent</span><span class='op'>::</span><span class='const'>Promises</span><span class='op'>::</span><span class='const'>FactoryMethods</span>

  <span class='kw'>def</span> <span class='id identifier rubyid_a_method'>a_method</span>
    <span class='id identifier rubyid_resolvable_event'>resolvable_event</span>
  <span class='kw'>end</span>
<span class='kw'>end</span><span class='period'>.</span><span class='id identifier rubyid_new'>new</span><span class='period'>.</span><span class='id identifier rubyid_a_method'>a_method</span>
<span class='comment'># =&gt; &lt;#Concurrent::Promises::ResolvableEvent:0x7fb5e090d308 pending&gt;
</span>
<span class='id identifier rubyid_mod'>mod</span> <span class='op'>=</span> <span class='const'>Module</span><span class='period'>.</span><span class='id identifier rubyid_new'>new</span> <span class='kw'>do</span>
  <span class='id identifier rubyid_extend'>extend</span> <span class='const'>Concurrent</span><span class='op'>::</span><span class='const'>Promises</span><span class='op'>::</span><span class='const'>FactoryMethods</span>
<span class='kw'>end</span> 
<span class='id identifier rubyid_mod'>mod</span><span class='period'>.</span><span class='id identifier rubyid_resolvable_event'>resolvable_event</span>
<span class='comment'># =&gt; &lt;#Concurrent::Promises::ResolvableEvent:0x7fb5e0907750 pending&gt;
</span></code></pre>

<p>The default executor can be changed by overriding <code>default_executor</code> method
inherited from <code>Concurrent::Promises::FactoryMethods</code>.</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_mod'>mod</span> <span class='op'>=</span> <span class='const'>Module</span><span class='period'>.</span><span class='id identifier rubyid_new'>new</span> <span class='kw'>do</span>
  <span class='id identifier rubyid_extend'>extend</span> <span class='const'>Concurrent</span><span class='op'>::</span><span class='const'>Promises</span><span class='op'>::</span><span class='const'>FactoryMethods</span>
  <span class='kw'>def</span> <span class='kw'>self</span><span class='period'>.</span><span class='id identifier rubyid_default_executor'>default_executor</span>
    <span class='symbol'>:fast</span>
  <span class='kw'>end</span>
<span class='kw'>end</span> 
<span class='id identifier rubyid_mod'>mod</span><span class='period'>.</span><span class='id identifier rubyid_future'>future</span> <span class='lbrace'>{</span> <span class='int'>1</span> <span class='rbrace'>}</span><span class='period'>.</span><span class='id identifier rubyid_default_executor'>default_executor</span>        <span class='comment'># =&gt; :fast
</span><span class='const'>Concurrent</span><span class='op'>::</span><span class='const'>Promises</span><span class='period'>.</span><span class='id identifier rubyid_future'>future</span> <span class='lbrace'>{</span> <span class='int'>1</span> <span class='rbrace'>}</span><span class='period'>.</span><span class='id identifier rubyid_default_executor'>default_executor</span>
<span class='comment'># =&gt; :io
</span></code></pre>

<p>The module is already extended into <span class='object_link'><a href="Concurrent/Promises.html" title="Concurrent::Promises (module)">Concurrent::Promises</a></span> for convenience.</p>

<pre class="code ruby"><code class="ruby"><span class='const'>Concurrent</span><span class='op'>::</span><span class='const'>Promises</span><span class='period'>.</span><span class='id identifier rubyid_resolvable_event'>resolvable_event</span>
<span class='comment'># =&gt; &lt;#Concurrent::Promises::ResolvableEvent:0x7fb5e1a6c680 pending&gt;
</span></code></pre>

<h2>Asynchronous task</h2>

<p>The most basic use-case of the framework is asynchronous processing. A task can
be processed asynchronously by using a <code>future</code> factory method. The block will
be executed on an internal thread pool.</p>

<p>Arguments of <code>future</code> are passed to the block and evaluation starts immediately.</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_future'>future</span> <span class='op'>=</span> <span class='const'>Concurrent</span><span class='op'>::</span><span class='const'>Promises</span><span class='period'>.</span><span class='id identifier rubyid_future'>future</span><span class='lparen'>(</span><span class='float'>0.1</span><span class='rparen'>)</span> <span class='kw'>do</span> <span class='op'>|</span><span class='id identifier rubyid_duration'>duration</span><span class='op'>|</span>
  <span class='id identifier rubyid_sleep'>sleep</span> <span class='id identifier rubyid_duration'>duration</span>
  <span class='symbol'>:result</span>
<span class='kw'>end</span>
<span class='comment'># =&gt; &lt;#Concurrent::Promises::Future:0x7fb5e1a64a70 pending&gt;
</span></code></pre>

<p>Asks if the future is resolved, here it will be still in the middle of the
sleep call.</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_future'>future</span><span class='period'>.</span><span class='id identifier rubyid_resolved?'>resolved?</span>                         <span class='comment'># =&gt; false
</span></code></pre>

<p>Retrieving the value will block until the future is resolved.</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_future'>future</span><span class='period'>.</span><span class='id identifier rubyid_value'>value</span>                             <span class='comment'># =&gt; :result
</span><span class='id identifier rubyid_future'>future</span><span class='period'>.</span><span class='id identifier rubyid_resolved?'>resolved?</span>                         <span class='comment'># =&gt; true
</span></code></pre>

<p>If the task fails we talk about the future being rejected.</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_future'>future</span> <span class='op'>=</span> <span class='const'>Concurrent</span><span class='op'>::</span><span class='const'>Promises</span><span class='period'>.</span><span class='id identifier rubyid_future'>future</span> <span class='lbrace'>{</span> <span class='id identifier rubyid_raise'>raise</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>Boom</span><span class='tstring_end'>&#39;</span></span> <span class='rbrace'>}</span>
<span class='comment'># =&gt; &lt;#Concurrent::Promises::Future:0x7fb5e22ca930 rejected&gt;
</span></code></pre>

<p>There is no result, the future was rejected with a reason.</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_future'>future</span><span class='period'>.</span><span class='id identifier rubyid_value'>value</span>                             <span class='comment'># =&gt; nil
</span><span class='id identifier rubyid_future'>future</span><span class='period'>.</span><span class='id identifier rubyid_reason'>reason</span>                            <span class='comment'># =&gt; #&lt;RuntimeError: Boom&gt;
</span></code></pre>

<p>It can be forced to raise the reason for rejection when retrieving the value.</p>

<pre class="code ruby"><code class="ruby"><span class='kw'>begin</span>
  <span class='id identifier rubyid_future'>future</span><span class='period'>.</span><span class='id identifier rubyid_value!'>value!</span> 
<span class='kw'>rescue</span> <span class='op'>=&gt;</span> <span class='id identifier rubyid_e'>e</span> 
  <span class='id identifier rubyid_e'>e</span>
<span class='kw'>end</span>                                      <span class='comment'># =&gt; #&lt;RuntimeError: Boom&gt;
</span></code></pre>

<p>Which is the same as <code>future.value! rescue $!</code> which will be used hereafter.</p>

<p>Or it can be used directly as argument for raise, since it implements exception
method.</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_raise'>raise</span> <span class='id identifier rubyid_future'>future</span> <span class='kw'>rescue</span> <span class='gvar'>$!</span>                   <span class='comment'># =&gt; #&lt;RuntimeError: Boom&gt;
</span></code></pre>

<h2>States</h2>

<p>Lets define a inspection helper for methods.</p>

<pre class="code ruby"><code class="ruby"><span class='kw'>def</span> <span class='id identifier rubyid_inspect_methods'>inspect_methods</span><span class='lparen'>(</span><span class='op'>*</span><span class='id identifier rubyid_methods'>methods</span><span class='comma'>,</span> <span class='label'>of:</span><span class='rparen'>)</span>
  <span class='id identifier rubyid_methods'>methods</span><span class='period'>.</span><span class='id identifier rubyid_reduce'>reduce</span><span class='lparen'>(</span><span class='lbrace'>{</span><span class='rbrace'>}</span><span class='rparen'>)</span> <span class='lbrace'>{</span> <span class='op'>|</span><span class='id identifier rubyid_h'>h</span><span class='comma'>,</span> <span class='id identifier rubyid_m'>m</span><span class='op'>|</span> <span class='id identifier rubyid_h'>h</span><span class='period'>.</span><span class='id identifier rubyid_update'>update</span> <span class='id identifier rubyid_m'>m</span> <span class='op'>=&gt;</span> <span class='id identifier rubyid_of'>of</span><span class='period'>.</span><span class='id identifier rubyid_send'>send</span><span class='lparen'>(</span><span class='id identifier rubyid_m'>m</span><span class='rparen'>)</span> <span class='rbrace'>}</span>
<span class='kw'>end</span> 
</code></pre>

<p>Event has <code>pending</code> and <code>resolved</code> state. </p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_event'>event</span> <span class='op'>=</span> <span class='const'>Concurrent</span><span class='op'>::</span><span class='const'>Promises</span><span class='period'>.</span><span class='id identifier rubyid_resolvable_event'>resolvable_event</span> 
<span class='id identifier rubyid_inspect_methods'>inspect_methods</span><span class='lparen'>(</span><span class='symbol'>:state</span><span class='comma'>,</span> <span class='symbol'>:pending?</span><span class='comma'>,</span> <span class='symbol'>:resolved?</span><span class='comma'>,</span> <span class='label'>of:</span> <span class='id identifier rubyid_event'>event</span><span class='rparen'>)</span>
<span class='comment'># =&gt; {:state=&gt;:pending, :pending?=&gt;true, :resolved?=&gt;false}
</span>
<span class='id identifier rubyid_event'>event</span><span class='period'>.</span><span class='id identifier rubyid_resolve'>resolve</span> 
<span class='id identifier rubyid_inspect_methods'>inspect_methods</span><span class='lparen'>(</span><span class='symbol'>:state</span><span class='comma'>,</span> <span class='symbol'>:pending?</span><span class='comma'>,</span> <span class='symbol'>:resolved?</span><span class='comma'>,</span> <span class='label'>of:</span> <span class='id identifier rubyid_event'>event</span><span class='rparen'>)</span>
<span class='comment'># =&gt; {:state=&gt;:resolved, :pending?=&gt;false, :resolved?=&gt;true}
</span></code></pre>

<p>Future&#39;s <code>resolved</code> state is further specified to be <code>fulfilled</code> or <code>rejected</code>.</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_future'>future</span> <span class='op'>=</span> <span class='const'>Concurrent</span><span class='op'>::</span><span class='const'>Promises</span><span class='period'>.</span><span class='id identifier rubyid_resolvable_future'>resolvable_future</span> 
<span class='id identifier rubyid_inspect_methods'>inspect_methods</span><span class='lparen'>(</span><span class='symbol'>:state</span><span class='comma'>,</span> <span class='symbol'>:pending?</span><span class='comma'>,</span> <span class='symbol'>:resolved?</span><span class='comma'>,</span> <span class='symbol'>:fulfilled?</span><span class='comma'>,</span> <span class='symbol'>:rejected?</span><span class='comma'>,</span> 
    <span class='label'>of:</span> <span class='id identifier rubyid_future'>future</span><span class='rparen'>)</span>
<span class='comment'># =&gt; {:state=&gt;:pending,
</span><span class='comment'>#     :pending?=&gt;true,
</span><span class='comment'>#     :resolved?=&gt;false,
</span><span class='comment'>#     :fulfilled?=&gt;false,
</span><span class='comment'>#     :rejected?=&gt;false}
</span>
<span class='id identifier rubyid_future'>future</span><span class='period'>.</span><span class='id identifier rubyid_fulfill'>fulfill</span> <span class='symbol'>:value</span> 
<span class='id identifier rubyid_inspect_methods'>inspect_methods</span><span class='lparen'>(</span><span class='symbol'>:state</span><span class='comma'>,</span> <span class='symbol'>:pending?</span><span class='comma'>,</span> <span class='symbol'>:resolved?</span><span class='comma'>,</span> <span class='symbol'>:fulfilled?</span><span class='comma'>,</span> <span class='symbol'>:rejected?</span><span class='comma'>,</span>
    <span class='symbol'>:result</span><span class='comma'>,</span> <span class='symbol'>:value</span><span class='comma'>,</span> <span class='symbol'>:reason</span><span class='comma'>,</span> <span class='label'>of:</span> <span class='id identifier rubyid_future'>future</span><span class='rparen'>)</span>
<span class='comment'># =&gt; {:state=&gt;:fulfilled,
</span><span class='comment'>#     :pending?=&gt;false,
</span><span class='comment'>#     :resolved?=&gt;true,
</span><span class='comment'>#     :fulfilled?=&gt;true,
</span><span class='comment'>#     :rejected?=&gt;false,
</span><span class='comment'>#     :result=&gt;[true, :value, nil],
</span><span class='comment'>#     :value=&gt;:value,
</span><span class='comment'>#     :reason=&gt;nil}
</span>
<span class='id identifier rubyid_future'>future</span> <span class='op'>=</span> <span class='const'>Concurrent</span><span class='op'>::</span><span class='const'>Promises</span><span class='period'>.</span><span class='id identifier rubyid_rejected_future'>rejected_future</span> <span class='const'>StandardError</span><span class='period'>.</span><span class='id identifier rubyid_new'>new</span> 
<span class='id identifier rubyid_inspect_methods'>inspect_methods</span><span class='lparen'>(</span><span class='symbol'>:state</span><span class='comma'>,</span> <span class='symbol'>:pending?</span><span class='comma'>,</span> <span class='symbol'>:resolved?</span><span class='comma'>,</span> <span class='symbol'>:fulfilled?</span><span class='comma'>,</span> <span class='symbol'>:rejected?</span><span class='comma'>,</span> 
    <span class='symbol'>:result</span><span class='comma'>,</span> <span class='symbol'>:value</span><span class='comma'>,</span> <span class='symbol'>:reason</span><span class='comma'>,</span> <span class='label'>of:</span> <span class='id identifier rubyid_future'>future</span><span class='rparen'>)</span>
<span class='comment'># =&gt; {:state=&gt;:rejected,
</span><span class='comment'>#     :pending?=&gt;false,
</span><span class='comment'>#     :resolved?=&gt;true,
</span><span class='comment'>#     :fulfilled?=&gt;false,
</span><span class='comment'>#     :rejected?=&gt;true,
</span><span class='comment'>#     :result=&gt;[false, nil, #&lt;StandardError: StandardError&gt;],
</span><span class='comment'>#     :value=&gt;nil,
</span><span class='comment'>#     :reason=&gt;#&lt;StandardError: StandardError&gt;}
</span></code></pre>

<h2>Direct creation of resolved futures</h2>

<p>When an existing value has to wrapped in a future it does not have to go
through evaluation as follows.</p>

<pre class="code ruby"><code class="ruby"><span class='const'>Concurrent</span><span class='op'>::</span><span class='const'>Promises</span><span class='period'>.</span><span class='id identifier rubyid_future'>future</span> <span class='lbrace'>{</span> <span class='symbol'>:value</span> <span class='rbrace'>}</span>
<span class='comment'># =&gt; &lt;#Concurrent::Promises::Future:0x7fb5e22a05b8 pending&gt;
</span></code></pre>

<p>Instead it can be created directly.</p>

<pre class="code ruby"><code class="ruby"><span class='const'>Concurrent</span><span class='op'>::</span><span class='const'>Promises</span><span class='period'>.</span><span class='id identifier rubyid_fulfilled_future'>fulfilled_future</span><span class='lparen'>(</span><span class='symbol'>:value</span><span class='rparen'>)</span>
<span class='comment'># =&gt; &lt;#Concurrent::Promises::Future:0x7fb5e38052c8 fulfilled&gt;
</span><span class='const'>Concurrent</span><span class='op'>::</span><span class='const'>Promises</span><span class='period'>.</span><span class='id identifier rubyid_rejected_future'>rejected_future</span><span class='lparen'>(</span><span class='const'>StandardError</span><span class='period'>.</span><span class='id identifier rubyid_new'>new</span><span class='lparen'>(</span><span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>Ups</span><span class='tstring_end'>&#39;</span></span><span class='rparen'>)</span><span class='rparen'>)</span>
<span class='comment'># =&gt; &lt;#Concurrent::Promises::Future:0x7fb5e08f7be8 rejected&gt;
</span><span class='const'>Concurrent</span><span class='op'>::</span><span class='const'>Promises</span><span class='period'>.</span><span class='id identifier rubyid_resolved_future'>resolved_future</span><span class='lparen'>(</span><span class='kw'>true</span><span class='comma'>,</span> <span class='symbol'>:value</span><span class='comma'>,</span> <span class='kw'>nil</span><span class='rparen'>)</span>
<span class='comment'># =&gt; &lt;#Concurrent::Promises::Future:0x7fb5e08f61a8 fulfilled&gt;
</span><span class='const'>Concurrent</span><span class='op'>::</span><span class='const'>Promises</span><span class='period'>.</span><span class='id identifier rubyid_resolved_future'>resolved_future</span><span class='lparen'>(</span><span class='kw'>false</span><span class='comma'>,</span> <span class='kw'>nil</span><span class='comma'>,</span> <span class='const'>StandardError</span><span class='period'>.</span><span class='id identifier rubyid_new'>new</span><span class='lparen'>(</span><span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>Ups</span><span class='tstring_end'>&#39;</span></span><span class='rparen'>)</span><span class='rparen'>)</span>
<span class='comment'># =&gt; &lt;#Concurrent::Promises::Future:0x7fb5e08f4150 rejected&gt;
</span></code></pre>

<h2>Chaining</h2>

<p>Big advantage of promises is ability to chain tasks together without blocking
current thread.</p>

<pre class="code ruby"><code class="ruby"><span class='const'>Concurrent</span><span class='op'>::</span><span class='const'>Promises</span><span class='period'>.</span>
    <span class='id identifier rubyid_future'>future</span><span class='lparen'>(</span><span class='int'>2</span><span class='rparen'>)</span> <span class='lbrace'>{</span> <span class='op'>|</span><span class='id identifier rubyid_v'>v</span><span class='op'>|</span> <span class='id identifier rubyid_v'>v</span><span class='period'>.</span><span class='id identifier rubyid_succ'>succ</span> <span class='rbrace'>}</span><span class='period'>.</span>
    <span class='id identifier rubyid_then'>then</span><span class='lparen'>(</span><span class='op'>&amp;</span><span class='symbol'>:succ</span><span class='rparen'>)</span><span class='period'>.</span>
    <span class='id identifier rubyid_value!'>value!</span>                               <span class='comment'># =&gt; 4
</span></code></pre>

<p>As <code>future</code> factory method takes argument, <code>then</code> method takes as well. Any
supplied arguments are passed to the block, and the library ensures that they
are visible to the block.</p>

<pre class="code ruby"><code class="ruby"><span class='const'>Concurrent</span><span class='op'>::</span><span class='const'>Promises</span><span class='period'>.</span>
    <span class='id identifier rubyid_future'>future</span><span class='lparen'>(</span><span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>3</span><span class='tstring_end'>&#39;</span></span><span class='rparen'>)</span> <span class='lbrace'>{</span> <span class='op'>|</span><span class='id identifier rubyid_s'>s</span><span class='op'>|</span> <span class='id identifier rubyid_s'>s</span><span class='period'>.</span><span class='id identifier rubyid_to_i'>to_i</span> <span class='rbrace'>}</span><span class='period'>.</span>
    <span class='id identifier rubyid_then'>then</span><span class='lparen'>(</span><span class='int'>2</span><span class='rparen'>)</span> <span class='lbrace'>{</span> <span class='op'>|</span><span class='id identifier rubyid_v'>v</span><span class='comma'>,</span> <span class='id identifier rubyid_arg'>arg</span><span class='op'>|</span> <span class='id identifier rubyid_v'>v</span> <span class='op'>+</span> <span class='id identifier rubyid_arg'>arg</span> <span class='rbrace'>}</span><span class='period'>.</span>
    <span class='id identifier rubyid_value'>value</span>                                <span class='comment'># =&gt; 5
</span><span class='const'>Concurrent</span><span class='op'>::</span><span class='const'>Promises</span><span class='period'>.</span>
    <span class='id identifier rubyid_fulfilled_future'>fulfilled_future</span><span class='lparen'>(</span><span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>3</span><span class='tstring_end'>&#39;</span></span><span class='rparen'>)</span><span class='period'>.</span>
    <span class='id identifier rubyid_then'>then</span><span class='lparen'>(</span><span class='op'>&amp;</span><span class='symbol'>:to_i</span><span class='rparen'>)</span><span class='period'>.</span>
    <span class='id identifier rubyid_then'>then</span><span class='lparen'>(</span><span class='int'>2</span><span class='comma'>,</span> <span class='op'>&amp;</span><span class='symbol'>:+</span><span class='rparen'>)</span><span class='period'>.</span>
    <span class='id identifier rubyid_value'>value</span>                                <span class='comment'># =&gt; 5
</span><span class='const'>Concurrent</span><span class='op'>::</span><span class='const'>Promises</span><span class='period'>.</span>
    <span class='id identifier rubyid_fulfilled_future'>fulfilled_future</span><span class='lparen'>(</span><span class='int'>1</span><span class='rparen'>)</span><span class='period'>.</span>
    <span class='id identifier rubyid_chain'>chain</span><span class='lparen'>(</span><span class='int'>2</span><span class='rparen'>)</span> <span class='lbrace'>{</span> <span class='op'>|</span><span class='id identifier rubyid_fulfilled'>fulfilled</span><span class='comma'>,</span> <span class='id identifier rubyid_value'>value</span><span class='comma'>,</span> <span class='id identifier rubyid_reason'>reason</span><span class='comma'>,</span> <span class='id identifier rubyid_arg'>arg</span><span class='op'>|</span> <span class='id identifier rubyid_value'>value</span> <span class='op'>+</span> <span class='id identifier rubyid_arg'>arg</span> <span class='rbrace'>}</span><span class='period'>.</span>
    <span class='id identifier rubyid_value'>value</span>                                <span class='comment'># =&gt; 3
</span></code></pre>

<p>Passing the arguments in (similarly as for a thread <code>Thread.new(arg) { |arg|
do_stuff arg }</code>) is <strong>required</strong>, both following examples may break.</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_arg'>arg</span> <span class='op'>=</span> <span class='int'>1</span>                                  <span class='comment'># =&gt; 1
</span><span class='const'>Thread</span><span class='period'>.</span><span class='id identifier rubyid_new'>new</span> <span class='lbrace'>{</span> <span class='id identifier rubyid_do_stuff'>do_stuff</span> <span class='id identifier rubyid_arg'>arg</span> <span class='rbrace'>}</span>
<span class='comment'># =&gt; #&lt;Thread:0x0000000000000002@promises.in.md:203 run&gt;
</span><span class='const'>Concurrent</span><span class='op'>::</span><span class='const'>Promises</span><span class='period'>.</span><span class='id identifier rubyid_future'>future</span> <span class='lbrace'>{</span> <span class='id identifier rubyid_do_stuff'>do_stuff</span> <span class='id identifier rubyid_arg'>arg</span> <span class='rbrace'>}</span>
<span class='comment'># =&gt; &lt;#Concurrent::Promises::Future:0x7fb5e11cd010 pending&gt;
</span></code></pre>

<h2>Branching, and zipping</h2>

<p>Besides chaining it can also be branched.</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_head'>head</span>    <span class='op'>=</span> <span class='const'>Concurrent</span><span class='op'>::</span><span class='const'>Promises</span><span class='period'>.</span><span class='id identifier rubyid_fulfilled_future'>fulfilled_future</span> <span class='op'>-</span><span class='int'>1</span> 
<span class='id identifier rubyid_branch1'>branch1</span> <span class='op'>=</span> <span class='id identifier rubyid_head'>head</span><span class='period'>.</span><span class='id identifier rubyid_then'>then</span><span class='lparen'>(</span><span class='op'>&amp;</span><span class='symbol'>:abs</span><span class='rparen'>)</span> 
<span class='id identifier rubyid_branch2'>branch2</span> <span class='op'>=</span> <span class='id identifier rubyid_head'>head</span><span class='period'>.</span><span class='id identifier rubyid_then'>then</span><span class='lparen'>(</span><span class='op'>&amp;</span><span class='symbol'>:succ</span><span class='rparen'>)</span><span class='period'>.</span><span class='id identifier rubyid_then'>then</span><span class='lparen'>(</span><span class='op'>&amp;</span><span class='symbol'>:succ</span><span class='rparen'>)</span> 

<span class='id identifier rubyid_branch1'>branch1</span><span class='period'>.</span><span class='id identifier rubyid_value!'>value!</span>                           <span class='comment'># =&gt; 1
</span><span class='id identifier rubyid_branch2'>branch2</span><span class='period'>.</span><span class='id identifier rubyid_value!'>value!</span>                           <span class='comment'># =&gt; 1
</span></code></pre>

<p>It can be combined back to one future by zipping (<code>zip</code>, <code>&amp;</code>).</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_branch1'>branch1</span><span class='period'>.</span><span class='id identifier rubyid_zip'>zip</span><span class='lparen'>(</span><span class='id identifier rubyid_branch2'>branch2</span><span class='rparen'>)</span><span class='period'>.</span><span class='id identifier rubyid_value!'>value!</span>              <span class='comment'># =&gt; [1, 1]
</span><span class='lparen'>(</span><span class='id identifier rubyid_branch1'>branch1</span> <span class='op'>&amp;</span> <span class='id identifier rubyid_branch2'>branch2</span><span class='rparen'>)</span><span class='period'>.</span>
    <span class='id identifier rubyid_then'>then</span> <span class='lbrace'>{</span> <span class='op'>|</span><span class='id identifier rubyid_a'>a</span><span class='comma'>,</span> <span class='id identifier rubyid_b'>b</span><span class='op'>|</span> <span class='id identifier rubyid_a'>a</span> <span class='op'>+</span> <span class='id identifier rubyid_b'>b</span> <span class='rbrace'>}</span><span class='period'>.</span>
    <span class='id identifier rubyid_value!'>value!</span>                               <span class='comment'># =&gt; 2
</span><span class='lparen'>(</span><span class='id identifier rubyid_branch1'>branch1</span> <span class='op'>&amp;</span> <span class='id identifier rubyid_branch2'>branch2</span><span class='rparen'>)</span><span class='period'>.</span>
    <span class='id identifier rubyid_then'>then</span><span class='lparen'>(</span><span class='op'>&amp;</span><span class='symbol'>:+</span><span class='rparen'>)</span><span class='period'>.</span>
    <span class='id identifier rubyid_value!'>value!</span>                               <span class='comment'># =&gt; 2
</span><span class='const'>Concurrent</span><span class='op'>::</span><span class='const'>Promises</span><span class='period'>.</span>
    <span class='id identifier rubyid_zip'>zip</span><span class='lparen'>(</span><span class='id identifier rubyid_branch1'>branch1</span><span class='comma'>,</span> <span class='id identifier rubyid_branch2'>branch2</span><span class='comma'>,</span> <span class='id identifier rubyid_branch1'>branch1</span><span class='rparen'>)</span><span class='period'>.</span>
    <span class='id identifier rubyid_then'>then</span> <span class='lbrace'>{</span> <span class='op'>|</span><span class='op'>*</span><span class='id identifier rubyid_values'>values</span><span class='op'>|</span> <span class='id identifier rubyid_values'>values</span><span class='period'>.</span><span class='id identifier rubyid_reduce'>reduce</span><span class='lparen'>(</span><span class='op'>&amp;</span><span class='symbol'>:+</span><span class='rparen'>)</span> <span class='rbrace'>}</span><span class='period'>.</span>
    <span class='id identifier rubyid_value!'>value!</span>                               <span class='comment'># =&gt; 3
</span></code></pre>

<p>Instead of zipping only the first one can be taken if needed.</p>

<pre class="code ruby"><code class="ruby"><span class='const'>Concurrent</span><span class='op'>::</span><span class='const'>Promises</span><span class='period'>.</span><span class='id identifier rubyid_any'>any</span><span class='lparen'>(</span><span class='id identifier rubyid_branch1'>branch1</span><span class='comma'>,</span> <span class='id identifier rubyid_branch2'>branch2</span><span class='rparen'>)</span><span class='period'>.</span><span class='id identifier rubyid_value!'>value!</span>
<span class='comment'># =&gt; 1
</span><span class='lparen'>(</span><span class='id identifier rubyid_branch1'>branch1</span> <span class='op'>|</span> <span class='id identifier rubyid_branch2'>branch2</span><span class='rparen'>)</span><span class='period'>.</span><span class='id identifier rubyid_value!'>value!</span>               <span class='comment'># =&gt; 1
</span></code></pre>

<h2>Blocking methods</h2>

<p>In these examples we have used blocking methods like <code>value</code> extensively for
their convenience, however in practice is better to avoid them and continue
chaining.</p>

<p>If they need to be used (e.g. when integrating with threads), <code>value!</code> is a
better option over <code>value</code> when rejections are not dealt with differently.
Otherwise the rejection are not handled and probably silently forgotten.</p>

<h2>Error handling</h2>

<p>When one of the tasks in the chain fails, the rejection propagates down the
chain without executing the tasks created with <code>then</code>.</p>

<pre class="code ruby"><code class="ruby"><span class='const'>Concurrent</span><span class='op'>::</span><span class='const'>Promises</span><span class='period'>.</span>
    <span class='id identifier rubyid_fulfilled_future'>fulfilled_future</span><span class='lparen'>(</span><span class='const'>Object</span><span class='period'>.</span><span class='id identifier rubyid_new'>new</span><span class='rparen'>)</span><span class='period'>.</span>
    <span class='id identifier rubyid_then'>then</span><span class='lparen'>(</span><span class='op'>&amp;</span><span class='symbol'>:succ</span><span class='rparen'>)</span><span class='period'>.</span>
    <span class='id identifier rubyid_then'>then</span><span class='lparen'>(</span><span class='op'>&amp;</span><span class='symbol'>:succ</span><span class='rparen'>)</span><span class='period'>.</span>
    <span class='id identifier rubyid_result'>result</span>
<span class='comment'># =&gt; [false,
</span><span class='comment'>#     nil,
</span><span class='comment'>#     #&lt;NoMethodError: undefined method `succ&#39; for #&lt;Object:0x0000000000000003&gt;&gt;]
</span></code></pre>

<p>As <code>then</code> chained tasks execute only on fulfilled futures, there is a <code>rescue</code>
method which chains a task which is executed only when the future is rejected. 
It can be used to recover from rejection.</p>

<p>Using rescue to fulfill to 0 instead of the error.</p>

<pre class="code ruby"><code class="ruby"><span class='const'>Concurrent</span><span class='op'>::</span><span class='const'>Promises</span><span class='period'>.</span>
    <span class='id identifier rubyid_fulfilled_future'>fulfilled_future</span><span class='lparen'>(</span><span class='const'>Object</span><span class='period'>.</span><span class='id identifier rubyid_new'>new</span><span class='rparen'>)</span><span class='period'>.</span>
    <span class='id identifier rubyid_then'>then</span><span class='lparen'>(</span><span class='op'>&amp;</span><span class='symbol'>:succ</span><span class='rparen'>)</span><span class='period'>.</span>
    <span class='id identifier rubyid_then'>then</span><span class='lparen'>(</span><span class='op'>&amp;</span><span class='symbol'>:succ</span><span class='rparen'>)</span><span class='period'>.</span>
    <span class='id identifier rubyid_rescue'>rescue</span> <span class='lbrace'>{</span> <span class='op'>|</span><span class='id identifier rubyid_err'>err</span><span class='op'>|</span> <span class='int'>0</span> <span class='rbrace'>}</span><span class='period'>.</span>
    <span class='id identifier rubyid_result'>result</span>                               <span class='comment'># =&gt; [true, 0, nil]
</span></code></pre>

<p>Rescue not executed when there is no rejection.</p>

<pre class="code ruby"><code class="ruby"><span class='const'>Concurrent</span><span class='op'>::</span><span class='const'>Promises</span><span class='period'>.</span>
    <span class='id identifier rubyid_fulfilled_future'>fulfilled_future</span><span class='lparen'>(</span><span class='int'>1</span><span class='rparen'>)</span><span class='period'>.</span>
    <span class='id identifier rubyid_then'>then</span><span class='lparen'>(</span><span class='op'>&amp;</span><span class='symbol'>:succ</span><span class='rparen'>)</span><span class='period'>.</span>
    <span class='id identifier rubyid_then'>then</span><span class='lparen'>(</span><span class='op'>&amp;</span><span class='symbol'>:succ</span><span class='rparen'>)</span><span class='period'>.</span>
    <span class='id identifier rubyid_rescue'>rescue</span> <span class='lbrace'>{</span> <span class='op'>|</span><span class='id identifier rubyid_e'>e</span><span class='op'>|</span> <span class='int'>0</span> <span class='rbrace'>}</span><span class='period'>.</span> 
    <span class='id identifier rubyid_result'>result</span>                               <span class='comment'># =&gt; [true, 3, nil]
</span></code></pre>

<p>Tasks added with <code>chain</code> are evaluated always.</p>

<pre class="code ruby"><code class="ruby"><span class='const'>Concurrent</span><span class='op'>::</span><span class='const'>Promises</span><span class='period'>.</span>
    <span class='id identifier rubyid_fulfilled_future'>fulfilled_future</span><span class='lparen'>(</span><span class='int'>1</span><span class='rparen'>)</span><span class='period'>.</span>
    <span class='id identifier rubyid_chain'>chain</span> <span class='lbrace'>{</span> <span class='op'>|</span><span class='id identifier rubyid_fulfilled'>fulfilled</span><span class='comma'>,</span> <span class='id identifier rubyid_value'>value</span><span class='comma'>,</span> <span class='id identifier rubyid_reason'>reason</span><span class='op'>|</span> <span class='id identifier rubyid_fulfilled'>fulfilled</span> <span class='op'>?</span> <span class='id identifier rubyid_value'>value</span> <span class='op'>:</span> <span class='id identifier rubyid_reason'>reason</span> <span class='rbrace'>}</span><span class='period'>.</span>
    <span class='id identifier rubyid_value!'>value!</span>                               <span class='comment'># =&gt; 1
</span><span class='const'>Concurrent</span><span class='op'>::</span><span class='const'>Promises</span><span class='period'>.</span>
    <span class='id identifier rubyid_rejected_future'>rejected_future</span><span class='lparen'>(</span><span class='const'>StandardError</span><span class='period'>.</span><span class='id identifier rubyid_new'>new</span><span class='lparen'>(</span><span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>Ups</span><span class='tstring_end'>&#39;</span></span><span class='rparen'>)</span><span class='rparen'>)</span><span class='period'>.</span>
    <span class='id identifier rubyid_chain'>chain</span> <span class='lbrace'>{</span> <span class='op'>|</span><span class='id identifier rubyid_fulfilled'>fulfilled</span><span class='comma'>,</span> <span class='id identifier rubyid_value'>value</span><span class='comma'>,</span> <span class='id identifier rubyid_reason'>reason</span><span class='op'>|</span> <span class='id identifier rubyid_fulfilled'>fulfilled</span> <span class='op'>?</span> <span class='id identifier rubyid_value'>value</span> <span class='op'>:</span> <span class='id identifier rubyid_reason'>reason</span> <span class='rbrace'>}</span><span class='period'>.</span>
    <span class='id identifier rubyid_value!'>value!</span>                               <span class='comment'># =&gt; #&lt;StandardError: Ups&gt;
</span></code></pre>

<p>Zip is rejected if any of the zipped futures is.</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_rejected_zip'>rejected_zip</span> <span class='op'>=</span> <span class='const'>Concurrent</span><span class='op'>::</span><span class='const'>Promises</span><span class='period'>.</span><span class='id identifier rubyid_zip'>zip</span><span class='lparen'>(</span>
    <span class='const'>Concurrent</span><span class='op'>::</span><span class='const'>Promises</span><span class='period'>.</span><span class='id identifier rubyid_fulfilled_future'>fulfilled_future</span><span class='lparen'>(</span><span class='int'>1</span><span class='rparen'>)</span><span class='comma'>,</span>
    <span class='const'>Concurrent</span><span class='op'>::</span><span class='const'>Promises</span><span class='period'>.</span><span class='id identifier rubyid_rejected_future'>rejected_future</span><span class='lparen'>(</span><span class='const'>StandardError</span><span class='period'>.</span><span class='id identifier rubyid_new'>new</span><span class='lparen'>(</span><span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>Ups</span><span class='tstring_end'>&#39;</span></span><span class='rparen'>)</span><span class='rparen'>)</span><span class='rparen'>)</span>
<span class='comment'># =&gt; &lt;#Concurrent::Promises::Future:0x7fb5e19c6640 rejected&gt;
</span><span class='id identifier rubyid_rejected_zip'>rejected_zip</span><span class='period'>.</span><span class='id identifier rubyid_result'>result</span>
<span class='comment'># =&gt; [false, [1, nil], [nil, #&lt;StandardError: Ups&gt;]]
</span><span class='id identifier rubyid_rejected_zip'>rejected_zip</span><span class='period'>.</span>
    <span class='id identifier rubyid_rescue'>rescue</span> <span class='lbrace'>{</span> <span class='op'>|</span><span class='id identifier rubyid_reason1'>reason1</span><span class='comma'>,</span> <span class='id identifier rubyid_reason2'>reason2</span><span class='op'>|</span> <span class='lparen'>(</span><span class='id identifier rubyid_reason1'>reason1</span> <span class='op'>||</span> <span class='id identifier rubyid_reason2'>reason2</span><span class='rparen'>)</span><span class='period'>.</span><span class='id identifier rubyid_message'>message</span> <span class='rbrace'>}</span><span class='period'>.</span>
    <span class='id identifier rubyid_value'>value</span>                                <span class='comment'># =&gt; &quot;Ups&quot;
</span></code></pre>

<h2>Delayed futures</h2>

<p>Delayed futures will not evaluate until asked by <code>touch</code> or other method
requiring resolution. </p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_future'>future</span> <span class='op'>=</span> <span class='const'>Concurrent</span><span class='op'>::</span><span class='const'>Promises</span><span class='period'>.</span><span class='id identifier rubyid_delay'>delay</span> <span class='lbrace'>{</span> <span class='id identifier rubyid_sleep'>sleep</span> <span class='float'>0.1</span><span class='semicolon'>;</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>lazy</span><span class='tstring_end'>&#39;</span></span> <span class='rbrace'>}</span>
<span class='comment'># =&gt; &lt;#Concurrent::Promises::Future:0x7fb5e19b60d8 pending&gt;
</span><span class='id identifier rubyid_sleep'>sleep</span> <span class='float'>0.1</span> 
<span class='id identifier rubyid_future'>future</span><span class='period'>.</span><span class='id identifier rubyid_resolved?'>resolved?</span>                         <span class='comment'># =&gt; false
</span><span class='id identifier rubyid_future'>future</span><span class='period'>.</span><span class='id identifier rubyid_touch'>touch</span>
<span class='comment'># =&gt; &lt;#Concurrent::Promises::Future:0x7fb5e19b60d8 pending&gt;
</span><span class='id identifier rubyid_sleep'>sleep</span> <span class='float'>0.2</span> 
<span class='id identifier rubyid_future'>future</span><span class='period'>.</span><span class='id identifier rubyid_resolved?'>resolved?</span>                         <span class='comment'># =&gt; true
</span></code></pre>

<p>All blocking methods like <code>wait</code>, <code>value</code> call <code>touch</code> and trigger evaluation.</p>

<pre class="code ruby"><code class="ruby"><span class='const'>Concurrent</span><span class='op'>::</span><span class='const'>Promises</span><span class='period'>.</span><span class='id identifier rubyid_delay'>delay</span> <span class='lbrace'>{</span> <span class='symbol'>:value</span> <span class='rbrace'>}</span><span class='period'>.</span><span class='id identifier rubyid_value'>value</span>
<span class='comment'># =&gt; :value
</span></code></pre>

<p>It propagates trough chain up allowing whole or partial lazy chains.</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_head'>head</span>    <span class='op'>=</span> <span class='const'>Concurrent</span><span class='op'>::</span><span class='const'>Promises</span><span class='period'>.</span><span class='id identifier rubyid_delay'>delay</span> <span class='lbrace'>{</span> <span class='int'>1</span> <span class='rbrace'>}</span> 
<span class='id identifier rubyid_branch1'>branch1</span> <span class='op'>=</span> <span class='id identifier rubyid_head'>head</span><span class='period'>.</span><span class='id identifier rubyid_then'>then</span><span class='lparen'>(</span><span class='op'>&amp;</span><span class='symbol'>:succ</span><span class='rparen'>)</span> 
<span class='id identifier rubyid_branch2'>branch2</span> <span class='op'>=</span> <span class='id identifier rubyid_head'>head</span><span class='period'>.</span><span class='id identifier rubyid_delay'>delay</span><span class='period'>.</span><span class='id identifier rubyid_then'>then</span><span class='lparen'>(</span><span class='op'>&amp;</span><span class='symbol'>:succ</span><span class='rparen'>)</span> 
<span class='id identifier rubyid_join'>join</span>    <span class='op'>=</span> <span class='id identifier rubyid_branch1'>branch1</span> <span class='op'>&amp;</span> <span class='id identifier rubyid_branch2'>branch2</span> 

<span class='id identifier rubyid_sleep'>sleep</span> <span class='float'>0.1</span> 
</code></pre>

<p>Nothing resolves.</p>

<pre class="code ruby"><code class="ruby"><span class='lbracket'>[</span><span class='id identifier rubyid_head'>head</span><span class='comma'>,</span> <span class='id identifier rubyid_branch1'>branch1</span><span class='comma'>,</span> <span class='id identifier rubyid_branch2'>branch2</span><span class='comma'>,</span> <span class='id identifier rubyid_join'>join</span><span class='rbracket'>]</span><span class='period'>.</span><span class='id identifier rubyid_map'>map</span><span class='lparen'>(</span><span class='op'>&amp;</span><span class='symbol'>:resolved?</span><span class='rparen'>)</span>
<span class='comment'># =&gt; [false, false, false, false]
</span></code></pre>

<p>Force <code>branch1</code> evaluation.</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_branch1'>branch1</span><span class='period'>.</span><span class='id identifier rubyid_value'>value</span>                            <span class='comment'># =&gt; 2
</span><span class='id identifier rubyid_sleep'>sleep</span> <span class='float'>0.1</span> 
<span class='lbracket'>[</span><span class='id identifier rubyid_head'>head</span><span class='comma'>,</span> <span class='id identifier rubyid_branch1'>branch1</span><span class='comma'>,</span> <span class='id identifier rubyid_branch2'>branch2</span><span class='comma'>,</span> <span class='id identifier rubyid_join'>join</span><span class='rbracket'>]</span><span class='period'>.</span><span class='id identifier rubyid_map'>map</span><span class='lparen'>(</span><span class='op'>&amp;</span><span class='symbol'>:resolved?</span><span class='rparen'>)</span>
<span class='comment'># =&gt; [true, true, false, false]
</span></code></pre>

<p>Force evaluation of both by calling <code>value</code> on <code>join</code>.</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_join'>join</span><span class='period'>.</span><span class='id identifier rubyid_value'>value</span>                               <span class='comment'># =&gt; [2, 2]
</span><span class='lbracket'>[</span><span class='id identifier rubyid_head'>head</span><span class='comma'>,</span> <span class='id identifier rubyid_branch1'>branch1</span><span class='comma'>,</span> <span class='id identifier rubyid_branch2'>branch2</span><span class='comma'>,</span> <span class='id identifier rubyid_join'>join</span><span class='rbracket'>]</span><span class='period'>.</span><span class='id identifier rubyid_map'>map</span><span class='lparen'>(</span><span class='op'>&amp;</span><span class='symbol'>:resolved?</span><span class='rparen'>)</span>
<span class='comment'># =&gt; [true, true, true, true]
</span></code></pre>

<h2>Flatting</h2>

<p>Sometimes it is needed to wait for a inner future. Apparent solution is to wait
inside the future <code>Concurrent::Promises.future { Concurrent::Promises.future { 1+1 }.value }.value</code>
however as mentioned before, <code>value</code> calls should be <strong>avoided</strong> to avoid
blocking threads. Therefore there is a flat method which is a correct solution
in this situation and does not block any thread.</p>

<pre class="code ruby"><code class="ruby"><span class='const'>Concurrent</span><span class='op'>::</span><span class='const'>Promises</span><span class='period'>.</span><span class='id identifier rubyid_future'>future</span> <span class='lbrace'>{</span> <span class='const'>Concurrent</span><span class='op'>::</span><span class='const'>Promises</span><span class='period'>.</span><span class='id identifier rubyid_future'>future</span> <span class='lbrace'>{</span> <span class='int'>1</span><span class='op'>+</span><span class='int'>1</span> <span class='rbrace'>}</span> <span class='rbrace'>}</span><span class='period'>.</span><span class='id identifier rubyid_flat'>flat</span><span class='period'>.</span><span class='id identifier rubyid_value!'>value!</span>
<span class='comment'># =&gt; 2
</span></code></pre>

<p>A more complicated example.</p>

<pre class="code ruby"><code class="ruby"><span class='const'>Concurrent</span><span class='op'>::</span><span class='const'>Promises</span><span class='period'>.</span>
    <span class='id identifier rubyid_future'>future</span> <span class='lbrace'>{</span> <span class='const'>Concurrent</span><span class='op'>::</span><span class='const'>Promises</span><span class='period'>.</span><span class='id identifier rubyid_future'>future</span> <span class='lbrace'>{</span> <span class='const'>Concurrent</span><span class='op'>::</span><span class='const'>Promises</span><span class='period'>.</span><span class='id identifier rubyid_future'>future</span> <span class='lbrace'>{</span> <span class='int'>1</span> <span class='op'>+</span> <span class='int'>1</span> <span class='rbrace'>}</span> <span class='rbrace'>}</span> <span class='rbrace'>}</span><span class='period'>.</span>
    <span class='id identifier rubyid_flat'>flat</span><span class='lparen'>(</span><span class='int'>1</span><span class='rparen'>)</span><span class='period'>.</span>
    <span class='id identifier rubyid_then'>then</span> <span class='lbrace'>{</span> <span class='op'>|</span><span class='id identifier rubyid_future'>future</span><span class='op'>|</span> <span class='id identifier rubyid_future'>future</span><span class='period'>.</span><span class='id identifier rubyid_then'>then</span><span class='lparen'>(</span><span class='op'>&amp;</span><span class='symbol'>:succ</span><span class='rparen'>)</span> <span class='rbrace'>}</span><span class='period'>.</span>
    <span class='id identifier rubyid_flat'>flat</span><span class='lparen'>(</span><span class='int'>1</span><span class='rparen'>)</span><span class='period'>.</span>
    <span class='id identifier rubyid_value!'>value!</span>                               <span class='comment'># =&gt; 3
</span></code></pre>

<h2>Scheduling</h2>

<p>Tasks can be planned to be executed with a time delay.</p>

<p>Schedule task to be executed in 0.1 seconds.</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_scheduled'>scheduled</span> <span class='op'>=</span> <span class='const'>Concurrent</span><span class='op'>::</span><span class='const'>Promises</span><span class='period'>.</span><span class='id identifier rubyid_schedule'>schedule</span><span class='lparen'>(</span><span class='float'>0.1</span><span class='rparen'>)</span> <span class='lbrace'>{</span> <span class='int'>1</span> <span class='rbrace'>}</span>
<span class='comment'># =&gt; &lt;#Concurrent::Promises::Future:0x7fb5e118f670 pending&gt;
</span><span class='id identifier rubyid_scheduled'>scheduled</span><span class='period'>.</span><span class='id identifier rubyid_resolved?'>resolved?</span>                      <span class='comment'># =&gt; false
</span></code></pre>

<p>Value will become available after 0.1 seconds. </p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_scheduled'>scheduled</span><span class='period'>.</span><span class='id identifier rubyid_value'>value</span>                          <span class='comment'># =&gt; 1
</span></code></pre>

<p>It can be used in the chain as well, where the delay is counted form a moment
its parent resolves. Therefore following future will be resolved in 0.2 seconds.</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_future'>future</span> <span class='op'>=</span> <span class='const'>Concurrent</span><span class='op'>::</span><span class='const'>Promises</span><span class='period'>.</span>
    <span class='id identifier rubyid_future'>future</span> <span class='lbrace'>{</span> <span class='id identifier rubyid_sleep'>sleep</span> <span class='float'>0.1</span><span class='semicolon'>;</span> <span class='symbol'>:result</span> <span class='rbrace'>}</span><span class='period'>.</span>
    <span class='id identifier rubyid_schedule'>schedule</span><span class='lparen'>(</span><span class='float'>0.1</span><span class='rparen'>)</span><span class='period'>.</span>
    <span class='id identifier rubyid_then'>then</span><span class='lparen'>(</span><span class='op'>&amp;</span><span class='symbol'>:to_s</span><span class='rparen'>)</span><span class='period'>.</span>
    <span class='id identifier rubyid_value!'>value!</span>                               <span class='comment'># =&gt; &quot;result&quot;
</span></code></pre>

<p>Time can be used as well.</p>

<pre class="code ruby"><code class="ruby"><span class='const'>Concurrent</span><span class='op'>::</span><span class='const'>Promises</span><span class='period'>.</span><span class='id identifier rubyid_schedule'>schedule</span><span class='lparen'>(</span><span class='const'>Time</span><span class='period'>.</span><span class='id identifier rubyid_now'>now</span> <span class='op'>+</span> <span class='int'>10</span><span class='rparen'>)</span> <span class='lbrace'>{</span> <span class='symbol'>:val</span> <span class='rbrace'>}</span>
<span class='comment'># =&gt; &lt;#Concurrent::Promises::Future:0x7fb5e1868cd0 pending&gt;
</span></code></pre>

<h2>Resolvable Future and Event:</h2>

<p>Sometimes it is required to resolve a future externally, in these cases
<code>resolvable_future</code> and <code>resolvable_event</code> factory methods can be uses. See
<span class='object_link'><a href="Concurrent/Promises/ResolvableFuture.html" title="Concurrent::Promises::ResolvableFuture (class)">Concurrent::Promises::ResolvableFuture</a></span> and
<span class='object_link'><a href="Concurrent/Promises/ResolvableEvent.html" title="Concurrent::Promises::ResolvableEvent (class)">Concurrent::Promises::ResolvableEvent</a></span>.</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_future'>future</span> <span class='op'>=</span> <span class='const'>Concurrent</span><span class='op'>::</span><span class='const'>Promises</span><span class='period'>.</span><span class='id identifier rubyid_resolvable_future'>resolvable_future</span>
<span class='comment'># =&gt; &lt;#Concurrent::Promises::ResolvableFuture:0x7fb5e225bf80 pending&gt;
</span></code></pre>

<p>The thread will be blocked until the future is resolved</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_thread'>thread</span> <span class='op'>=</span> <span class='const'>Thread</span><span class='period'>.</span><span class='id identifier rubyid_new'>new</span> <span class='lbrace'>{</span> <span class='id identifier rubyid_future'>future</span><span class='period'>.</span><span class='id identifier rubyid_value'>value</span> <span class='rbrace'>}</span> 
<span class='id identifier rubyid_future'>future</span><span class='period'>.</span><span class='id identifier rubyid_fulfill'>fulfill</span> <span class='int'>1</span>
<span class='comment'># =&gt; &lt;#Concurrent::Promises::ResolvableFuture:0x7fb5e225bf80 fulfilled&gt;
</span><span class='id identifier rubyid_thread'>thread</span><span class='period'>.</span><span class='id identifier rubyid_value'>value</span>                             <span class='comment'># =&gt; 1
</span></code></pre>

<p>Future can be resolved only once.</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_future'>future</span><span class='period'>.</span><span class='id identifier rubyid_fulfill'>fulfill</span> <span class='int'>1</span> <span class='kw'>rescue</span> <span class='gvar'>$!</span>
<span class='comment'># =&gt; #&lt;Concurrent::MultipleAssignmentError: Future can be resolved only once. It&#39;s [true, 1, nil], trying to set [true, 1, nil]. {:current_result=&gt;[true, 1, nil], :new_result=&gt;[true, 1, nil]}&gt;
</span><span class='id identifier rubyid_future'>future</span><span class='period'>.</span><span class='id identifier rubyid_fulfill'>fulfill</span> <span class='int'>2</span><span class='comma'>,</span> <span class='kw'>false</span>                  <span class='comment'># =&gt; false
</span></code></pre>

<h2>How are promises executed?</h2>

<p>Promises use global pools to execute the tasks. Therefore each task may run on
different thread which implies that users have to be careful not to depend on
Thread local variables (or they have to set at the begging of the task and
cleaned up at the end of the task).</p>

<p>Since the tasks are running on may different threads of the thread pool, it&#39;s
better to follow following rules:</p>

<ul>
<li>  Use only data passed in through arguments or values of parent futures, to 
have better control over what are futures accessing.</li>
<li>  The data passed in and out of futures are easier to deal with if they are 
immutable or at least treated as such.</li>
<li>  Any mutable and mutated object accessed by more than one threads or futures 
must be thread safe, see <span class='object_link'><a href="Concurrent/Array.html" title="Concurrent::Array (class)">Concurrent::Array</a></span>, <span class='object_link'><a href="Concurrent/Hash.html" title="Concurrent::Hash (class)">Concurrent::Hash</a></span>, and 
<span class='object_link'><a href="Concurrent/Map.html" title="Concurrent::Map (class)">Concurrent::Map</a></span>. (Value of a future may be consumed by many futures.)</li>
<li>  Futures can access outside objects, but they has to be thread-safe.</li>
</ul>

<blockquote>
<p><em>TODO: This part to be extended</em></p>
</blockquote>

<h1>Advanced</h1>

<h2>Callbacks</h2>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_queue'>queue</span>  <span class='op'>=</span> <span class='const'>Queue</span><span class='period'>.</span><span class='id identifier rubyid_new'>new</span>                       <span class='comment'># =&gt; #&lt;Thread::Queue:0x0000000000000004&gt;
</span><span class='id identifier rubyid_future'>future</span> <span class='op'>=</span> <span class='const'>Concurrent</span><span class='op'>::</span><span class='const'>Promises</span><span class='period'>.</span><span class='id identifier rubyid_delay'>delay</span> <span class='lbrace'>{</span> <span class='int'>1</span> <span class='op'>+</span> <span class='int'>1</span> <span class='rbrace'>}</span>
<span class='comment'># =&gt; &lt;#Concurrent::Promises::Future:0x7fb5e222a610 pending&gt;
</span>
<span class='id identifier rubyid_future'>future</span><span class='period'>.</span><span class='id identifier rubyid_on_fulfillment'>on_fulfillment</span> <span class='lbrace'>{</span> <span class='id identifier rubyid_queue'>queue</span> <span class='op'>&lt;&lt;</span> <span class='int'>1</span> <span class='rbrace'>}</span> <span class='comment'># evaluated asynchronously
</span><span class='id identifier rubyid_future'>future</span><span class='period'>.</span><span class='id identifier rubyid_on_fulfillment!'>on_fulfillment!</span> <span class='lbrace'>{</span> <span class='id identifier rubyid_queue'>queue</span> <span class='op'>&lt;&lt;</span> <span class='int'>2</span> <span class='rbrace'>}</span> <span class='comment'># evaluated on resolving thread
</span>
<span class='id identifier rubyid_queue'>queue</span><span class='period'>.</span><span class='id identifier rubyid_empty?'>empty?</span>                             <span class='comment'># =&gt; true
</span><span class='id identifier rubyid_future'>future</span><span class='period'>.</span><span class='id identifier rubyid_value'>value</span>                             <span class='comment'># =&gt; 2
</span><span class='id identifier rubyid_queue'>queue</span><span class='period'>.</span><span class='id identifier rubyid_pop'>pop</span>                                <span class='comment'># =&gt; 2
</span><span class='id identifier rubyid_queue'>queue</span><span class='period'>.</span><span class='id identifier rubyid_pop'>pop</span>                                <span class='comment'># =&gt; 1
</span></code></pre>

<h2>Using executors</h2>

<p>Factory methods, chain, and callback methods have all other version of them
which takes executor argument.</p>

<p>It takes an instance of an executor or a symbol which is a shortcuts for the
two global pools in concurrent-ruby. <code>fast</code> for short and non-blocking tasks
and <code>:io</code> for blocking and long tasks.</p>

<pre class="code ruby"><code class="ruby"><span class='const'>Concurrent</span><span class='op'>::</span><span class='const'>Promises</span><span class='period'>.</span><span class='id identifier rubyid_future_on'>future_on</span><span class='lparen'>(</span><span class='symbol'>:fast</span><span class='rparen'>)</span> <span class='lbrace'>{</span> <span class='int'>2</span> <span class='rbrace'>}</span><span class='period'>.</span>
    <span class='id identifier rubyid_then_on'>then_on</span><span class='lparen'>(</span><span class='symbol'>:io</span><span class='rparen'>)</span> <span class='lbrace'>{</span> <span class='const'>File</span><span class='period'>.</span><span class='id identifier rubyid_read'>read</span> <span class='kw'>__FILE__</span> <span class='rbrace'>}</span><span class='period'>.</span>
    <span class='id identifier rubyid_value'>value</span><span class='period'>.</span><span class='id identifier rubyid_size'>size</span>                           <span class='comment'># =&gt; 26689
</span></code></pre>

<h2>Run (simulated process)</h2>

<p>Similar to flatting is running. When <code>run</code> is called on a future it will flat
indefinitely as long the future fulfils into a <code>Future</code> value. It can be used
to simulate a thread like processing without actually occupying the thread.</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_count'>count</span> <span class='op'>=</span> <span class='id identifier rubyid_lambda'>lambda</span> <span class='kw'>do</span> <span class='op'>|</span><span class='id identifier rubyid_v'>v</span><span class='op'>|</span>
  <span class='id identifier rubyid_v'>v</span> <span class='op'>+=</span> <span class='int'>1</span>
  <span class='id identifier rubyid_v'>v</span> <span class='op'>&lt;</span> <span class='int'>5</span> <span class='op'>?</span> <span class='const'>Concurrent</span><span class='op'>::</span><span class='const'>Promises</span><span class='period'>.</span><span class='id identifier rubyid_future_on'>future_on</span><span class='lparen'>(</span><span class='symbol'>:fast</span><span class='comma'>,</span> <span class='id identifier rubyid_v'>v</span><span class='comma'>,</span> <span class='op'>&amp;</span><span class='id identifier rubyid_count'>count</span><span class='rparen'>)</span> <span class='op'>:</span> <span class='id identifier rubyid_v'>v</span>
<span class='kw'>end</span>
<span class='comment'># =&gt; #&lt;Proc:0x0000000000000005@promises.in.md:511 (lambda)&gt;
</span><span class='int'>400</span><span class='period'>.</span><span class='id identifier rubyid_times'>times</span><span class='period'>.</span>
    <span class='id identifier rubyid_map'>map</span> <span class='lbrace'>{</span> <span class='const'>Concurrent</span><span class='op'>::</span><span class='const'>Promises</span><span class='period'>.</span><span class='id identifier rubyid_future_on'>future_on</span><span class='lparen'>(</span><span class='symbol'>:fast</span><span class='comma'>,</span> <span class='int'>0</span><span class='comma'>,</span> <span class='op'>&amp;</span><span class='id identifier rubyid_count'>count</span><span class='rparen'>)</span><span class='period'>.</span><span class='id identifier rubyid_run'>run</span><span class='period'>.</span><span class='id identifier rubyid_value!'>value!</span> <span class='rbrace'>}</span><span class='period'>.</span>
    <span class='id identifier rubyid_all?'>all?</span> <span class='lbrace'>{</span> <span class='op'>|</span><span class='id identifier rubyid_v'>v</span><span class='op'>|</span> <span class='id identifier rubyid_v'>v</span> <span class='op'>==</span> <span class='int'>5</span> <span class='rbrace'>}</span>                  <span class='comment'># =&gt; true
</span></code></pre>

<p>Therefore the above example finished fine on the the <code>:fast</code> thread pool even
though it has much less threads than there is the simulated process.</p>

<h1>Interoperability</h1>

<h2>Actors</h2>

<p>Create an actor which takes received numbers and returns the number squared. </p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_actor'>actor</span> <span class='op'>=</span> <span class='const'>Concurrent</span><span class='op'>::</span><span class='const'>Actor</span><span class='op'>::</span><span class='const'>Utils</span><span class='op'>::</span><span class='const'>AdHoc</span><span class='period'>.</span><span class='id identifier rubyid_spawn'>spawn</span> <span class='symbol'>:square</span> <span class='kw'>do</span>
  <span class='tlambda'>-&gt;</span> <span class='id identifier rubyid_v'>v</span> <span class='tlambeg'>{</span> <span class='id identifier rubyid_v'>v</span> <span class='op'>**</span> <span class='int'>2</span> <span class='rbrace'>}</span>
<span class='kw'>end</span>
<span class='comment'># =&gt; #&lt;Concurrent::Actor::Reference:0x7fb5e08190f0 /square (Concurrent::Actor::Utils::AdHoc)&gt;
</span></code></pre>

<p>Send result of <code>1+1</code> to the actor, and add 2 to the result send back from the
actor.</p>

<pre class="code ruby"><code class="ruby"><span class='const'>Concurrent</span><span class='op'>::</span><span class='const'>Promises</span><span class='period'>.</span>
    <span class='id identifier rubyid_future'>future</span> <span class='lbrace'>{</span> <span class='int'>1</span> <span class='op'>+</span> <span class='int'>1</span> <span class='rbrace'>}</span><span class='period'>.</span>
    <span class='id identifier rubyid_then_ask'>then_ask</span><span class='lparen'>(</span><span class='id identifier rubyid_actor'>actor</span><span class='rparen'>)</span><span class='period'>.</span>
    <span class='id identifier rubyid_then'>then</span> <span class='lbrace'>{</span> <span class='op'>|</span><span class='id identifier rubyid_v'>v</span><span class='op'>|</span> <span class='id identifier rubyid_v'>v</span> <span class='op'>+</span> <span class='int'>2</span> <span class='rbrace'>}</span><span class='period'>.</span>
    <span class='id identifier rubyid_value!'>value!</span>                               <span class='comment'># =&gt; 6
</span></code></pre>

<p>So <code>(1 + 1)**2 + 2 = 6</code>.</p>

<p>The <code>ask</code> method returns future.</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_actor'>actor</span><span class='period'>.</span><span class='id identifier rubyid_ask'>ask</span><span class='lparen'>(</span><span class='int'>2</span><span class='rparen'>)</span><span class='period'>.</span><span class='id identifier rubyid_then'>then</span><span class='lparen'>(</span><span class='op'>&amp;</span><span class='symbol'>:succ</span><span class='rparen'>)</span><span class='period'>.</span><span class='id identifier rubyid_value!'>value!</span>         <span class='comment'># =&gt; 5
</span></code></pre>

<h2>Channel</h2>

<p>There is an implementation of channel as well. Lets start by creating a
channel with capacity 2 messages.</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_ch1'>ch1</span> <span class='op'>=</span> <span class='const'>Concurrent</span><span class='op'>::</span><span class='const'>Promises</span><span class='op'>::</span><span class='const'>Channel</span><span class='period'>.</span><span class='id identifier rubyid_new'>new</span> <span class='int'>2</span>
<span class='comment'># =&gt; &lt;#Concurrent::Promises::Channel:0x7fb5e1a74128 size:2&gt;
</span></code></pre>

<p>We push 3 messages, it can be observed that the last future representing the
push is not fulfilled since the capacity prevents it. When the work which fills
the channel depends on the futures created by push it can be used to create
back pressure  the filling work is delayed until the channel has space for
more messages.</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_pushes'>pushes</span> <span class='op'>=</span> <span class='int'>3</span><span class='period'>.</span><span class='id identifier rubyid_times'>times</span><span class='period'>.</span><span class='id identifier rubyid_map'>map</span> <span class='lbrace'>{</span> <span class='op'>|</span><span class='id identifier rubyid_i'>i</span><span class='op'>|</span> <span class='id identifier rubyid_ch1'>ch1</span><span class='period'>.</span><span class='id identifier rubyid_push'>push</span> <span class='id identifier rubyid_i'>i</span> <span class='rbrace'>}</span>
<span class='comment'># =&gt; [&lt;#Concurrent::Promises::Future:0x7fb5e1a6d3a0 fulfilled&gt;,
</span><span class='comment'>#     &lt;#Concurrent::Promises::Future:0x7fb5e1a6cae0 fulfilled&gt;,
</span><span class='comment'>#     &lt;#Concurrent::Promises::Future:0x7fb5e1a67ab8 pending&gt;]
</span><span class='id identifier rubyid_ch1'>ch1</span><span class='period'>.</span><span class='id identifier rubyid_pop'>pop</span><span class='period'>.</span><span class='id identifier rubyid_value!'>value!</span>                           <span class='comment'># =&gt; 0
</span><span class='id identifier rubyid_pushes'>pushes</span>
<span class='comment'># =&gt; [&lt;#Concurrent::Promises::Future:0x7fb5e1a6d3a0 fulfilled&gt;,
</span><span class='comment'>#     &lt;#Concurrent::Promises::Future:0x7fb5e1a6cae0 fulfilled&gt;,
</span><span class='comment'>#     &lt;#Concurrent::Promises::Future:0x7fb5e1a67ab8 fulfilled&gt;]
</span></code></pre>

<p>A selection over channels can be created with select_channel factory method. It
will be fulfilled with a first message available in any of the channels. It
returns a pair to be able to find out which channel had the message available.</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_ch2'>ch2</span>    <span class='op'>=</span> <span class='const'>Concurrent</span><span class='op'>::</span><span class='const'>Promises</span><span class='op'>::</span><span class='const'>Channel</span><span class='period'>.</span><span class='id identifier rubyid_new'>new</span> <span class='int'>2</span>
<span class='comment'># =&gt; &lt;#Concurrent::Promises::Channel:0x7fb5e22c8bd0 size:2&gt;
</span><span class='id identifier rubyid_result'>result</span> <span class='op'>=</span> <span class='const'>Concurrent</span><span class='op'>::</span><span class='const'>Promises</span><span class='period'>.</span><span class='id identifier rubyid_select_channel'>select_channel</span><span class='lparen'>(</span><span class='id identifier rubyid_ch1'>ch1</span><span class='comma'>,</span> <span class='id identifier rubyid_ch2'>ch2</span><span class='rparen'>)</span>
<span class='comment'># =&gt; &lt;#Concurrent::Promises::ResolvableFuture:0x7fb5e22c3d38 fulfilled&gt;
</span><span class='id identifier rubyid_result'>result</span><span class='period'>.</span><span class='id identifier rubyid_value!'>value!</span>
<span class='comment'># =&gt; [&lt;#Concurrent::Promises::Channel:0x7fb5e1a74128 size:2&gt;, 1]
</span>
<span class='const'>Concurrent</span><span class='op'>::</span><span class='const'>Promises</span><span class='period'>.</span><span class='id identifier rubyid_future'>future</span> <span class='lbrace'>{</span> <span class='int'>1</span><span class='op'>+</span><span class='int'>1</span> <span class='rbrace'>}</span><span class='period'>.</span><span class='id identifier rubyid_then_push_channel'>then_push_channel</span><span class='lparen'>(</span><span class='id identifier rubyid_ch1'>ch1</span><span class='rparen'>)</span>
<span class='comment'># =&gt; &lt;#Concurrent::Promises::Future:0x7fb5e1a5d860 pending&gt;
</span><span class='id identifier rubyid_result'>result</span> <span class='op'>=</span> <span class='lparen'>(</span>
    <span class='const'>Concurrent</span><span class='op'>::</span><span class='const'>Promises</span><span class='period'>.</span><span class='id identifier rubyid_fulfilled_future'>fulfilled_future</span><span class='lparen'>(</span><span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>%02d</span><span class='tstring_end'>&#39;</span></span><span class='rparen'>)</span> <span class='op'>&amp;</span>      
        <span class='const'>Concurrent</span><span class='op'>::</span><span class='const'>Promises</span><span class='period'>.</span><span class='id identifier rubyid_select_channel'>select_channel</span><span class='lparen'>(</span><span class='id identifier rubyid_ch1'>ch1</span><span class='comma'>,</span> <span class='id identifier rubyid_ch2'>ch2</span><span class='rparen'>)</span><span class='rparen'>)</span><span class='period'>.</span>
    <span class='id identifier rubyid_then'>then</span> <span class='lbrace'>{</span> <span class='op'>|</span><span class='id identifier rubyid_format'>format</span><span class='comma'>,</span> <span class='lparen'>(</span><span class='id identifier rubyid_channel'>channel</span><span class='comma'>,</span> <span class='id identifier rubyid_value'>value</span><span class='rparen'>)</span><span class='op'>|</span> <span class='id identifier rubyid_format'>format</span> <span class='id identifier rubyid_format'>format</span><span class='comma'>,</span> <span class='id identifier rubyid_value'>value</span> <span class='rbrace'>}</span>
<span class='comment'># =&gt; &lt;#Concurrent::Promises::Future:0x7fb5e22b9f90 pending&gt;
</span><span class='id identifier rubyid_result'>result</span><span class='period'>.</span><span class='id identifier rubyid_value!'>value!</span>                            <span class='comment'># =&gt; &quot;02&quot;
</span></code></pre>

<h2>ProcessingActor</h2>

<p>There is also a new implementation of actors based on the Channel and the
ability of promises to simulate process. The actor runs as a process but also
does not occupy a thread per actor as previous Concurrent::Actor
implementation. This implementation is close to Erlang actors, therefore OTP
can be ported for this actors (and it&#39;s planned).</p>

<p>The simplest actor is a one which just computes without even receiving a
message.</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_actor'>actor</span> <span class='op'>=</span> <span class='const'>Concurrent</span><span class='op'>::</span><span class='const'>ProcessingActor</span><span class='period'>.</span><span class='id identifier rubyid_act'>act</span><span class='lparen'>(</span><span class='id identifier rubyid_an_argument'>an_argument</span> <span class='op'>=</span> <span class='int'>2</span><span class='rparen'>)</span> <span class='kw'>do</span> <span class='op'>|</span><span class='id identifier rubyid_actor'>actor</span><span class='comma'>,</span> <span class='id identifier rubyid_number'>number</span><span class='op'>|</span>
  <span class='id identifier rubyid_number'>number</span> <span class='op'>**</span> <span class='int'>3</span>
<span class='kw'>end</span>
<span class='comment'># =&gt; &lt;#Concurrent::ProcessingActor:0x7fb5e1a54490 termination:pending&gt;
</span><span class='id identifier rubyid_actor'>actor</span><span class='period'>.</span><span class='id identifier rubyid_termination'>termination</span><span class='period'>.</span><span class='id identifier rubyid_value!'>value!</span>                 <span class='comment'># =&gt; 8
</span></code></pre>

<p>Let&#39;s receive some messages though.</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_add_2_messages'>add_2_messages</span> <span class='op'>=</span> <span class='const'>Concurrent</span><span class='op'>::</span><span class='const'>ProcessingActor</span><span class='period'>.</span><span class='id identifier rubyid_act'>act</span> <span class='kw'>do</span> <span class='op'>|</span><span class='id identifier rubyid_actor'>actor</span><span class='op'>|</span>
  <span class='comment'># Receive two messages then terminate normally with the sum.
</span>  <span class='lparen'>(</span><span class='id identifier rubyid_actor'>actor</span><span class='period'>.</span><span class='id identifier rubyid_receive'>receive</span> <span class='op'>&amp;</span> <span class='id identifier rubyid_actor'>actor</span><span class='period'>.</span><span class='id identifier rubyid_receive'>receive</span><span class='rparen'>)</span><span class='period'>.</span><span class='id identifier rubyid_then'>then</span> <span class='kw'>do</span> <span class='op'>|</span><span class='id identifier rubyid_a'>a</span><span class='comma'>,</span> <span class='id identifier rubyid_b'>b</span><span class='op'>|</span>
    <span class='id identifier rubyid_a'>a</span> <span class='op'>+</span> <span class='id identifier rubyid_b'>b</span>
  <span class='kw'>end</span>
<span class='kw'>end</span>
<span class='id identifier rubyid_add_2_messages'>add_2_messages</span><span class='period'>.</span><span class='id identifier rubyid_tell'>tell</span> <span class='int'>1</span>
<span class='comment'># =&gt; &lt;#Concurrent::Promises::Future:0x7fb5e1a44518 pending&gt;
</span><span class='id identifier rubyid_add_2_messages'>add_2_messages</span><span class='period'>.</span><span class='id identifier rubyid_termination'>termination</span><span class='period'>.</span><span class='id identifier rubyid_resolved?'>resolved?</span>     <span class='comment'># =&gt; false
</span><span class='id identifier rubyid_add_2_messages'>add_2_messages</span><span class='period'>.</span><span class='id identifier rubyid_tell'>tell</span> <span class='int'>3</span>
<span class='comment'># =&gt; &lt;#Concurrent::Promises::Future:0x7fb5e22a9e10 pending&gt;
</span><span class='id identifier rubyid_add_2_messages'>add_2_messages</span><span class='period'>.</span><span class='id identifier rubyid_termination'>termination</span><span class='period'>.</span><span class='id identifier rubyid_value!'>value!</span>        <span class='comment'># =&gt; 4
</span></code></pre>

<p>Actors can also be used to apply back pressure to a producer. Let&#39;s start by
defining an actor which a mailbox of size 2.</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_slow_counter'>slow_counter</span> <span class='op'>=</span> <span class='tlambda'>-&gt;</span> <span class='lparen'>(</span><span class='id identifier rubyid_actor'>actor</span><span class='comma'>,</span> <span class='id identifier rubyid_count'>count</span><span class='rparen'>)</span> <span class='kw'>do</span>
  <span class='id identifier rubyid_actor'>actor</span><span class='period'>.</span><span class='id identifier rubyid_receive'>receive</span><span class='period'>.</span><span class='id identifier rubyid_then'>then</span> <span class='kw'>do</span> <span class='op'>|</span><span class='id identifier rubyid_command'>command</span><span class='comma'>,</span> <span class='id identifier rubyid_number'>number</span><span class='op'>|</span>
    <span class='id identifier rubyid_sleep'>sleep</span> <span class='float'>0.1</span>
    <span class='kw'>case</span> <span class='id identifier rubyid_command'>command</span>
    <span class='kw'>when</span> <span class='symbol'>:add</span>
      <span class='id identifier rubyid_slow_counter'>slow_counter</span><span class='period'>.</span><span class='id identifier rubyid_call'>call</span> <span class='id identifier rubyid_actor'>actor</span><span class='comma'>,</span> <span class='id identifier rubyid_count'>count</span> <span class='op'>+</span> <span class='id identifier rubyid_number'>number</span>
    <span class='kw'>when</span> <span class='symbol'>:done</span>
      <span class='comment'># terminate
</span>      <span class='id identifier rubyid_count'>count</span>
    <span class='kw'>end</span>
  <span class='kw'>end</span>
<span class='kw'>end</span>

<span class='id identifier rubyid_actor'>actor</span> <span class='op'>=</span> <span class='const'>Concurrent</span><span class='op'>::</span><span class='const'>ProcessingActor</span><span class='period'>.</span><span class='id identifier rubyid_act_listening'>act_listening</span><span class='lparen'>(</span> 
    <span class='const'>Concurrent</span><span class='op'>::</span><span class='const'>Promises</span><span class='op'>::</span><span class='const'>Channel</span><span class='period'>.</span><span class='id identifier rubyid_new'>new</span><span class='lparen'>(</span><span class='int'>2</span><span class='rparen'>)</span><span class='comma'>,</span> 
    <span class='int'>0</span><span class='comma'>,</span>
    <span class='op'>&amp;</span><span class='id identifier rubyid_slow_counter'>slow_counter</span><span class='rparen'>)</span>
<span class='comment'># =&gt; &lt;#Concurrent::ProcessingActor:0x7fb5e11dd960 termination:pending&gt;
</span></code></pre>

<p>Now we can create a producer which will push messages only when there is a
space available in the mailbox. We use promises to free a thread during waiting
on a free space in the mailbox.</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_produce'>produce</span> <span class='op'>=</span> <span class='tlambda'>-&gt;</span> <span class='id identifier rubyid_receiver'>receiver</span><span class='comma'>,</span> <span class='id identifier rubyid_i'>i</span> <span class='kw'>do</span>
  <span class='kw'>if</span> <span class='id identifier rubyid_i'>i</span> <span class='op'>&lt;</span> <span class='int'>10</span>
    <span class='id identifier rubyid_receiver'>receiver</span><span class='period'>.</span>
        <span class='comment'># send a message to the actor, resolves only after the message is 
</span>        <span class='comment'># accepted by the actor&#39;s mailbox
</span>        <span class='id identifier rubyid_tell'>tell</span><span class='lparen'>(</span><span class='lbracket'>[</span><span class='symbol'>:add</span><span class='comma'>,</span> <span class='id identifier rubyid_i'>i</span><span class='rbracket'>]</span><span class='rparen'>)</span><span class='period'>.</span>
        <span class='comment'># send incremented message when the above message is accepted 
</span>        <span class='id identifier rubyid_then'>then</span><span class='lparen'>(</span><span class='id identifier rubyid_i'>i</span><span class='op'>+</span><span class='int'>1</span><span class='comma'>,</span> <span class='op'>&amp;</span><span class='id identifier rubyid_produce'>produce</span><span class='rparen'>)</span>
  <span class='kw'>else</span>
    <span class='id identifier rubyid_receiver'>receiver</span><span class='period'>.</span><span class='id identifier rubyid_tell'>tell</span><span class='lparen'>(</span><span class='symbol'>:done</span><span class='rparen'>)</span>
    <span class='comment'># do not continue 
</span>  <span class='kw'>end</span>
<span class='kw'>end</span>

<span class='const'>Concurrent</span><span class='op'>::</span><span class='const'>Promises</span><span class='period'>.</span><span class='id identifier rubyid_future'>future</span><span class='lparen'>(</span><span class='id identifier rubyid_actor'>actor</span><span class='comma'>,</span> <span class='int'>0</span><span class='comma'>,</span> <span class='op'>&amp;</span><span class='id identifier rubyid_produce'>produce</span><span class='rparen'>)</span><span class='period'>.</span><span class='id identifier rubyid_run'>run</span><span class='period'>.</span><span class='id identifier rubyid_wait!'>wait!</span>
<span class='comment'># =&gt; &lt;#Concurrent::Promises::Future:0x7fb5e1a1fd80 fulfilled&gt;
</span>
<span class='id identifier rubyid_actor'>actor</span><span class='period'>.</span><span class='id identifier rubyid_termination'>termination</span><span class='period'>.</span><span class='id identifier rubyid_value!'>value!</span>                 <span class='comment'># =&gt; 45
</span></code></pre>

<h1>Use-cases</h1>

<h2>Simple background processing</h2>

<pre class="code ruby"><code class="ruby"><span class='const'>Concurrent</span><span class='op'>::</span><span class='const'>Promises</span><span class='period'>.</span><span class='id identifier rubyid_future'>future</span> <span class='lbrace'>{</span> <span class='id identifier rubyid_do_stuff'>do_stuff</span> <span class='rbrace'>}</span>
<span class='comment'># =&gt; &lt;#Concurrent::Promises::Future:0x7fb5e19cff88 pending&gt;
</span></code></pre>

<h2>Parallel background processing</h2>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_tasks'>tasks</span> <span class='op'>=</span> <span class='int'>4</span><span class='period'>.</span><span class='id identifier rubyid_times'>times</span><span class='period'>.</span><span class='id identifier rubyid_map'>map</span> <span class='lbrace'>{</span> <span class='op'>|</span><span class='id identifier rubyid_i'>i</span><span class='op'>|</span> <span class='const'>Concurrent</span><span class='op'>::</span><span class='const'>Promises</span><span class='period'>.</span><span class='id identifier rubyid_future'>future</span><span class='lparen'>(</span><span class='id identifier rubyid_i'>i</span><span class='rparen'>)</span> <span class='lbrace'>{</span> <span class='op'>|</span><span class='id identifier rubyid_i'>i</span><span class='op'>|</span> <span class='id identifier rubyid_i'>i</span><span class='op'>*</span><span class='int'>2</span> <span class='rbrace'>}</span> <span class='rbrace'>}</span>
<span class='comment'># =&gt; [&lt;#Concurrent::Promises::Future:0x7fb5e19cc450 pending&gt;,
</span><span class='comment'>#     &lt;#Concurrent::Promises::Future:0x7fb5e229b428 pending&gt;,
</span><span class='comment'>#     &lt;#Concurrent::Promises::Future:0x7fb5e229a0a0 pending&gt;,
</span><span class='comment'>#     &lt;#Concurrent::Promises::Future:0x7fb5e2298480 pending&gt;]
</span><span class='const'>Concurrent</span><span class='op'>::</span><span class='const'>Promises</span><span class='period'>.</span><span class='id identifier rubyid_zip'>zip</span><span class='lparen'>(</span><span class='op'>*</span><span class='id identifier rubyid_tasks'>tasks</span><span class='rparen'>)</span><span class='period'>.</span><span class='id identifier rubyid_value!'>value!</span>
<span class='comment'># =&gt; [0, 2, 4, 6]
</span></code></pre>

<h2>Actor background processing</h2>

<p>Actors are mainly keep and isolate state, they should stay responsive not being
blocked by a longer running computations. It desirable to offload the work to
stateless promises.</p>

<p>Lets define an actor which will process jobs, while staying responsive, and
tracking the number of tasks being processed.</p>

<pre class="code ruby"><code class="ruby"><span class='kw'>class</span> <span class='const'>Computer</span> <span class='op'>&lt;</span> <span class='const'>Concurrent</span><span class='op'>::</span><span class='const'>Actor</span><span class='op'>::</span><span class='const'>RestartingContext</span>
  <span class='kw'>def</span> <span class='id identifier rubyid_initialize'>initialize</span>
    <span class='kw'>super</span><span class='lparen'>(</span><span class='rparen'>)</span>
    <span class='ivar'>@jobs</span> <span class='op'>=</span> <span class='lbrace'>{</span><span class='rbrace'>}</span>
  <span class='kw'>end</span>

  <span class='kw'>def</span> <span class='id identifier rubyid_on_message'>on_message</span><span class='lparen'>(</span><span class='id identifier rubyid_msg'>msg</span><span class='rparen'>)</span>
    <span class='id identifier rubyid_command'>command</span><span class='comma'>,</span> <span class='op'>*</span><span class='id identifier rubyid_args'>args</span> <span class='op'>=</span> <span class='id identifier rubyid_msg'>msg</span>
    <span class='kw'>case</span> <span class='id identifier rubyid_command'>command</span>
    <span class='comment'># new job to process
</span>    <span class='kw'>when</span> <span class='symbol'>:run</span>
      <span class='id identifier rubyid_job'>job</span>        <span class='op'>=</span> <span class='id identifier rubyid_args'>args</span><span class='lbracket'>[</span><span class='int'>0</span><span class='rbracket'>]</span>
      <span class='ivar'>@jobs</span><span class='lbracket'>[</span><span class='id identifier rubyid_job'>job</span><span class='rbracket'>]</span> <span class='op'>=</span> <span class='id identifier rubyid_envelope'>envelope</span><span class='period'>.</span><span class='id identifier rubyid_future'>future</span>
      <span class='comment'># Process asynchronously and send message back when done.
</span>      <span class='const'>Concurrent</span><span class='op'>::</span><span class='const'>Promises</span><span class='period'>.</span><span class='id identifier rubyid_future'>future</span><span class='lparen'>(</span><span class='op'>&amp;</span><span class='id identifier rubyid_job'>job</span><span class='rparen'>)</span><span class='period'>.</span><span class='id identifier rubyid_chain'>chain</span><span class='lparen'>(</span><span class='id identifier rubyid_job'>job</span><span class='rparen'>)</span> <span class='kw'>do</span> <span class='op'>|</span><span class='id identifier rubyid_fulfilled'>fulfilled</span><span class='comma'>,</span> <span class='id identifier rubyid_value'>value</span><span class='comma'>,</span> <span class='id identifier rubyid_reason'>reason</span><span class='comma'>,</span> <span class='id identifier rubyid_job'>job</span><span class='op'>|</span>
        <span class='kw'>self</span><span class='period'>.</span><span class='id identifier rubyid_tell'>tell</span> <span class='lbracket'>[</span><span class='symbol'>:done</span><span class='comma'>,</span> <span class='id identifier rubyid_job'>job</span><span class='comma'>,</span> <span class='id identifier rubyid_fulfilled'>fulfilled</span><span class='comma'>,</span> <span class='id identifier rubyid_value'>value</span><span class='comma'>,</span> <span class='id identifier rubyid_reason'>reason</span><span class='rbracket'>]</span>
      <span class='kw'>end</span>
      <span class='comment'># Do not make return value of this method to be answer of this message.
</span>      <span class='comment'># We are answering later in :done by resolving the future kept in @jobs.
</span>      <span class='const'>Concurrent</span><span class='op'>::</span><span class='const'>Actor</span><span class='op'>::</span><span class='const'>Behaviour</span><span class='op'>::</span><span class='const'>MESSAGE_PROCESSED</span>
    <span class='kw'>when</span> <span class='symbol'>:done</span>
      <span class='id identifier rubyid_job'>job</span><span class='comma'>,</span> <span class='id identifier rubyid_fulfilled'>fulfilled</span><span class='comma'>,</span> <span class='id identifier rubyid_value'>value</span><span class='comma'>,</span> <span class='id identifier rubyid_reason'>reason</span> <span class='op'>=</span> <span class='op'>*</span><span class='id identifier rubyid_args'>args</span>
      <span class='id identifier rubyid_future'>future</span>                        <span class='op'>=</span> <span class='ivar'>@jobs</span><span class='period'>.</span><span class='id identifier rubyid_delete'>delete</span> <span class='id identifier rubyid_job'>job</span>
      <span class='comment'># Answer the job&#39;s result.
</span>      <span class='id identifier rubyid_future'>future</span><span class='period'>.</span><span class='id identifier rubyid_resolve'>resolve</span> <span class='id identifier rubyid_fulfilled'>fulfilled</span><span class='comma'>,</span> <span class='id identifier rubyid_value'>value</span><span class='comma'>,</span> <span class='id identifier rubyid_reason'>reason</span>
    <span class='kw'>when</span> <span class='symbol'>:status</span>
      <span class='lbrace'>{</span> <span class='label'>running_jobs:</span> <span class='ivar'>@jobs</span><span class='period'>.</span><span class='id identifier rubyid_size'>size</span> <span class='rbrace'>}</span>
    <span class='kw'>else</span>
      <span class='comment'># Continue to fail with unknown message.
</span>      <span class='id identifier rubyid_pass'>pass</span> 
    <span class='kw'>end</span>
  <span class='kw'>end</span>
<span class='kw'>end</span>
</code></pre>

<p>Create the computer actor and send it 3 jobs.</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_computer'>computer</span> <span class='op'>=</span> <span class='const'>Concurrent</span><span class='op'>::</span><span class='const'>Actor</span><span class='period'>.</span><span class='id identifier rubyid_spawn'>spawn</span> <span class='const'>Computer</span><span class='comma'>,</span> <span class='symbol'>:computer</span>
<span class='comment'># =&gt; #&lt;Concurrent::Actor::Reference:0x7fb5e11a6b90 /computer (Computer)&gt;
</span><span class='id identifier rubyid_results'>results</span> <span class='op'>=</span> <span class='int'>3</span><span class='period'>.</span><span class='id identifier rubyid_times'>times</span><span class='period'>.</span><span class='id identifier rubyid_map'>map</span> <span class='lbrace'>{</span> <span class='id identifier rubyid_computer'>computer</span><span class='period'>.</span><span class='id identifier rubyid_ask'>ask</span> <span class='lbracket'>[</span><span class='symbol'>:run</span><span class='comma'>,</span> <span class='tlambda'>-&gt;</span> <span class='tlambeg'>{</span> <span class='id identifier rubyid_sleep'>sleep</span> <span class='float'>0.1</span><span class='semicolon'>;</span> <span class='symbol'>:result</span> <span class='rbrace'>}</span><span class='rbracket'>]</span> <span class='rbrace'>}</span>
<span class='comment'># =&gt; [&lt;#Concurrent::Promises::Future:0x7fb5e1873d38 pending&gt;,
</span><span class='comment'>#     &lt;#Concurrent::Promises::Future:0x7fb5e1872cd0 pending&gt;,
</span><span class='comment'>#     &lt;#Concurrent::Promises::Future:0x7fb5e1871a88 pending&gt;]
</span><span class='id identifier rubyid_computer'>computer</span><span class='period'>.</span><span class='id identifier rubyid_ask'>ask</span><span class='lparen'>(</span><span class='symbol'>:status</span><span class='rparen'>)</span><span class='period'>.</span><span class='id identifier rubyid_value!'>value!</span>             <span class='comment'># =&gt; {:running_jobs=&gt;3}
</span><span class='id identifier rubyid_results'>results</span><span class='period'>.</span><span class='id identifier rubyid_map'>map</span><span class='lparen'>(</span><span class='op'>&amp;</span><span class='symbol'>:value!</span><span class='rparen'>)</span>                    <span class='comment'># =&gt; [:result, :result, :result]
</span></code></pre>

<h2>Solving the Thread count limit by thread simulation</h2>

<p>Sometimes an application requires to process a lot of tasks concurrently. If
the number of concurrent tasks is high enough than it is not possible to create
a Thread for each of them. A partially satisfactory solution could be to use
Fibers, but that solution locks the application on MRI since other Ruby
implementations are using threads for each Fiber.</p>

<p>This library provides a <span class='object_link'><a href="Concurrent/Promises/Future.html#run-instance_method" title="Concurrent::Promises::Future#run (method)">Concurrent::Promises::Future#run</a></span> method on a future
to simulate threads without actually accepting one all the time. The run method
is similar to <span class='object_link'><a href="Concurrent/Promises/Future.html#flat-instance_method" title="Concurrent::Promises::Future#flat (method)">Concurrent::Promises::Future#flat</a></span> but it will keep flattening
until it&#39;s fulfilled with non future value, then the value is taken as a result
of the process simulated by <code>run</code>.</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_body'>body</span> <span class='op'>=</span> <span class='id identifier rubyid_lambda'>lambda</span> <span class='kw'>do</span> <span class='op'>|</span><span class='id identifier rubyid_v'>v</span><span class='op'>|</span>
  <span class='comment'># Some computation step of the process    
</span>  <span class='id identifier rubyid_new_v'>new_v</span> <span class='op'>=</span> <span class='id identifier rubyid_v'>v</span> <span class='op'>+</span> <span class='int'>1</span>
  <span class='comment'># Is the process finished?
</span>  <span class='kw'>if</span> <span class='id identifier rubyid_new_v'>new_v</span> <span class='op'>&lt;</span> <span class='int'>5</span>
    <span class='comment'># Continue computing with new value, does not have to be recursive.
</span>    <span class='comment'># It just has to return a future.
</span>    <span class='const'>Concurrent</span><span class='op'>::</span><span class='const'>Promises</span><span class='period'>.</span><span class='id identifier rubyid_future'>future</span><span class='lparen'>(</span><span class='id identifier rubyid_new_v'>new_v</span><span class='comma'>,</span> <span class='op'>&amp;</span><span class='id identifier rubyid_body'>body</span><span class='rparen'>)</span>
  <span class='kw'>else</span>
    <span class='comment'># The process is finished, fulfill the final value with `new_v`.
</span>    <span class='id identifier rubyid_new_v'>new_v</span>
  <span class='kw'>end</span>
<span class='kw'>end</span>
<span class='const'>Concurrent</span><span class='op'>::</span><span class='const'>Promises</span><span class='period'>.</span><span class='id identifier rubyid_future'>future</span><span class='lparen'>(</span><span class='int'>0</span><span class='comma'>,</span> <span class='op'>&amp;</span><span class='id identifier rubyid_body'>body</span><span class='rparen'>)</span><span class='period'>.</span><span class='id identifier rubyid_run'>run</span><span class='period'>.</span><span class='id identifier rubyid_value!'>value!</span> <span class='comment'># =&gt; 5
</span></code></pre>

<p>This solution works well an any Ruby implementation.</p>

<blockquote>
<p><em>TODO: More examples to be added.</em></p>
</blockquote>

<h2>Cancellation</h2>

<h3>Simple</h3>

<p>Lets have two processes which will count until cancelled.</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_source'>source</span><span class='comma'>,</span> <span class='id identifier rubyid_token'>token</span> <span class='op'>=</span> <span class='const'>Concurrent</span><span class='op'>::</span><span class='const'>Cancellation</span><span class='period'>.</span><span class='id identifier rubyid_create'>create</span>
<span class='comment'># =&gt; [&lt;#Concurrent::Cancellation:0x7fb5e182ea80 canceled:false&gt;,
</span><span class='comment'>#     &lt;#Concurrent::Cancellation::Token:0x7fb5e182dbf8 canceled:false&gt;]
</span>
<span class='id identifier rubyid_count_until_cancelled'>count_until_cancelled</span> <span class='op'>=</span> <span class='tlambda'>-&gt;</span> <span class='id identifier rubyid_token'>token</span><span class='comma'>,</span> <span class='id identifier rubyid_count'>count</span> <span class='kw'>do</span>
  <span class='kw'>if</span> <span class='id identifier rubyid_token'>token</span><span class='period'>.</span><span class='id identifier rubyid_canceled?'>canceled?</span>
    <span class='id identifier rubyid_count'>count</span>
  <span class='kw'>else</span>
    <span class='const'>Concurrent</span><span class='op'>::</span><span class='const'>Promises</span><span class='period'>.</span><span class='id identifier rubyid_future'>future</span> <span class='id identifier rubyid_token'>token</span><span class='comma'>,</span> <span class='id identifier rubyid_count'>count</span><span class='op'>+</span><span class='int'>1</span><span class='comma'>,</span> <span class='op'>&amp;</span><span class='id identifier rubyid_count_until_cancelled'>count_until_cancelled</span>
  <span class='kw'>end</span>
<span class='kw'>end</span> 

<span class='id identifier rubyid_futures'>futures</span> <span class='op'>=</span> <span class='const'>Array</span><span class='period'>.</span><span class='id identifier rubyid_new'>new</span><span class='lparen'>(</span><span class='int'>2</span><span class='rparen'>)</span> <span class='kw'>do</span>
  <span class='const'>Concurrent</span><span class='op'>::</span><span class='const'>Promises</span><span class='period'>.</span><span class='id identifier rubyid_future'>future</span><span class='lparen'>(</span><span class='id identifier rubyid_token'>token</span><span class='comma'>,</span> <span class='int'>0</span><span class='comma'>,</span> <span class='op'>&amp;</span><span class='id identifier rubyid_count_until_cancelled'>count_until_cancelled</span><span class='rparen'>)</span><span class='period'>.</span><span class='id identifier rubyid_run'>run</span>
<span class='kw'>end</span>
<span class='comment'># =&gt; [&lt;#Concurrent::Promises::Future:0x7fb5e1826f88 pending&gt;,
</span><span class='comment'>#     &lt;#Concurrent::Promises::Future:0x7fb5e18249b8 pending&gt;]
</span>
<span class='id identifier rubyid_sleep'>sleep</span> <span class='float'>0.01</span> 
<span class='id identifier rubyid_source'>source</span><span class='period'>.</span><span class='id identifier rubyid_cancel'>cancel</span>                            <span class='comment'># =&gt; true
</span><span class='id identifier rubyid_futures'>futures</span><span class='period'>.</span><span class='id identifier rubyid_map'>map</span><span class='lparen'>(</span><span class='op'>&amp;</span><span class='symbol'>:value!</span><span class='rparen'>)</span>                    <span class='comment'># =&gt; [53, 53]
</span></code></pre>

<p>Cancellation can also be used as event or future to log or plan re-execution.</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_token'>token</span><span class='period'>.</span><span class='id identifier rubyid_to_event'>to_event</span><span class='period'>.</span><span class='id identifier rubyid_chain'>chain</span> <span class='kw'>do</span>
  <span class='comment'># log cancellation
</span>  <span class='comment'># plane re-execution
</span><span class='kw'>end</span>
</code></pre>

<h3>Parallel background processing with cancellation</h3>

<p>Each task tries to count to 1000 but there is a randomly failing test. The
tasks share a cancellation, when one of them fails it cancels the others.</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_source'>source</span><span class='comma'>,</span> <span class='id identifier rubyid_token'>token</span> <span class='op'>=</span> <span class='const'>Concurrent</span><span class='op'>::</span><span class='const'>Cancellation</span><span class='period'>.</span><span class='id identifier rubyid_create'>create</span>
<span class='comment'># =&gt; [&lt;#Concurrent::Cancellation:0x7fb5e22abdf0 canceled:false&gt;,
</span><span class='comment'>#     &lt;#Concurrent::Cancellation::Token:0x7fb5e22ab5f8 canceled:false&gt;]
</span><span class='id identifier rubyid_tasks'>tasks</span> <span class='op'>=</span> <span class='int'>4</span><span class='period'>.</span><span class='id identifier rubyid_times'>times</span><span class='period'>.</span><span class='id identifier rubyid_map'>map</span> <span class='kw'>do</span> <span class='op'>|</span><span class='id identifier rubyid_i'>i</span><span class='op'>|</span>
  <span class='const'>Concurrent</span><span class='op'>::</span><span class='const'>Promises</span><span class='period'>.</span><span class='id identifier rubyid_future'>future</span><span class='lparen'>(</span><span class='id identifier rubyid_source'>source</span><span class='comma'>,</span> <span class='id identifier rubyid_token'>token</span><span class='comma'>,</span> <span class='id identifier rubyid_i'>i</span><span class='rparen'>)</span> <span class='kw'>do</span> <span class='op'>|</span><span class='id identifier rubyid_source'>source</span><span class='comma'>,</span> <span class='id identifier rubyid_token'>token</span><span class='comma'>,</span> <span class='id identifier rubyid_i'>i</span><span class='op'>|</span>
    <span class='id identifier rubyid_count'>count</span> <span class='op'>=</span> <span class='int'>0</span>
    <span class='int'>1000</span><span class='period'>.</span><span class='id identifier rubyid_times'>times</span> <span class='kw'>do</span>
      <span class='kw'>break</span> <span class='id identifier rubyid_count'>count</span> <span class='op'>=</span> <span class='symbol'>:cancelled</span> <span class='kw'>if</span> <span class='id identifier rubyid_token'>token</span><span class='period'>.</span><span class='id identifier rubyid_canceled?'>canceled?</span>
      <span class='id identifier rubyid_count'>count</span> <span class='op'>+=</span> <span class='int'>1</span>
      <span class='id identifier rubyid_sleep'>sleep</span> <span class='float'>0.01</span>
      <span class='kw'>if</span> <span class='id identifier rubyid_rand'>rand</span> <span class='op'>&gt;</span> <span class='float'>0.95</span>
        <span class='id identifier rubyid_source'>source</span><span class='period'>.</span><span class='id identifier rubyid_cancel'>cancel</span>
        <span class='id identifier rubyid_raise'>raise</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>random error</span><span class='tstring_end'>&#39;</span></span>
      <span class='kw'>end</span>
      <span class='id identifier rubyid_count'>count</span>
    <span class='kw'>end</span>
  <span class='kw'>end</span>
<span class='kw'>end</span>
<span class='comment'># =&gt; [&lt;#Concurrent::Promises::Future:0x7fb5e22a81c8 pending&gt;,
</span><span class='comment'>#     &lt;#Concurrent::Promises::Future:0x7fb5e22a3218 pending&gt;,
</span><span class='comment'>#     &lt;#Concurrent::Promises::Future:0x7fb5e22a1d28 pending&gt;,
</span><span class='comment'>#     &lt;#Concurrent::Promises::Future:0x7fb5e22a0658 pending&gt;]
</span><span class='const'>Concurrent</span><span class='op'>::</span><span class='const'>Promises</span><span class='period'>.</span><span class='id identifier rubyid_zip'>zip</span><span class='lparen'>(</span><span class='op'>*</span><span class='id identifier rubyid_tasks'>tasks</span><span class='rparen'>)</span><span class='period'>.</span><span class='id identifier rubyid_result'>result</span>
<span class='comment'># =&gt; [false,
</span><span class='comment'>#     [nil, :cancelled, nil, :cancelled],
</span><span class='comment'>#     [#&lt;RuntimeError: random error&gt;, nil, #&lt;RuntimeError: random error&gt;, nil]]
</span></code></pre>

<p>Without the randomly failing part it produces following.</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_source'>source</span><span class='comma'>,</span> <span class='id identifier rubyid_token'>token</span> <span class='op'>=</span> <span class='const'>Concurrent</span><span class='op'>::</span><span class='const'>Cancellation</span><span class='period'>.</span><span class='id identifier rubyid_create'>create</span>
<span class='comment'># =&gt; [&lt;#Concurrent::Cancellation:0x7fb5e1a2cd00 canceled:false&gt;,
</span><span class='comment'>#     &lt;#Concurrent::Cancellation::Token:0x7fb5e1a2c2d8 canceled:false&gt;]
</span><span class='id identifier rubyid_tasks'>tasks</span> <span class='op'>=</span> <span class='int'>4</span><span class='period'>.</span><span class='id identifier rubyid_times'>times</span><span class='period'>.</span><span class='id identifier rubyid_map'>map</span> <span class='kw'>do</span> <span class='op'>|</span><span class='id identifier rubyid_i'>i</span><span class='op'>|</span>
  <span class='const'>Concurrent</span><span class='op'>::</span><span class='const'>Promises</span><span class='period'>.</span><span class='id identifier rubyid_future'>future</span><span class='lparen'>(</span><span class='id identifier rubyid_source'>source</span><span class='comma'>,</span> <span class='id identifier rubyid_token'>token</span><span class='comma'>,</span> <span class='id identifier rubyid_i'>i</span><span class='rparen'>)</span> <span class='kw'>do</span> <span class='op'>|</span><span class='id identifier rubyid_source'>source</span><span class='comma'>,</span> <span class='id identifier rubyid_token'>token</span><span class='comma'>,</span> <span class='id identifier rubyid_i'>i</span><span class='op'>|</span>
    <span class='id identifier rubyid_count'>count</span> <span class='op'>=</span> <span class='int'>0</span>
    <span class='int'>1000</span><span class='period'>.</span><span class='id identifier rubyid_times'>times</span> <span class='kw'>do</span>
      <span class='kw'>break</span> <span class='id identifier rubyid_count'>count</span> <span class='op'>=</span> <span class='symbol'>:cancelled</span> <span class='kw'>if</span> <span class='id identifier rubyid_token'>token</span><span class='period'>.</span><span class='id identifier rubyid_canceled?'>canceled?</span>
      <span class='id identifier rubyid_count'>count</span> <span class='op'>+=</span> <span class='int'>1</span>
      <span class='comment'># sleep 0.01
</span>      <span class='comment'># if rand &gt; 0.95
</span>      <span class='comment'>#   source.cancel
</span>      <span class='comment'>#   raise &#39;random error&#39;
</span>      <span class='comment'># end
</span>    <span class='kw'>end</span>
    <span class='id identifier rubyid_count'>count</span>
  <span class='kw'>end</span>
<span class='kw'>end</span>
<span class='const'>Concurrent</span><span class='op'>::</span><span class='const'>Promises</span><span class='period'>.</span><span class='id identifier rubyid_zip'>zip</span><span class='lparen'>(</span><span class='op'>*</span><span class='id identifier rubyid_tasks'>tasks</span><span class='rparen'>)</span><span class='period'>.</span><span class='id identifier rubyid_result'>result</span>
<span class='comment'># =&gt; [true, [1000, 1000, 1000, 1000], nil]
</span></code></pre>

<h2>Throttling concurrency</h2>

<p>By creating an actor managing the resource we can control how many threads is
accessing the resource. In this case one at the time.</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_data'>data</span>      <span class='op'>=</span> <span class='const'>Array</span><span class='period'>.</span><span class='id identifier rubyid_new'>new</span><span class='lparen'>(</span><span class='int'>10</span><span class='rparen'>)</span> <span class='lbrace'>{</span> <span class='op'>|</span><span class='id identifier rubyid_i'>i</span><span class='op'>|</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>*</span><span class='tstring_end'>&#39;</span></span> <span class='op'>*</span> <span class='id identifier rubyid_i'>i</span> <span class='rbrace'>}</span>
<span class='comment'># =&gt; [&quot;&quot;,
</span><span class='comment'>#     &quot;*&quot;,
</span><span class='comment'>#     &quot;**&quot;,
</span><span class='comment'>#     &quot;***&quot;,
</span><span class='comment'>#     &quot;****&quot;,
</span><span class='comment'>#     &quot;*****&quot;,
</span><span class='comment'>#     &quot;******&quot;,
</span><span class='comment'>#     &quot;*******&quot;,
</span><span class='comment'>#     &quot;********&quot;,
</span><span class='comment'>#     &quot;*********&quot;]
</span><span class='const'>DB</span> <span class='op'>=</span> <span class='const'>Concurrent</span><span class='op'>::</span><span class='const'>Actor</span><span class='op'>::</span><span class='const'>Utils</span><span class='op'>::</span><span class='const'>AdHoc</span><span class='period'>.</span><span class='id identifier rubyid_spawn'>spawn</span> <span class='symbol'>:db</span><span class='comma'>,</span> <span class='id identifier rubyid_data'>data</span> <span class='kw'>do</span> <span class='op'>|</span><span class='id identifier rubyid_data'>data</span><span class='op'>|</span>
  <span class='id identifier rubyid_lambda'>lambda</span> <span class='kw'>do</span> <span class='op'>|</span><span class='id identifier rubyid_message'>message</span><span class='op'>|</span>
    <span class='comment'># pretending that this queries a DB
</span>    <span class='id identifier rubyid_data'>data</span><span class='lbracket'>[</span><span class='id identifier rubyid_message'>message</span><span class='rbracket'>]</span>
  <span class='kw'>end</span>
<span class='kw'>end</span>

<span class='id identifier rubyid_concurrent_jobs'>concurrent_jobs</span> <span class='op'>=</span> <span class='int'>11</span><span class='period'>.</span><span class='id identifier rubyid_times'>times</span><span class='period'>.</span><span class='id identifier rubyid_map'>map</span> <span class='kw'>do</span> <span class='op'>|</span><span class='id identifier rubyid_v'>v</span><span class='op'>|</span>
  <span class='const'>DB</span><span class='period'>.</span>
      <span class='comment'># ask the DB with the `v`, only one at the time, rest is parallel
</span>      <span class='id identifier rubyid_ask'>ask</span><span class='lparen'>(</span><span class='id identifier rubyid_v'>v</span><span class='rparen'>)</span><span class='period'>.</span>
      <span class='comment'># get size of the string, rejects for 11
</span>      <span class='id identifier rubyid_then'>then</span><span class='lparen'>(</span><span class='op'>&amp;</span><span class='symbol'>:size</span><span class='rparen'>)</span><span class='period'>.</span>
      <span class='comment'># translate error to a value (message of the exception)
</span>      <span class='id identifier rubyid_rescue'>rescue</span> <span class='lbrace'>{</span> <span class='op'>|</span><span class='id identifier rubyid_reason'>reason</span><span class='op'>|</span> <span class='id identifier rubyid_reason'>reason</span><span class='period'>.</span><span class='id identifier rubyid_message'>message</span> <span class='rbrace'>}</span> 
<span class='kw'>end</span> 

<span class='const'>Concurrent</span><span class='op'>::</span><span class='const'>Promises</span><span class='period'>.</span><span class='id identifier rubyid_zip'>zip</span><span class='lparen'>(</span><span class='op'>*</span><span class='id identifier rubyid_concurrent_jobs'>concurrent_jobs</span><span class='rparen'>)</span><span class='period'>.</span><span class='id identifier rubyid_value!'>value!</span>
<span class='comment'># =&gt; [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, &quot;undefined method `size&#39; for nil:NilClass&quot;]
</span></code></pre>

<p>Often there is more then one DB connections, then the pool can be used.</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_pool_size'>pool_size</span> <span class='op'>=</span> <span class='int'>5</span>                            <span class='comment'># =&gt; 5
</span>
<span class='const'>DB_POOL</span> <span class='op'>=</span> <span class='const'>Concurrent</span><span class='op'>::</span><span class='const'>Actor</span><span class='op'>::</span><span class='const'>Utils</span><span class='op'>::</span><span class='const'>Pool</span><span class='period'>.</span><span class='id identifier rubyid_spawn!'>spawn!</span><span class='lparen'>(</span><span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>DB-pool</span><span class='tstring_end'>&#39;</span></span><span class='comma'>,</span> <span class='id identifier rubyid_pool_size'>pool_size</span><span class='rparen'>)</span> <span class='kw'>do</span> <span class='op'>|</span><span class='id identifier rubyid_index'>index</span><span class='op'>|</span>
  <span class='comment'># DB connection constructor
</span>  <span class='const'>Concurrent</span><span class='op'>::</span><span class='const'>Actor</span><span class='op'>::</span><span class='const'>Utils</span><span class='op'>::</span><span class='const'>AdHoc</span><span class='period'>.</span><span class='id identifier rubyid_spawn'>spawn</span><span class='lparen'>(</span>
      <span class='label'>name:</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>connection-</span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_index'>index</span><span class='embexpr_end'>}</span><span class='tstring_end'>&quot;</span></span><span class='comma'>,</span> 
      <span class='label'>args:</span> <span class='lbracket'>[</span><span class='id identifier rubyid_data'>data</span><span class='rbracket'>]</span><span class='rparen'>)</span> <span class='kw'>do</span> <span class='op'>|</span><span class='id identifier rubyid_data'>data</span><span class='op'>|</span>
    <span class='id identifier rubyid_lambda'>lambda</span> <span class='kw'>do</span> <span class='op'>|</span><span class='id identifier rubyid_message'>message</span><span class='op'>|</span>
      <span class='comment'># pretending that this queries a DB
</span>      <span class='id identifier rubyid_data'>data</span><span class='lbracket'>[</span><span class='id identifier rubyid_message'>message</span><span class='rbracket'>]</span>
    <span class='kw'>end</span>
  <span class='kw'>end</span>
<span class='kw'>end</span>

<span class='id identifier rubyid_concurrent_jobs'>concurrent_jobs</span> <span class='op'>=</span> <span class='int'>11</span><span class='period'>.</span><span class='id identifier rubyid_times'>times</span><span class='period'>.</span><span class='id identifier rubyid_map'>map</span> <span class='kw'>do</span> <span class='op'>|</span><span class='id identifier rubyid_v'>v</span><span class='op'>|</span>
  <span class='const'>DB_POOL</span><span class='period'>.</span>
      <span class='comment'># ask the DB with the `v`, only one at the time, rest is parallel
</span>      <span class='id identifier rubyid_ask'>ask</span><span class='lparen'>(</span><span class='id identifier rubyid_v'>v</span><span class='rparen'>)</span><span class='period'>.</span>
      <span class='comment'># get size of the string, rejects for 11
</span>      <span class='id identifier rubyid_then'>then</span><span class='lparen'>(</span><span class='op'>&amp;</span><span class='symbol'>:size</span><span class='rparen'>)</span><span class='period'>.</span>
      <span class='comment'># translate error to a value (message of the exception)
</span>      <span class='id identifier rubyid_rescue'>rescue</span> <span class='lbrace'>{</span> <span class='op'>|</span><span class='id identifier rubyid_reason'>reason</span><span class='op'>|</span> <span class='id identifier rubyid_reason'>reason</span><span class='period'>.</span><span class='id identifier rubyid_message'>message</span> <span class='rbrace'>}</span> 
<span class='kw'>end</span> 

<span class='const'>Concurrent</span><span class='op'>::</span><span class='const'>Promises</span><span class='period'>.</span><span class='id identifier rubyid_zip'>zip</span><span class='lparen'>(</span><span class='op'>*</span><span class='id identifier rubyid_concurrent_jobs'>concurrent_jobs</span><span class='rparen'>)</span><span class='period'>.</span><span class='id identifier rubyid_value!'>value!</span>
<span class='comment'># =&gt; [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, &quot;undefined method `size&#39; for nil:NilClass&quot;]
</span></code></pre>

<p>In other cases the DB adapter maintains its internal connection pool and we
just need to limit concurrent access to the DB&#39;s API to avoid the calls being
blocked.</p>

<p>Lets pretend that the <code>#[]</code> method on <code>DB_INTERNAL_POOL</code> is using the internal
pool of size 3. We create throttle with the same size</p>

<pre class="code ruby"><code class="ruby"><span class='const'>DB_INTERNAL_POOL</span> <span class='op'>=</span> <span class='const'>Concurrent</span><span class='op'>::</span><span class='const'>Array</span><span class='period'>.</span><span class='id identifier rubyid_new'>new</span> <span class='id identifier rubyid_data'>data</span> 
<span class='comment'># =&gt; [&quot;&quot;,
</span><span class='comment'>#     &quot;*&quot;,
</span><span class='comment'>#     &quot;**&quot;,
</span><span class='comment'>#     &quot;***&quot;,
</span><span class='comment'>#     &quot;****&quot;,
</span><span class='comment'>#     &quot;*****&quot;,
</span><span class='comment'>#     &quot;******&quot;,
</span><span class='comment'>#     &quot;*******&quot;,
</span><span class='comment'>#     &quot;********&quot;,
</span><span class='comment'>#     &quot;*********&quot;]
</span>
<span class='id identifier rubyid_max_tree'>max_tree</span> <span class='op'>=</span> <span class='const'>Concurrent</span><span class='op'>::</span><span class='const'>Throttle</span><span class='period'>.</span><span class='id identifier rubyid_new'>new</span> <span class='int'>3</span>
<span class='comment'># =&gt; &lt;#Concurrent::Throttle:0x7fb5e21d3360 limit:3 can_run:3&gt;
</span>
<span class='id identifier rubyid_futures'>futures</span> <span class='op'>=</span> <span class='int'>11</span><span class='period'>.</span><span class='id identifier rubyid_times'>times</span><span class='period'>.</span><span class='id identifier rubyid_map'>map</span> <span class='kw'>do</span> <span class='op'>|</span><span class='id identifier rubyid_i'>i</span><span class='op'>|</span>
  <span class='id identifier rubyid_max_tree'>max_tree</span><span class='period'>.</span>
      <span class='comment'># throttled tasks, at most 3 simultaneous calls of [] on the database
</span>      <span class='id identifier rubyid_throttled_future'>throttled_future</span> <span class='lbrace'>{</span> <span class='const'>DB_INTERNAL_POOL</span><span class='lbracket'>[</span><span class='id identifier rubyid_i'>i</span><span class='rbracket'>]</span> <span class='rbrace'>}</span><span class='period'>.</span>
      <span class='comment'># un-throttled tasks, unlimited concurrency
</span>      <span class='id identifier rubyid_then'>then</span> <span class='lbrace'>{</span> <span class='op'>|</span><span class='id identifier rubyid_starts'>starts</span><span class='op'>|</span> <span class='id identifier rubyid_starts'>starts</span><span class='period'>.</span><span class='id identifier rubyid_size'>size</span> <span class='rbrace'>}</span><span class='period'>.</span>
      <span class='id identifier rubyid_rescue'>rescue</span> <span class='lbrace'>{</span> <span class='op'>|</span><span class='id identifier rubyid_reason'>reason</span><span class='op'>|</span> <span class='id identifier rubyid_reason'>reason</span><span class='period'>.</span><span class='id identifier rubyid_message'>message</span> <span class='rbrace'>}</span>
<span class='kw'>end</span> 

<span class='id identifier rubyid_futures'>futures</span><span class='period'>.</span><span class='id identifier rubyid_map'>map</span><span class='lparen'>(</span><span class='op'>&amp;</span><span class='symbol'>:value!</span><span class='rparen'>)</span>
<span class='comment'># =&gt; [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, &quot;undefined method `size&#39; for nil:NilClass&quot;]
</span></code></pre>

<h2>Long stream of tasks, applying back pressure</h2>

<p>Lets assume that we queuing an API for a data and the queries can be faster
than we are able to process them. This example shows how to use channel as a
buffer and how to apply back pressure to slow down the queries. </p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_require'>require</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>json</span><span class='tstring_end'>&#39;</span></span> 

<span class='id identifier rubyid_channel'>channel</span>       <span class='op'>=</span> <span class='const'>Concurrent</span><span class='op'>::</span><span class='const'>Promises</span><span class='op'>::</span><span class='const'>Channel</span><span class='period'>.</span><span class='id identifier rubyid_new'>new</span> <span class='int'>6</span>
<span class='comment'># =&gt; &lt;#Concurrent::Promises::Channel:0x7fb5e11e4e90 size:6&gt;
</span><span class='id identifier rubyid_source'>source</span><span class='comma'>,</span> <span class='id identifier rubyid_token'>token</span> <span class='op'>=</span> <span class='const'>Concurrent</span><span class='op'>::</span><span class='const'>Cancellation</span><span class='period'>.</span><span class='id identifier rubyid_create'>create</span>
<span class='comment'># =&gt; [&lt;#Concurrent::Cancellation:0x7fb5e11de9a0 canceled:false&gt;,
</span><span class='comment'>#     &lt;#Concurrent::Cancellation::Token:0x7fb5e11ddc58 canceled:false&gt;]
</span>
<span class='kw'>def</span> <span class='id identifier rubyid_query_random_text'>query_random_text</span><span class='lparen'>(</span><span class='id identifier rubyid_token'>token</span><span class='comma'>,</span> <span class='id identifier rubyid_channel'>channel</span><span class='rparen'>)</span>
  <span class='const'>Concurrent</span><span class='op'>::</span><span class='const'>Promises</span><span class='period'>.</span><span class='id identifier rubyid_future'>future</span> <span class='kw'>do</span>
    <span class='comment'># for simplicity the query is omitted
</span>    <span class='comment'># url = &#39;some api&#39;
</span>    <span class='comment'># Net::HTTP.get(URI(url))
</span>    <span class='id identifier rubyid_sleep'>sleep</span> <span class='float'>0.1</span>
    <span class='lbrace'>{</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>message</span><span class='tstring_end'>&#39;</span></span> <span class='op'>=&gt;</span> 
        <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>Lorem ipsum rhoncus scelerisque vulputate diam inceptos</span><span class='tstring_end'>&#39;</span></span> 
    <span class='rbrace'>}</span><span class='period'>.</span><span class='id identifier rubyid_to_json'>to_json</span>
  <span class='kw'>end</span><span class='period'>.</span><span class='id identifier rubyid_then'>then</span><span class='lparen'>(</span><span class='id identifier rubyid_token'>token</span><span class='rparen'>)</span> <span class='kw'>do</span> <span class='op'>|</span><span class='id identifier rubyid_value'>value</span><span class='comma'>,</span> <span class='id identifier rubyid_token'>token</span><span class='op'>|</span>
    <span class='comment'># The push to channel is fulfilled only after the message is successfully
</span>    <span class='comment'># published to the channel, therefore it will not continue querying until 
</span>    <span class='comment'># current message is pushed.
</span>    <span class='id identifier rubyid_channel'>channel</span><span class='period'>.</span><span class='id identifier rubyid_push'>push</span><span class='lparen'>(</span><span class='id identifier rubyid_value'>value</span><span class='rparen'>)</span> <span class='op'>|</span> 
        <span class='comment'># It could wait on the push indefinitely if the token is not checked 
</span>        <span class='comment'># here with `or` (the pipe).
</span>        <span class='id identifier rubyid_token'>token</span><span class='period'>.</span><span class='id identifier rubyid_to_future'>to_future</span>
  <span class='kw'>end</span><span class='period'>.</span><span class='id identifier rubyid_flat_future'>flat_future</span><span class='period'>.</span><span class='id identifier rubyid_then'>then</span><span class='lparen'>(</span><span class='id identifier rubyid_token'>token</span><span class='rparen'>)</span> <span class='kw'>do</span> <span class='op'>|</span><span class='id identifier rubyid__'>_</span><span class='comma'>,</span> <span class='id identifier rubyid_token'>token</span><span class='op'>|</span>
    <span class='comment'># query again after the message is pushed to buffer
</span>    <span class='id identifier rubyid_query_random_text'>query_random_text</span><span class='lparen'>(</span><span class='id identifier rubyid_token'>token</span><span class='comma'>,</span> <span class='id identifier rubyid_channel'>channel</span><span class='rparen'>)</span> <span class='kw'>unless</span> <span class='id identifier rubyid_token'>token</span><span class='period'>.</span><span class='id identifier rubyid_canceled?'>canceled?</span>
  <span class='kw'>end</span>
<span class='kw'>end</span>

<span class='id identifier rubyid_words'>words</span>          <span class='op'>=</span> <span class='lbracket'>[</span><span class='rbracket'>]</span>                      <span class='comment'># =&gt; []
</span><span class='id identifier rubyid_words_throttle'>words_throttle</span> <span class='op'>=</span> <span class='const'>Concurrent</span><span class='op'>::</span><span class='const'>Throttle</span><span class='period'>.</span><span class='id identifier rubyid_new'>new</span> <span class='int'>1</span>
<span class='comment'># =&gt; &lt;#Concurrent::Throttle:0x7fb5e1a37d90 limit:1 can_run:1&gt;
</span>
<span class='kw'>def</span> <span class='id identifier rubyid_count_words_in_random_text'>count_words_in_random_text</span><span class='lparen'>(</span><span class='id identifier rubyid_token'>token</span><span class='comma'>,</span> <span class='id identifier rubyid_channel'>channel</span><span class='comma'>,</span> <span class='id identifier rubyid_words'>words</span><span class='comma'>,</span> <span class='id identifier rubyid_words_throttle'>words_throttle</span><span class='rparen'>)</span>
  <span class='id identifier rubyid_channel'>channel</span><span class='period'>.</span><span class='id identifier rubyid_pop'>pop</span><span class='period'>.</span><span class='id identifier rubyid_then'>then</span> <span class='kw'>do</span> <span class='op'>|</span><span class='id identifier rubyid_response'>response</span><span class='op'>|</span>
    <span class='id identifier rubyid_string'>string</span> <span class='op'>=</span> <span class='const'>JSON</span><span class='period'>.</span><span class='id identifier rubyid_load'>load</span><span class='lparen'>(</span><span class='id identifier rubyid_response'>response</span><span class='rparen'>)</span><span class='lbracket'>[</span><span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>message</span><span class='tstring_end'>&#39;</span></span><span class='rbracket'>]</span>
    <span class='comment'># processing is slower than querying
</span>    <span class='id identifier rubyid_sleep'>sleep</span> <span class='float'>0.2</span>
    <span class='id identifier rubyid_words_count'>words_count</span> <span class='op'>=</span> <span class='id identifier rubyid_string'>string</span><span class='period'>.</span><span class='id identifier rubyid_scan'>scan</span><span class='lparen'>(</span><span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>\w+</span><span class='regexp_end'>/</span></span><span class='rparen'>)</span><span class='period'>.</span><span class='id identifier rubyid_size'>size</span>
  <span class='kw'>end</span><span class='period'>.</span><span class='id identifier rubyid_then_throttled_by'>then_throttled_by</span><span class='lparen'>(</span><span class='id identifier rubyid_words_throttle'>words_throttle</span><span class='comma'>,</span> <span class='id identifier rubyid_words'>words</span><span class='rparen'>)</span> <span class='kw'>do</span> <span class='op'>|</span><span class='id identifier rubyid_words_count'>words_count</span><span class='comma'>,</span> <span class='id identifier rubyid_words'>words</span><span class='op'>|</span>
    <span class='comment'># safe since throttled to only 1 task at a time
</span>    <span class='id identifier rubyid_words'>words</span> <span class='op'>&lt;&lt;</span> <span class='id identifier rubyid_words_count'>words_count</span>
  <span class='kw'>end</span><span class='period'>.</span><span class='id identifier rubyid_then'>then</span><span class='lparen'>(</span><span class='id identifier rubyid_token'>token</span><span class='rparen'>)</span> <span class='kw'>do</span> <span class='op'>|</span><span class='id identifier rubyid__'>_</span><span class='comma'>,</span> <span class='id identifier rubyid_token'>token</span><span class='op'>|</span>
    <span class='comment'># count words in next message
</span>    <span class='kw'>unless</span> <span class='id identifier rubyid_token'>token</span><span class='period'>.</span><span class='id identifier rubyid_canceled?'>canceled?</span>
      <span class='id identifier rubyid_count_words_in_random_text'>count_words_in_random_text</span><span class='lparen'>(</span><span class='id identifier rubyid_token'>token</span><span class='comma'>,</span> <span class='id identifier rubyid_channel'>channel</span><span class='comma'>,</span> <span class='id identifier rubyid_words'>words</span><span class='comma'>,</span> <span class='id identifier rubyid_words_throttle'>words_throttle</span><span class='rparen'>)</span>
    <span class='kw'>end</span>
  <span class='kw'>end</span>
<span class='kw'>end</span>

<span class='id identifier rubyid_query_processes'>query_processes</span> <span class='op'>=</span> <span class='int'>3</span><span class='period'>.</span><span class='id identifier rubyid_times'>times</span><span class='period'>.</span><span class='id identifier rubyid_map'>map</span> <span class='kw'>do</span>
  <span class='const'>Concurrent</span><span class='op'>::</span><span class='const'>Promises</span><span class='period'>.</span><span class='id identifier rubyid_future'>future</span><span class='lparen'>(</span><span class='id identifier rubyid_token'>token</span><span class='comma'>,</span> <span class='id identifier rubyid_channel'>channel</span><span class='comma'>,</span> <span class='op'>&amp;</span><span class='id identifier rubyid_method'>method</span><span class='lparen'>(</span><span class='symbol'>:query_random_text</span><span class='rparen'>)</span><span class='rparen'>)</span><span class='period'>.</span><span class='id identifier rubyid_run'>run</span>
<span class='kw'>end</span>
<span class='comment'># =&gt; [&lt;#Concurrent::Promises::Future:0x7fb5e1a2e128 pending&gt;,
</span><span class='comment'>#     &lt;#Concurrent::Promises::Future:0x7fb5e1a279b8 pending&gt;,
</span><span class='comment'>#     &lt;#Concurrent::Promises::Future:0x7fb5e1a25820 pending&gt;]
</span>
<span class='id identifier rubyid_word_counter_processes'>word_counter_processes</span> <span class='op'>=</span> <span class='int'>2</span><span class='period'>.</span><span class='id identifier rubyid_times'>times</span><span class='period'>.</span><span class='id identifier rubyid_map'>map</span> <span class='kw'>do</span>
  <span class='const'>Concurrent</span><span class='op'>::</span><span class='const'>Promises</span><span class='period'>.</span><span class='id identifier rubyid_future'>future</span><span class='lparen'>(</span><span class='id identifier rubyid_token'>token</span><span class='comma'>,</span> <span class='id identifier rubyid_channel'>channel</span><span class='comma'>,</span> <span class='id identifier rubyid_words'>words</span><span class='comma'>,</span> <span class='id identifier rubyid_words_throttle'>words_throttle</span><span class='comma'>,</span> 
      <span class='op'>&amp;</span><span class='id identifier rubyid_method'>method</span><span class='lparen'>(</span><span class='symbol'>:count_words_in_random_text</span><span class='rparen'>)</span><span class='rparen'>)</span><span class='period'>.</span><span class='id identifier rubyid_run'>run</span>
<span class='kw'>end</span>
<span class='comment'># =&gt; [&lt;#Concurrent::Promises::Future:0x7fb5e11ccf70 pending&gt;,
</span><span class='comment'>#     &lt;#Concurrent::Promises::Future:0x7fb5e11c6b48 pending&gt;]
</span>
<span class='id identifier rubyid_sleep'>sleep</span> <span class='float'>0.5</span>                                <span class='comment'># =&gt; 1
</span></code></pre>

<p>Let it run for a while then cancel it and ensure that the runs all fulfilled
(therefore ended) after the cancellation. Finally print the result.</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_source'>source</span><span class='period'>.</span><span class='id identifier rubyid_cancel'>cancel</span>                            <span class='comment'># =&gt; true
</span><span class='id identifier rubyid_query_processes'>query_processes</span><span class='period'>.</span><span class='id identifier rubyid_map'>map</span><span class='lparen'>(</span><span class='op'>&amp;</span><span class='symbol'>:wait!</span><span class='rparen'>)</span> 
<span class='comment'># =&gt; [&lt;#Concurrent::Promises::Future:0x7fb5e1a2e128 fulfilled&gt;,
</span><span class='comment'>#     &lt;#Concurrent::Promises::Future:0x7fb5e1a279b8 fulfilled&gt;,
</span><span class='comment'>#     &lt;#Concurrent::Promises::Future:0x7fb5e1a25820 fulfilled&gt;]
</span><span class='id identifier rubyid_word_counter_processes'>word_counter_processes</span><span class='period'>.</span><span class='id identifier rubyid_map'>map</span><span class='lparen'>(</span><span class='op'>&amp;</span><span class='symbol'>:wait!</span><span class='rparen'>)</span>
<span class='comment'># =&gt; [&lt;#Concurrent::Promises::Future:0x7fb5e11ccf70 fulfilled&gt;,
</span><span class='comment'>#     &lt;#Concurrent::Promises::Future:0x7fb5e11c6b48 fulfilled&gt;]
</span><span class='id identifier rubyid_words'>words</span>                                    <span class='comment'># =&gt; [7, 7, 7, 7]
</span></code></pre>

<p>Compared to using threads directly this is highly configurable and compostable
solution.</p>

<h2>Periodic task</h2>

<p>By combining <code>schedule</code>, <code>run</code> and <code>Cancellation</code> periodically executed task
can be easily created.</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_repeating_scheduled_task'>repeating_scheduled_task</span> <span class='op'>=</span> <span class='tlambda'>-&gt;</span> <span class='id identifier rubyid_interval'>interval</span><span class='comma'>,</span> <span class='id identifier rubyid_token'>token</span><span class='comma'>,</span> <span class='id identifier rubyid_task'>task</span> <span class='kw'>do</span>
  <span class='const'>Concurrent</span><span class='op'>::</span><span class='const'>Promises</span><span class='period'>.</span>
      <span class='comment'># Schedule the task.
</span>      <span class='id identifier rubyid_schedule'>schedule</span><span class='lparen'>(</span><span class='id identifier rubyid_interval'>interval</span><span class='comma'>,</span> <span class='id identifier rubyid_token'>token</span><span class='comma'>,</span> <span class='op'>&amp;</span><span class='id identifier rubyid_task'>task</span><span class='rparen'>)</span><span class='period'>.</span>
      <span class='comment'># If successful schedule again. 
</span>      <span class='comment'># Alternatively use chain to schedule always.
</span>      <span class='id identifier rubyid_then'>then</span> <span class='lbrace'>{</span> <span class='id identifier rubyid_repeating_scheduled_task'>repeating_scheduled_task</span><span class='period'>.</span><span class='id identifier rubyid_call'>call</span><span class='lparen'>(</span><span class='id identifier rubyid_interval'>interval</span><span class='comma'>,</span> <span class='id identifier rubyid_token'>token</span><span class='comma'>,</span> <span class='id identifier rubyid_task'>task</span><span class='rparen'>)</span> <span class='rbrace'>}</span>
<span class='kw'>end</span>

<span class='id identifier rubyid_cancellation'>cancellation</span><span class='comma'>,</span> <span class='id identifier rubyid_token'>token</span> <span class='op'>=</span> <span class='const'>Concurrent</span><span class='op'>::</span><span class='const'>Cancellation</span><span class='period'>.</span><span class='id identifier rubyid_create'>create</span>
<span class='comment'># =&gt; [&lt;#Concurrent::Cancellation:0x7fb5e222a7c8 canceled:false&gt;,
</span><span class='comment'>#     &lt;#Concurrent::Cancellation::Token:0x7fb5e2228b80 canceled:false&gt;]
</span>
<span class='id identifier rubyid_task'>task</span> <span class='op'>=</span> <span class='tlambda'>-&gt;</span> <span class='id identifier rubyid_token'>token</span> <span class='kw'>do</span>
  <span class='int'>5</span><span class='period'>.</span><span class='id identifier rubyid_times'>times</span> <span class='kw'>do</span>
    <span class='id identifier rubyid_token'>token</span><span class='period'>.</span><span class='id identifier rubyid_raise_if_canceled'>raise_if_canceled</span>
    <span class='comment'># do stuff
</span>    <span class='id identifier rubyid_print'>print</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>.</span><span class='tstring_end'>&#39;</span></span>
    <span class='id identifier rubyid_sleep'>sleep</span> <span class='float'>0.01</span>
  <span class='kw'>end</span>
<span class='kw'>end</span>

<span class='id identifier rubyid_result'>result</span> <span class='op'>=</span> <span class='const'>Concurrent</span><span class='op'>::</span><span class='const'>Promises</span><span class='period'>.</span><span class='id identifier rubyid_future'>future</span><span class='lparen'>(</span><span class='float'>0.1</span><span class='comma'>,</span> <span class='id identifier rubyid_token'>token</span><span class='comma'>,</span> <span class='id identifier rubyid_task'>task</span><span class='comma'>,</span> <span class='op'>&amp;</span><span class='id identifier rubyid_repeating_scheduled_task'>repeating_scheduled_task</span><span class='rparen'>)</span><span class='period'>.</span><span class='id identifier rubyid_run'>run</span>
<span class='comment'># =&gt; &lt;#Concurrent::Promises::Future:0x7fb5e1987968 pending&gt;
</span><span class='id identifier rubyid_sleep'>sleep</span> <span class='float'>0.2</span>                                <span class='comment'># =&gt; 0
</span><span class='id identifier rubyid_cancellation'>cancellation</span><span class='period'>.</span><span class='id identifier rubyid_cancel'>cancel</span>                      <span class='comment'># =&gt; true
</span><span class='id identifier rubyid_result'>result</span><span class='period'>.</span><span class='id identifier rubyid_result'>result</span>
<span class='comment'># =&gt; [false,
</span><span class='comment'>#     nil,
</span><span class='comment'>#     #&lt;Concurrent::CancelledOperationError: Concurrent::CancelledOperationError&gt;]
</span></code></pre>
</div></div>

    <div id="footer">
  Generated on Wed Aug 15 13:38:39 2018 by
  <a href="http://yardoc.org" title="Yay! A Ruby Documentation Tool" target="_parent">yard</a>
  0.8.7.6 (ruby-2.4.3).
</div>

<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
          m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-57940973-1', 'auto');
  ga('send', 'pageview');

</script>

  </body>
</html>