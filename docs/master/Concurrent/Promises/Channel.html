<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>
  Class: Concurrent::Promises::Channel
  
    &mdash; Concurrent Ruby
  
</title>

  <link rel="stylesheet" href="../../css/style.css" type="text/css" charset="utf-8" />

  <link rel="stylesheet" href="../../css/common.css" type="text/css" charset="utf-8" />

<script type="text/javascript" charset="utf-8">
  pathId = "Concurrent::Promises::Channel";
  relpath = '../../';
</script>


  <script type="text/javascript" charset="utf-8" src="../../js/jquery.js"></script>

  <script type="text/javascript" charset="utf-8" src="../../js/app.js"></script>


  </head>
  <body>
    <div class="nav_wrap">
      <iframe id="nav" src="../../class_list.html?1"></iframe>
      <div id="resizer"></div>
    </div>

    <div id="main" tabindex="-1">
      <div id="header">
        <div id="menu">
  
    <a href="../../_index.html">Index (C)</a> &raquo;
    <span class='title'><span class='object_link'><a href="../../Concurrent.html" title="Concurrent (module)">Concurrent</a></span></span> &raquo; <span class='title'><span class='object_link'><a href="../Promises.html" title="Concurrent::Promises (module)">Promises</a></span></span>
     &raquo; 
    <span class="title">Channel</span>
  
</div>

        <div id="search">
  
    <a class="full_list_link" id="class_list_link"
        href="../../class_list.html">

        <svg width="24" height="24">
          <rect x="0" y="4" width="24" height="4" rx="1" ry="1"></rect>
          <rect x="0" y="12" width="24" height="4" rx="1" ry="1"></rect>
          <rect x="0" y="20" width="24" height="4" rx="1" ry="1"></rect>
        </svg>
    </a>
  
</div>
        <div class="clear"></div>
      </div>

      <div id="content"><h1>Class: Concurrent::Promises::Channel
  
  
  
</h1>
<div class="box_info">
  
  <dl>
    <dt>Inherits:</dt>
    <dd>
      <span class="inheritName"><span class='object_link'><a href="../Synchronization/Object.html" title="Concurrent::Synchronization::Object (class)">Synchronization::Object</a></span></span>
      
        <ul class="fullTree">
          <li>Object</li>
          
            <li class="next"><span class='object_link'><a href="../Synchronization/Object.html" title="Concurrent::Synchronization::Object (class)">Synchronization::Object</a></span></li>
          
            <li class="next">Concurrent::Promises::Channel</li>
          
        </ul>
        <a href="#" class="inheritanceTree">show all</a>
      
    </dd>
  </dl>
  

  
  
  
  
  

  

  
  <dl>
    <dt>Defined in:</dt>
    <dd>lib-edge/concurrent/edge/channel.rb</dd>
  </dl>
  
</div>

<h2>Overview</h2><div class="docstring">
  <div class="discussion">
    <p>A first in first out channel that accepts messages with push family of methods and returns
messages with pop family of methods.
Pop and push operations can be represented as futures, see <span class='object_link'><a href="#pop_op-instance_method" title="Concurrent::Promises::Channel#pop_op (method)">#pop_op</a></span> and <span class='object_link'><a href="#push_op-instance_method" title="Concurrent::Promises::Channel#push_op (method)">#push_op</a></span>.
The capacity of the channel can be limited to support back pressure, use capacity option in <span class='object_link'><a href="#initialize-instance_method" title="Concurrent::Promises::Channel#initialize (method)">#initialize</a></span>.
<span class='object_link'><a href="#pop-instance_method" title="Concurrent::Promises::Channel#pop (method)">#pop</a></span> method blocks ans <span class='object_link'><a href="#pop_op-instance_method" title="Concurrent::Promises::Channel#pop_op (method)">#pop_op</a></span> returns pending future if there is no message in the channel.
If the capacity is limited the <span class='object_link'><a href="#push-instance_method" title="Concurrent::Promises::Channel#push (method)">#push</a></span> method blocks and <span class='object_link'><a href="#push_op-instance_method" title="Concurrent::Promises::Channel#push_op (method)">#push_op</a></span> returns pending future.</p>

<p><h2>Examples</h2>

<p>Let&#39;s start by creating a channel with a capacity of 2 messages.</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_ch'>ch</span> <span class='op'>=</span> <span class='const'><span class='object_link'><a href="../../Concurrent.html" title="Concurrent (module)">Concurrent</a></span></span><span class='op'>::</span><span class='const'><span class='object_link'><a href="../Promises.html" title="Concurrent::Promises (module)">Promises</a></span></span><span class='op'>::</span><span class='const'>Channel</span><span class='period'>.</span><span class='id identifier rubyid_new'>new</span> <span class='int'>2</span>
<span class='comment'># =&gt; #&lt;Concurrent::Promises::Channel:0x000002 capacity taken 0 of 2&gt;
</span></code></pre>

<p>We push 3 messages, 
then it can be observed that the last thread pushing is sleeping 
since the channel is full. </p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_threads'>threads</span> <span class='op'>=</span> <span class='const'><span class='object_link'><a href="../Array.html" title="Concurrent::Array (class)">Array</a></span></span><span class='period'>.</span><span class='id identifier rubyid_new'>new</span><span class='lparen'>(</span><span class='int'>3</span><span class='rparen'>)</span> <span class='lbrace'>{</span> <span class='op'>|</span><span class='id identifier rubyid_i'>i</span><span class='op'>|</span> <span class='const'>Thread</span><span class='period'>.</span><span class='id identifier rubyid_new'>new</span> <span class='lbrace'>{</span> <span class='id identifier rubyid_ch'>ch</span><span class='period'>.</span><span class='id identifier rubyid_push'>push</span> <span class='label'>message:</span> <span class='id identifier rubyid_i'>i</span> <span class='rbrace'>}</span> <span class='rbrace'>}</span> 
<span class='id identifier rubyid_sleep'>sleep</span> <span class='float'>0.01</span> <span class='comment'># let the threads run
</span><span class='id identifier rubyid_threads'>threads</span>
<span class='comment'># =&gt; [#&lt;Thread:0x000003@channel.in.md:14 dead&gt;,
</span><span class='comment'>#     #&lt;Thread:0x000004@channel.in.md:14 dead&gt;,
</span><span class='comment'>#     #&lt;Thread:0x000005@channel.in.md:14 sleep_forever&gt;]
</span></code></pre>

<p>When message is popped the last thread continues and finishes as well.</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_ch'>ch</span><span class='period'>.</span><span class='id identifier rubyid_pop'>pop</span>                                   <span class='comment'># =&gt; {:message=&gt;0}
</span><span class='id identifier rubyid_threads'>threads</span><span class='period'>.</span><span class='id identifier rubyid_map'>map</span><span class='lparen'>(</span><span class='op'>&amp;</span><span class='symbol'>:join</span><span class='rparen'>)</span>
<span class='comment'># =&gt; [#&lt;Thread:0x000003@channel.in.md:14 dead&gt;,
</span><span class='comment'>#     #&lt;Thread:0x000004@channel.in.md:14 dead&gt;,
</span><span class='comment'>#     #&lt;Thread:0x000005@channel.in.md:14 dead&gt;]
</span></code></pre>

<p>Same principle applies to popping as well.
There are now 2 messages int he channel.
Lets create 3 threads trying to pop a message, 
one will be blocked until new messages is pushed.</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_threads'>threads</span> <span class='op'>=</span> <span class='const'><span class='object_link'><a href="../Array.html" title="Concurrent::Array (class)">Array</a></span></span><span class='period'>.</span><span class='id identifier rubyid_new'>new</span><span class='lparen'>(</span><span class='int'>3</span><span class='rparen'>)</span> <span class='lbrace'>{</span> <span class='op'>|</span><span class='id identifier rubyid_i'>i</span><span class='op'>|</span> <span class='const'>Thread</span><span class='period'>.</span><span class='id identifier rubyid_new'>new</span> <span class='lbrace'>{</span> <span class='id identifier rubyid_ch'>ch</span><span class='period'>.</span><span class='id identifier rubyid_pop'>pop</span> <span class='rbrace'>}</span> <span class='rbrace'>}</span> 
<span class='id identifier rubyid_sleep'>sleep</span> <span class='float'>0.01</span> <span class='comment'># let the threads run
</span><span class='id identifier rubyid_threads'>threads</span>
<span class='comment'># =&gt; [#&lt;Thread:0x000006@channel.in.md:32 dead&gt;,
</span><span class='comment'>#     #&lt;Thread:0x000007@channel.in.md:32 dead&gt;,
</span><span class='comment'>#     #&lt;Thread:0x000008@channel.in.md:32 sleep_forever&gt;]
</span><span class='id identifier rubyid_ch'>ch</span><span class='period'>.</span><span class='id identifier rubyid_push'>push</span> <span class='label'>message:</span> <span class='int'>3</span>
<span class='comment'># =&gt; #&lt;Concurrent::Promises::Channel:0x000002 capacity taken 0 of 2&gt;
</span><span class='id identifier rubyid_threads'>threads</span><span class='period'>.</span><span class='id identifier rubyid_map'>map</span><span class='lparen'>(</span><span class='op'>&amp;</span><span class='symbol'>:value</span><span class='rparen'>)</span>
<span class='comment'># =&gt; [{:message=&gt;1}, {:message=&gt;2}, {:message=&gt;3}]
</span></code></pre>

<h3>Promises integration</h3>

<p>However this channel is implemented to <strong>integrate with promises</strong>
therefore all operations can be represented as futures.</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_ch'>ch</span> <span class='op'>=</span> <span class='const'><span class='object_link'><a href="../../Concurrent.html" title="Concurrent (module)">Concurrent</a></span></span><span class='op'>::</span><span class='const'><span class='object_link'><a href="../Promises.html" title="Concurrent::Promises (module)">Promises</a></span></span><span class='op'>::</span><span class='const'>Channel</span><span class='period'>.</span><span class='id identifier rubyid_new'>new</span> <span class='int'>2</span>
<span class='comment'># =&gt; #&lt;Concurrent::Promises::Channel:0x000009 capacity taken 0 of 2&gt;
</span><span class='id identifier rubyid_push_operations'>push_operations</span> <span class='op'>=</span> <span class='const'><span class='object_link'><a href="../Array.html" title="Concurrent::Array (class)">Array</a></span></span><span class='period'>.</span><span class='id identifier rubyid_new'>new</span><span class='lparen'>(</span><span class='int'>3</span><span class='rparen'>)</span> <span class='lbrace'>{</span> <span class='op'>|</span><span class='id identifier rubyid_i'>i</span><span class='op'>|</span> <span class='id identifier rubyid_ch'>ch</span><span class='period'>.</span><span class='id identifier rubyid_push_op'>push_op</span> <span class='label'>message:</span> <span class='id identifier rubyid_i'>i</span> <span class='rbrace'>}</span>
<span class='comment'># =&gt; [#&lt;Concurrent::Promises::Future:0x00000a fulfilled&gt;,
</span><span class='comment'>#     #&lt;Concurrent::Promises::Future:0x00000b fulfilled&gt;,
</span><span class='comment'>#     #&lt;Concurrent::Promises::ResolvableFuture:0x00000c pending&gt;]
</span></code></pre>

<blockquote>
<p>We do not have to sleep here letting the futures execute as Threads.
Since there is capacity for 2 messages the Promises are immediately resolved 
without ever allocating a Thread to execute. 
Push and pop operations are often more efficient.
The remaining pending push operation will also never require another thread,
instead it will resolve when a message is popped from the channel
making a space for a new message.    </p>
</blockquote>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_ch'>ch</span><span class='period'>.</span><span class='id identifier rubyid_pop_op'>pop_op</span><span class='period'>.</span><span class='id identifier rubyid_value!'>value!</span>                         <span class='comment'># =&gt; {:message=&gt;0}
</span><span class='id identifier rubyid_push_operations'>push_operations</span><span class='period'>.</span><span class='id identifier rubyid_map'>map</span><span class='lparen'>(</span><span class='op'>&amp;</span><span class='symbol'>:value!</span><span class='rparen'>)</span>
<span class='comment'># =&gt; [#&lt;Concurrent::Promises::Channel:0x000009 capacity taken 2 of 2&gt;,
</span><span class='comment'>#     #&lt;Concurrent::Promises::Channel:0x000009 capacity taken 2 of 2&gt;,
</span><span class='comment'>#     #&lt;Concurrent::Promises::Channel:0x000009 capacity taken 2 of 2&gt;]
</span>
<span class='id identifier rubyid_pop_operations'>pop_operations</span> <span class='op'>=</span> <span class='const'><span class='object_link'><a href="../Array.html" title="Concurrent::Array (class)">Array</a></span></span><span class='period'>.</span><span class='id identifier rubyid_new'>new</span><span class='lparen'>(</span><span class='int'>3</span><span class='rparen'>)</span> <span class='lbrace'>{</span> <span class='op'>|</span><span class='id identifier rubyid_i'>i</span><span class='op'>|</span> <span class='id identifier rubyid_ch'>ch</span><span class='period'>.</span><span class='id identifier rubyid_pop_op'>pop_op</span> <span class='rbrace'>}</span>
<span class='comment'># =&gt; [#&lt;Concurrent::Promises::ResolvableFuture:0x00000d fulfilled&gt;,
</span><span class='comment'>#     #&lt;Concurrent::Promises::ResolvableFuture:0x00000e fulfilled&gt;,
</span><span class='comment'>#     #&lt;Concurrent::Promises::ResolvableFuture:0x00000f pending&gt;]
</span><span class='id identifier rubyid_ch'>ch</span><span class='period'>.</span><span class='id identifier rubyid_push'>push</span> <span class='label'>message:</span> <span class='int'>3</span> <span class='comment'># (push|pop) can be freely mixed with (push_o|pop_op)
</span><span class='id identifier rubyid_pop_operations'>pop_operations</span><span class='period'>.</span><span class='id identifier rubyid_map'>map</span><span class='lparen'>(</span><span class='op'>&amp;</span><span class='symbol'>:value</span><span class='rparen'>)</span> 
<span class='comment'># =&gt; [{:message=&gt;1}, {:message=&gt;2}, {:message=&gt;3}]
</span></code></pre>

<h3>Selecting over channels</h3>

<p>A selection over channels can be created with the <code>.select_channel</code> factory method. It
will be fulfilled with a first message available in any of the channels. It
returns a pair to be able to find out which channel had the message available.</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_ch1'>ch1</span>    <span class='op'>=</span> <span class='const'><span class='object_link'><a href="../../Concurrent.html" title="Concurrent (module)">Concurrent</a></span></span><span class='op'>::</span><span class='const'><span class='object_link'><a href="../Promises.html" title="Concurrent::Promises (module)">Promises</a></span></span><span class='op'>::</span><span class='const'>Channel</span><span class='period'>.</span><span class='id identifier rubyid_new'>new</span> <span class='int'>2</span>
<span class='comment'># =&gt; #&lt;Concurrent::Promises::Channel:0x000010 capacity taken 0 of 2&gt;
</span><span class='id identifier rubyid_ch2'>ch2</span>    <span class='op'>=</span> <span class='const'><span class='object_link'><a href="../../Concurrent.html" title="Concurrent (module)">Concurrent</a></span></span><span class='op'>::</span><span class='const'><span class='object_link'><a href="../Promises.html" title="Concurrent::Promises (module)">Promises</a></span></span><span class='op'>::</span><span class='const'>Channel</span><span class='period'>.</span><span class='id identifier rubyid_new'>new</span> <span class='int'>2</span>
<span class='comment'># =&gt; #&lt;Concurrent::Promises::Channel:0x000011 capacity taken 0 of 2&gt;
</span><span class='id identifier rubyid_ch1'>ch1</span><span class='period'>.</span><span class='id identifier rubyid_push'>push</span> <span class='int'>1</span> 
<span class='comment'># =&gt; #&lt;Concurrent::Promises::Channel:0x000010 capacity taken 1 of 2&gt;
</span><span class='id identifier rubyid_ch2'>ch2</span><span class='period'>.</span><span class='id identifier rubyid_push'>push</span> <span class='int'>2</span> 
<span class='comment'># =&gt; #&lt;Concurrent::Promises::Channel:0x000011 capacity taken 1 of 2&gt;
</span>
<span class='const'><span class='object_link'><a href="../../Concurrent.html" title="Concurrent (module)">Concurrent</a></span></span><span class='op'>::</span><span class='const'><span class='object_link'><a href="../Promises.html" title="Concurrent::Promises (module)">Promises</a></span></span><span class='op'>::</span><span class='const'>Channel</span><span class='period'>.</span><span class='id identifier rubyid_select'><span class='object_link'><a href="#select-class_method" title="Concurrent::Promises::Channel.select (method)">select</a></span></span><span class='lparen'>(</span><span class='lbracket'>[</span><span class='id identifier rubyid_ch1'>ch1</span><span class='comma'>,</span> <span class='id identifier rubyid_ch2'>ch2</span><span class='rbracket'>]</span><span class='rparen'>)</span>
<span class='comment'># =&gt; [#&lt;Concurrent::Promises::Channel:0x000010 capacity taken 0 of 2&gt;, 1]
</span><span class='id identifier rubyid_ch1'>ch1</span><span class='period'>.</span><span class='id identifier rubyid_select'>select</span><span class='lparen'>(</span><span class='id identifier rubyid_ch2'>ch2</span><span class='rparen'>)</span>
<span class='comment'># =&gt; [#&lt;Concurrent::Promises::Channel:0x000011 capacity taken 0 of 2&gt;, 2]
</span>
<span class='const'><span class='object_link'><a href="../../Concurrent.html" title="Concurrent (module)">Concurrent</a></span></span><span class='op'>::</span><span class='const'><span class='object_link'><a href="../Promises.html" title="Concurrent::Promises (module)">Promises</a></span></span><span class='period'>.</span><span class='id identifier rubyid_future'><span class='object_link'><a href="FactoryMethods.html#future-instance_method" title="Concurrent::Promises::FactoryMethods#future (method)">future</a></span></span> <span class='lbrace'>{</span> <span class='int'>3</span> <span class='op'>+</span> <span class='int'>4</span> <span class='rbrace'>}</span><span class='period'>.</span><span class='id identifier rubyid_then_channel_push'>then_channel_push</span><span class='lparen'>(</span><span class='id identifier rubyid_ch1'>ch1</span><span class='rparen'>)</span>
<span class='comment'># =&gt; #&lt;Concurrent::Promises::Future:0x000012 pending&gt;
</span><span class='const'><span class='object_link'><a href="../../Concurrent.html" title="Concurrent (module)">Concurrent</a></span></span><span class='op'>::</span><span class='const'><span class='object_link'><a href="../Promises.html" title="Concurrent::Promises (module)">Promises</a></span></span><span class='op'>::</span><span class='const'>Channel</span><span class='period'>.</span> 
    <span class='comment'># or `ch1.select_op(ch2)` would be equivalent
</span>    <span class='id identifier rubyid_select_op'>select_op</span><span class='lparen'>(</span><span class='lbracket'>[</span><span class='id identifier rubyid_ch1'>ch1</span><span class='comma'>,</span> <span class='id identifier rubyid_ch2'>ch2</span><span class='rbracket'>]</span><span class='rparen'>)</span><span class='period'>.</span>
    <span class='id identifier rubyid_then'>then</span><span class='lparen'>(</span><span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>got number %03d from ch%d</span><span class='tstring_end'>&#39;</span></span><span class='rparen'>)</span> <span class='lbrace'>{</span> <span class='op'>|</span><span class='lparen'>(</span><span class='id identifier rubyid_channel'>channel</span><span class='comma'>,</span> <span class='id identifier rubyid_value'>value</span><span class='rparen'>)</span><span class='comma'>,</span> <span class='id identifier rubyid_format'>format</span><span class='op'>|</span> 
      <span class='id identifier rubyid_format'>format</span> <span class='id identifier rubyid_format'>format</span><span class='comma'>,</span> <span class='id identifier rubyid_value'>value</span><span class='comma'>,</span> <span class='lbracket'>[</span><span class='id identifier rubyid_ch1'>ch1</span><span class='comma'>,</span> <span class='id identifier rubyid_ch2'>ch2</span><span class='rbracket'>]</span><span class='period'>.</span><span class='id identifier rubyid_index'>index</span><span class='lparen'>(</span><span class='id identifier rubyid_channel'>channel</span><span class='rparen'>)</span><span class='period'>.</span><span class='id identifier rubyid_succ'>succ</span>
    <span class='rbrace'>}</span><span class='period'>.</span><span class='id identifier rubyid_value!'>value!</span>                             <span class='comment'># =&gt; &quot;got number 007 from ch1&quot;
</span></code></pre>

<h3><code>try_</code> variants</h3>

<p>All blocking operations (<span class='object_link'><a href="#pop-instance_method" title="Concurrent::Promises::Channel#pop (method)">#pop</a></span>, <span class='object_link'><a href="#push-instance_method" title="Concurrent::Promises::Channel#push (method)">#push</a></span>, <span class='object_link'><a href="#select-instance_method" title="Concurrent::Promises::Channel#select (method)">#select</a></span>) have non-blocking variant
with <code>try_</code> prefix. 
They always return immediately and indicate either success or failure.</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_ch'>ch</span>
<span class='comment'># =&gt; #&lt;Concurrent::Promises::Channel:0x000009 capacity taken 0 of 2&gt;
</span><span class='id identifier rubyid_ch'>ch</span><span class='period'>.</span><span class='id identifier rubyid_try_push'>try_push</span> <span class='int'>1</span>                            <span class='comment'># =&gt; true
</span><span class='id identifier rubyid_ch'>ch</span><span class='period'>.</span><span class='id identifier rubyid_try_push'>try_push</span> <span class='int'>2</span>                            <span class='comment'># =&gt; true
</span><span class='id identifier rubyid_ch'>ch</span><span class='period'>.</span><span class='id identifier rubyid_try_push'>try_push</span> <span class='int'>3</span>                            <span class='comment'># =&gt; false
</span><span class='id identifier rubyid_ch'>ch</span><span class='period'>.</span><span class='id identifier rubyid_try_pop'>try_pop</span>                               <span class='comment'># =&gt; 1
</span><span class='id identifier rubyid_ch'>ch</span><span class='period'>.</span><span class='id identifier rubyid_try_pop'>try_pop</span>                               <span class='comment'># =&gt; 2
</span><span class='id identifier rubyid_ch'>ch</span><span class='period'>.</span><span class='id identifier rubyid_try_pop'>try_pop</span>                               <span class='comment'># =&gt; nil
</span></code></pre>

<h3>Timeouts</h3>

<p>All blocking operations (<span class='object_link'><a href="#pop-instance_method" title="Concurrent::Promises::Channel#pop (method)">#pop</a></span>, <span class='object_link'><a href="#push-instance_method" title="Concurrent::Promises::Channel#push (method)">#push</a></span>, <span class='object_link'><a href="#select-instance_method" title="Concurrent::Promises::Channel#select (method)">#select</a></span>) have a timeout option.
Similar to <code>try_</code> variants it will indicate success or timing out, 
when the timeout option is used.</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_ch'>ch</span>
<span class='comment'># =&gt; #&lt;Concurrent::Promises::Channel:0x000009 capacity taken 0 of 2&gt;
</span><span class='id identifier rubyid_ch'>ch</span><span class='period'>.</span><span class='id identifier rubyid_push'>push</span> <span class='int'>1</span><span class='comma'>,</span> <span class='float'>0.01</span>                          <span class='comment'># =&gt; true
</span><span class='id identifier rubyid_ch'>ch</span><span class='period'>.</span><span class='id identifier rubyid_push'>push</span> <span class='int'>2</span><span class='comma'>,</span> <span class='float'>0.01</span>                          <span class='comment'># =&gt; true
</span><span class='id identifier rubyid_ch'>ch</span><span class='period'>.</span><span class='id identifier rubyid_push'>push</span> <span class='int'>3</span><span class='comma'>,</span> <span class='float'>0.01</span>                          <span class='comment'># =&gt; false
</span><span class='id identifier rubyid_ch'>ch</span><span class='period'>.</span><span class='id identifier rubyid_pop'>pop</span> <span class='float'>0.01</span>                              <span class='comment'># =&gt; 1
</span><span class='id identifier rubyid_ch'>ch</span><span class='period'>.</span><span class='id identifier rubyid_pop'>pop</span> <span class='float'>0.01</span>                              <span class='comment'># =&gt; 2
</span><span class='id identifier rubyid_ch'>ch</span><span class='period'>.</span><span class='id identifier rubyid_pop'>pop</span> <span class='float'>0.01</span>                              <span class='comment'># =&gt; [true, nil, nil]
</span></code></pre>

<h3>Backpressure</h3>

<p>Most importantly the channel can be used to create systems with backpressure.
A self adjusting system where the producers will slow down 
if the consumers are not keeping up.</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_channel'>channel</span> <span class='op'>=</span> <span class='const'><span class='object_link'><a href="../../Concurrent.html" title="Concurrent (module)">Concurrent</a></span></span><span class='op'>::</span><span class='const'><span class='object_link'><a href="../Promises.html" title="Concurrent::Promises (module)">Promises</a></span></span><span class='op'>::</span><span class='const'>Channel</span><span class='period'>.</span><span class='id identifier rubyid_new'>new</span> <span class='int'>2</span>
<span class='comment'># =&gt; #&lt;Concurrent::Promises::Channel:0x000013 capacity taken 0 of 2&gt;
</span><span class='id identifier rubyid_log'>log</span>     <span class='op'>=</span> <span class='const'><span class='object_link'><a href="../../Concurrent.html" title="Concurrent (module)">Concurrent</a></span></span><span class='op'>::</span><span class='const'><span class='object_link'><a href="../Array.html" title="Concurrent::Array (class)">Array</a></span></span><span class='period'>.</span><span class='id identifier rubyid_new'>new</span>          <span class='comment'># =&gt; []
</span>
<span class='id identifier rubyid_producers'>producers</span> <span class='op'>=</span> <span class='const'><span class='object_link'><a href="../Array.html" title="Concurrent::Array (class)">Array</a></span></span><span class='period'>.</span><span class='id identifier rubyid_new'>new</span> <span class='int'>2</span> <span class='kw'>do</span> <span class='op'>|</span><span class='id identifier rubyid_i'>i</span><span class='op'>|</span>
  <span class='const'>Thread</span><span class='period'>.</span><span class='id identifier rubyid_new'>new</span><span class='lparen'>(</span><span class='id identifier rubyid_i'>i</span><span class='rparen'>)</span> <span class='kw'>do</span> <span class='op'>|</span><span class='id identifier rubyid_i'>i</span><span class='op'>|</span>
    <span class='int'>4</span><span class='period'>.</span><span class='id identifier rubyid_times'>times</span> <span class='kw'>do</span> <span class='op'>|</span><span class='id identifier rubyid_j'>j</span><span class='op'>|</span>
      <span class='id identifier rubyid_log'>log</span><span class='period'>.</span><span class='id identifier rubyid_push'>push</span> <span class='id identifier rubyid_format'>format</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>producer %d pushing %d</span><span class='tstring_end'>&quot;</span></span><span class='comma'>,</span> <span class='id identifier rubyid_i'>i</span><span class='comma'>,</span> <span class='id identifier rubyid_j'>j</span>      
      <span class='id identifier rubyid_channel'>channel</span><span class='period'>.</span><span class='id identifier rubyid_push'>push</span> <span class='lbracket'>[</span><span class='id identifier rubyid_i'>i</span><span class='comma'>,</span> <span class='id identifier rubyid_j'>j</span><span class='rbracket'>]</span>      
    <span class='kw'>end</span>
  <span class='kw'>end</span>
<span class='kw'>end</span>
<span class='comment'># =&gt; [#&lt;Thread:0x000014@channel.in.md:133 run&gt;,
</span><span class='comment'>#     #&lt;Thread:0x000015@channel.in.md:133 run&gt;]
</span>
<span class='id identifier rubyid_consumers'>consumers</span> <span class='op'>=</span> <span class='const'><span class='object_link'><a href="../Array.html" title="Concurrent::Array (class)">Array</a></span></span><span class='period'>.</span><span class='id identifier rubyid_new'>new</span> <span class='int'>4</span> <span class='kw'>do</span> <span class='op'>|</span><span class='id identifier rubyid_i'>i</span><span class='op'>|</span>
  <span class='const'>Thread</span><span class='period'>.</span><span class='id identifier rubyid_new'>new</span><span class='lparen'>(</span><span class='id identifier rubyid_i'>i</span><span class='rparen'>)</span> <span class='kw'>do</span> <span class='op'>|</span><span class='id identifier rubyid_consumer'>consumer</span><span class='op'>|</span>
    <span class='int'>2</span><span class='period'>.</span><span class='id identifier rubyid_times'>times</span> <span class='kw'>do</span> <span class='op'>|</span><span class='id identifier rubyid_j'>j</span><span class='op'>|</span>
      <span class='id identifier rubyid_from'>from</span><span class='comma'>,</span> <span class='id identifier rubyid_message'>message</span> <span class='op'>=</span> <span class='id identifier rubyid_channel'>channel</span><span class='period'>.</span><span class='id identifier rubyid_pop'>pop</span>
      <span class='id identifier rubyid_log'>log</span><span class='period'>.</span><span class='id identifier rubyid_push'>push</span> <span class='id identifier rubyid_format'>format</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>consumer %d got %d. payload %d from producer %d</span><span class='tstring_end'>&quot;</span></span><span class='comma'>,</span> 
                      <span class='id identifier rubyid_consumer'>consumer</span><span class='comma'>,</span> <span class='id identifier rubyid_j'>j</span><span class='comma'>,</span> <span class='id identifier rubyid_message'>message</span><span class='comma'>,</span> <span class='id identifier rubyid_from'>from</span>       
      <span class='id identifier rubyid_do_stuff'>do_stuff</span>      
    <span class='kw'>end</span>
  <span class='kw'>end</span>
<span class='kw'>end</span>
<span class='comment'># =&gt; [#&lt;Thread:0x000016@channel.in.md:142 run&gt;,
</span><span class='comment'>#     #&lt;Thread:0x000017@channel.in.md:142 run&gt;,
</span><span class='comment'>#     #&lt;Thread:0x000018@channel.in.md:142 run&gt;,
</span><span class='comment'>#     #&lt;Thread:0x000019@channel.in.md:142 run&gt;]
</span>
<span class='comment'># wait for all to finish
</span><span class='id identifier rubyid_producers'>producers</span><span class='period'>.</span><span class='id identifier rubyid_map'>map</span><span class='lparen'>(</span><span class='op'>&amp;</span><span class='symbol'>:join</span><span class='rparen'>)</span>
<span class='comment'># =&gt; [#&lt;Thread:0x000014@channel.in.md:133 dead&gt;,
</span><span class='comment'>#     #&lt;Thread:0x000015@channel.in.md:133 dead&gt;]
</span><span class='id identifier rubyid_consumers'>consumers</span><span class='period'>.</span><span class='id identifier rubyid_map'>map</span><span class='lparen'>(</span><span class='op'>&amp;</span><span class='symbol'>:join</span><span class='rparen'>)</span>
<span class='comment'># =&gt; [#&lt;Thread:0x000016@channel.in.md:142 dead&gt;,
</span><span class='comment'>#     #&lt;Thread:0x000017@channel.in.md:142 dead&gt;,
</span><span class='comment'>#     #&lt;Thread:0x000018@channel.in.md:142 dead&gt;,
</span><span class='comment'>#     #&lt;Thread:0x000019@channel.in.md:142 dead&gt;]
</span><span class='comment'># investigate log
</span><span class='id identifier rubyid_log'>log</span>
<span class='comment'># =&gt; [&quot;producer 0 pushing 0&quot;,
</span><span class='comment'>#     &quot;producer 0 pushing 1&quot;,
</span><span class='comment'>#     &quot;producer 0 pushing 2&quot;,
</span><span class='comment'>#     &quot;producer 1 pushing 0&quot;,
</span><span class='comment'>#     &quot;consumer 0 got 0. payload 0 from producer 0&quot;,
</span><span class='comment'>#     &quot;producer 0 pushing 3&quot;,
</span><span class='comment'>#     &quot;consumer 2 got 0. payload 1 from producer 0&quot;,
</span><span class='comment'>#     &quot;consumer 3 got 0. payload 2 from producer 0&quot;,
</span><span class='comment'>#     &quot;consumer 1 got 0. payload 0 from producer 1&quot;,
</span><span class='comment'>#     &quot;producer 1 pushing 1&quot;,
</span><span class='comment'>#     &quot;producer 1 pushing 2&quot;,
</span><span class='comment'>#     &quot;consumer 2 got 1. payload 3 from producer 0&quot;,
</span><span class='comment'>#     &quot;consumer 3 got 1. payload 1 from producer 1&quot;,
</span><span class='comment'>#     &quot;consumer 1 got 1. payload 2 from producer 1&quot;,
</span><span class='comment'>#     &quot;producer 1 pushing 3&quot;,
</span><span class='comment'>#     &quot;consumer 0 got 1. payload 3 from producer 1&quot;]
</span></code></pre>

<p>The producers are much faster than consumers 
(since they <code>do_stuff</code> which takes some time)<br>
but as it can be seen from the log they fill the channel 
and then they slow down 
until there is space available in the channel.</p>

<p>If permanent allocation of threads to the producers and consumers has to be avoided,
the threads can be replaced with promises
that run a thread pool.</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_channel'>channel</span> <span class='op'>=</span> <span class='const'><span class='object_link'><a href="../../Concurrent.html" title="Concurrent (module)">Concurrent</a></span></span><span class='op'>::</span><span class='const'><span class='object_link'><a href="../Promises.html" title="Concurrent::Promises (module)">Promises</a></span></span><span class='op'>::</span><span class='const'>Channel</span><span class='period'>.</span><span class='id identifier rubyid_new'>new</span> <span class='int'>2</span>
<span class='comment'># =&gt; #&lt;Concurrent::Promises::Channel:0x00001a capacity taken 0 of 2&gt;
</span><span class='id identifier rubyid_log'>log</span>     <span class='op'>=</span> <span class='const'><span class='object_link'><a href="../../Concurrent.html" title="Concurrent (module)">Concurrent</a></span></span><span class='op'>::</span><span class='const'><span class='object_link'><a href="../Array.html" title="Concurrent::Array (class)">Array</a></span></span><span class='period'>.</span><span class='id identifier rubyid_new'>new</span>          <span class='comment'># =&gt; []
</span>
<span class='kw'>def</span> <span class='id identifier rubyid_produce'>produce</span><span class='lparen'>(</span><span class='id identifier rubyid_channel'>channel</span><span class='comma'>,</span> <span class='id identifier rubyid_log'>log</span><span class='comma'>,</span> <span class='id identifier rubyid_producer'>producer</span><span class='comma'>,</span> <span class='id identifier rubyid_i'>i</span><span class='rparen'>)</span>
  <span class='id identifier rubyid_log'>log</span><span class='period'>.</span><span class='id identifier rubyid_push'>push</span> <span class='id identifier rubyid_format'>format</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>producer %d pushing %d</span><span class='tstring_end'>&quot;</span></span><span class='comma'>,</span> <span class='id identifier rubyid_producer'>producer</span><span class='comma'>,</span> <span class='id identifier rubyid_i'>i</span>      
  <span class='id identifier rubyid_channel'>channel</span><span class='period'>.</span><span class='id identifier rubyid_push_op'>push_op</span><span class='lparen'>(</span><span class='lbracket'>[</span><span class='id identifier rubyid_producer'>producer</span><span class='comma'>,</span> <span class='id identifier rubyid_i'>i</span><span class='rbracket'>]</span><span class='rparen'>)</span><span class='period'>.</span><span class='id identifier rubyid_then'>then</span> <span class='kw'>do</span>
    <span class='id identifier rubyid_i'>i</span> <span class='op'>+</span> <span class='int'>1</span> <span class='op'>&lt;</span> <span class='int'>4</span> <span class='op'>?</span> <span class='id identifier rubyid_produce'>produce</span><span class='lparen'>(</span><span class='id identifier rubyid_channel'>channel</span><span class='comma'>,</span> <span class='id identifier rubyid_log'>log</span><span class='comma'>,</span> <span class='id identifier rubyid_producer'>producer</span><span class='comma'>,</span> <span class='id identifier rubyid_i'>i</span> <span class='op'>+</span> <span class='int'>1</span><span class='rparen'>)</span> <span class='op'>:</span> <span class='symbol'>:done</span>    
  <span class='kw'>end</span>      
<span class='kw'>end</span>                                      <span class='comment'># =&gt; :produce
</span>
<span class='kw'>def</span> <span class='id identifier rubyid_consume'>consume</span><span class='lparen'>(</span><span class='id identifier rubyid_channel'>channel</span><span class='comma'>,</span> <span class='id identifier rubyid_log'>log</span><span class='comma'>,</span> <span class='id identifier rubyid_consumer'>consumer</span><span class='comma'>,</span> <span class='id identifier rubyid_i'>i</span><span class='rparen'>)</span>
  <span class='id identifier rubyid_channel'>channel</span><span class='period'>.</span><span class='id identifier rubyid_pop_op'>pop_op</span><span class='period'>.</span><span class='id identifier rubyid_then'>then</span><span class='lparen'>(</span><span class='id identifier rubyid_consumer'>consumer</span><span class='comma'>,</span> <span class='id identifier rubyid_i'>i</span><span class='rparen'>)</span> <span class='kw'>do</span> <span class='op'>|</span><span class='lparen'>(</span><span class='id identifier rubyid_from'>from</span><span class='comma'>,</span> <span class='id identifier rubyid_message'>message</span><span class='rparen'>)</span><span class='comma'>,</span> <span class='id identifier rubyid_consumer'>consumer</span><span class='comma'>,</span> <span class='id identifier rubyid_i'>i</span><span class='op'>|</span>
    <span class='id identifier rubyid_log'>log</span><span class='period'>.</span><span class='id identifier rubyid_push'>push</span> <span class='id identifier rubyid_format'>format</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>consumer %d got %d. payload %d from producer %d</span><span class='tstring_end'>&quot;</span></span><span class='comma'>,</span> 
                    <span class='id identifier rubyid_consumer'>consumer</span><span class='comma'>,</span> <span class='id identifier rubyid_i'>i</span><span class='comma'>,</span> <span class='id identifier rubyid_message'>message</span><span class='comma'>,</span> <span class='id identifier rubyid_from'>from</span>       
    <span class='id identifier rubyid_do_stuff'>do_stuff</span>
    <span class='id identifier rubyid_i'>i</span> <span class='op'>+</span> <span class='int'>1</span> <span class='op'>&lt;</span> <span class='int'>2</span> <span class='op'>?</span> <span class='id identifier rubyid_consume'>consume</span><span class='lparen'>(</span><span class='id identifier rubyid_channel'>channel</span><span class='comma'>,</span> <span class='id identifier rubyid_log'>log</span><span class='comma'>,</span> <span class='id identifier rubyid_consumer'>consumer</span><span class='comma'>,</span> <span class='id identifier rubyid_i'>i</span> <span class='op'>+</span> <span class='int'>1</span><span class='rparen'>)</span> <span class='op'>:</span> <span class='symbol'>:done</span>       
  <span class='kw'>end</span>
<span class='kw'>end</span>                                      <span class='comment'># =&gt; :consume
</span>
<span class='id identifier rubyid_producers'>producers</span> <span class='op'>=</span> <span class='const'><span class='object_link'><a href="../Array.html" title="Concurrent::Array (class)">Array</a></span></span><span class='period'>.</span><span class='id identifier rubyid_new'>new</span> <span class='int'>2</span> <span class='kw'>do</span> <span class='op'>|</span><span class='id identifier rubyid_i'>i</span><span class='op'>|</span>
  <span class='const'><span class='object_link'><a href="../../Concurrent.html" title="Concurrent (module)">Concurrent</a></span></span><span class='op'>::</span><span class='const'><span class='object_link'><a href="../Promises.html" title="Concurrent::Promises (module)">Promises</a></span></span><span class='period'>.</span><span class='id identifier rubyid_future'><span class='object_link'><a href="FactoryMethods.html#future-instance_method" title="Concurrent::Promises::FactoryMethods#future (method)">future</a></span></span><span class='lparen'>(</span><span class='id identifier rubyid_channel'>channel</span><span class='comma'>,</span> <span class='id identifier rubyid_log'>log</span><span class='comma'>,</span> <span class='id identifier rubyid_i'>i</span><span class='rparen'>)</span> <span class='lbrace'>{</span> <span class='op'>|</span><span class='op'>*</span><span class='id identifier rubyid_args'>args</span><span class='op'>|</span> <span class='id identifier rubyid_produce'>produce</span> <span class='op'>*</span><span class='id identifier rubyid_args'>args</span><span class='comma'>,</span> <span class='int'>0</span> <span class='rbrace'>}</span><span class='period'>.</span><span class='id identifier rubyid_run'>run</span>
<span class='kw'>end</span>
<span class='comment'># =&gt; [#&lt;Concurrent::Promises::Future:0x00001b pending&gt;,
</span><span class='comment'>#     #&lt;Concurrent::Promises::Future:0x00001c pending&gt;]
</span>
<span class='id identifier rubyid_consumers'>consumers</span> <span class='op'>=</span> <span class='const'><span class='object_link'><a href="../Array.html" title="Concurrent::Array (class)">Array</a></span></span><span class='period'>.</span><span class='id identifier rubyid_new'>new</span> <span class='int'>4</span> <span class='kw'>do</span> <span class='op'>|</span><span class='id identifier rubyid_i'>i</span><span class='op'>|</span>
  <span class='const'><span class='object_link'><a href="../../Concurrent.html" title="Concurrent (module)">Concurrent</a></span></span><span class='op'>::</span><span class='const'><span class='object_link'><a href="../Promises.html" title="Concurrent::Promises (module)">Promises</a></span></span><span class='period'>.</span><span class='id identifier rubyid_future'><span class='object_link'><a href="FactoryMethods.html#future-instance_method" title="Concurrent::Promises::FactoryMethods#future (method)">future</a></span></span><span class='lparen'>(</span><span class='id identifier rubyid_channel'>channel</span><span class='comma'>,</span> <span class='id identifier rubyid_log'>log</span><span class='comma'>,</span> <span class='id identifier rubyid_i'>i</span><span class='rparen'>)</span> <span class='lbrace'>{</span> <span class='op'>|</span><span class='op'>*</span><span class='id identifier rubyid_args'>args</span><span class='op'>|</span> <span class='id identifier rubyid_consume'>consume</span> <span class='op'>*</span><span class='id identifier rubyid_args'>args</span><span class='comma'>,</span> <span class='int'>0</span> <span class='rbrace'>}</span><span class='period'>.</span><span class='id identifier rubyid_run'>run</span>
<span class='kw'>end</span>
<span class='comment'># =&gt; [#&lt;Concurrent::Promises::Future:0x00001d pending&gt;,
</span><span class='comment'>#     #&lt;Concurrent::Promises::Future:0x00001e pending&gt;,
</span><span class='comment'>#     #&lt;Concurrent::Promises::Future:0x00001f pending&gt;,
</span><span class='comment'>#     #&lt;Concurrent::Promises::Future:0x000020 pending&gt;]
</span>
<span class='comment'># wait for all to finish
</span><span class='id identifier rubyid_producers'>producers</span><span class='period'>.</span><span class='id identifier rubyid_map'>map</span><span class='lparen'>(</span><span class='op'>&amp;</span><span class='symbol'>:value!</span><span class='rparen'>)</span>                  <span class='comment'># =&gt; [:done, :done]
</span><span class='id identifier rubyid_consumers'>consumers</span><span class='period'>.</span><span class='id identifier rubyid_map'>map</span><span class='lparen'>(</span><span class='op'>&amp;</span><span class='symbol'>:value!</span><span class='rparen'>)</span>                  <span class='comment'># =&gt; [:done, :done, :done, :done]
</span><span class='comment'># investigate log
</span><span class='id identifier rubyid_log'>log</span>
<span class='comment'># =&gt; [&quot;producer 0 pushing 0&quot;,
</span><span class='comment'>#     &quot;producer 1 pushing 0&quot;,
</span><span class='comment'>#     &quot;consumer 0 got 0. payload 0 from producer 0&quot;,
</span><span class='comment'>#     &quot;producer 0 pushing 1&quot;,
</span><span class='comment'>#     &quot;producer 1 pushing 1&quot;,
</span><span class='comment'>#     &quot;consumer 2 got 0. payload 0 from producer 1&quot;,
</span><span class='comment'>#     &quot;consumer 3 got 0. payload 1 from producer 0&quot;,
</span><span class='comment'>#     &quot;producer 0 pushing 2&quot;,
</span><span class='comment'>#     &quot;producer 0 pushing 3&quot;,
</span><span class='comment'>#     &quot;consumer 1 got 0. payload 1 from producer 1&quot;,
</span><span class='comment'>#     &quot;producer 1 pushing 2&quot;,
</span><span class='comment'>#     &quot;producer 1 pushing 3&quot;,
</span><span class='comment'>#     &quot;consumer 0 got 1. payload 2 from producer 0&quot;,
</span><span class='comment'>#     &quot;consumer 3 got 1. payload 3 from producer 0&quot;,
</span><span class='comment'>#     &quot;consumer 2 got 1. payload 2 from producer 1&quot;,
</span><span class='comment'>#     &quot;consumer 1 got 1. payload 3 from producer 1&quot;]
</span></code></pre>

<h3>Synchronization of workers by passing a value</h3>

<p>If the capacity of the channel is zero 
then any push operation will succeed only 
when there is a matching pop operation
which can take the message.
The operations have to be paired to succeed. </p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_channel'>channel</span> <span class='op'>=</span> <span class='const'><span class='object_link'><a href="../../Concurrent.html" title="Concurrent (module)">Concurrent</a></span></span><span class='op'>::</span><span class='const'><span class='object_link'><a href="../Promises.html" title="Concurrent::Promises (module)">Promises</a></span></span><span class='op'>::</span><span class='const'>Channel</span><span class='period'>.</span><span class='id identifier rubyid_new'>new</span> <span class='int'>0</span>
<span class='comment'># =&gt; #&lt;Concurrent::Promises::Channel:0x000021 capacity taken 0 of 0&gt;
</span><span class='id identifier rubyid_thread'>thread</span> <span class='op'>=</span> <span class='const'>Thread</span><span class='period'>.</span><span class='id identifier rubyid_new'>new</span> <span class='lbrace'>{</span> <span class='id identifier rubyid_channel'>channel</span><span class='period'>.</span><span class='id identifier rubyid_pop'>pop</span> <span class='rbrace'>}</span><span class='semicolon'>;</span> <span class='id identifier rubyid_sleep'>sleep</span> <span class='float'>0.01</span> 
<span class='comment'># allow the thread to go to sleep
</span><span class='id identifier rubyid_thread'>thread</span>
<span class='comment'># =&gt; #&lt;Thread:0x000022@channel.in.md:214 sleep_forever&gt;
</span><span class='comment'># succeeds because there is matching pop operation waiting in the thread 
</span><span class='id identifier rubyid_channel'>channel</span><span class='period'>.</span><span class='id identifier rubyid_try_push'>try_push</span><span class='lparen'>(</span><span class='symbol'>:v1</span><span class='rparen'>)</span>                    <span class='comment'># =&gt; true
</span><span class='comment'># remains pending, since there is no matching operation 
</span><span class='id identifier rubyid_push'>push</span> <span class='op'>=</span> <span class='id identifier rubyid_channel'>channel</span><span class='period'>.</span><span class='id identifier rubyid_push_op'>push_op</span><span class='lparen'>(</span><span class='symbol'>:v2</span><span class='rparen'>)</span>
<span class='comment'># =&gt; #&lt;Concurrent::Promises::ResolvableFuture:0x000023 pending&gt;
</span><span class='id identifier rubyid_thread'>thread</span><span class='period'>.</span><span class='id identifier rubyid_value'>value</span>                             <span class='comment'># =&gt; :v1
</span><span class='comment'># the push operation resolves as a pairing pop is called
</span><span class='id identifier rubyid_channel'>channel</span><span class='period'>.</span><span class='id identifier rubyid_pop'>pop</span>                              <span class='comment'># =&gt; :v2
</span><span class='id identifier rubyid_push'>push</span>
<span class='comment'># =&gt; #&lt;Concurrent::Promises::ResolvableFuture:0x000023 fulfilled&gt;
</span></code></pre>
</p>


  </div>
</div>
<div class="tags">
  

</div>
  
    <h2>
      Constant Summary
      <small><a href="#" class="constants_summary_toggle">collapse</a></small>
    </h2>

    <dl class="constants">
      
        <dt id="UNLIMITED_CAPACITY-constant" class="">UNLIMITED_CAPACITY =
          <div class="docstring">
  <div class="discussion">
    <p>Default capacity of the Channel, makes it accept unlimited number of messages.</p>


  </div>
</div>
<div class="tags">
  

</div>
        </dt>
        <dd><pre class="code"><span class='op'>::</span><span class='const'>Object</span><span class='period'>.</span><span class='id identifier rubyid_new'>new</span></pre></dd>
      
    </dl>
  







  
    <h2>
      Class Method Summary
      <small><a href="#" class="summary_toggle">collapse</a></small>
    </h2>

    <ul class="summary">
      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#select-class_method" title="select (class method)">.<strong>select</strong>(channels, timeout = nil)  &#x21d2; Object<sup>?</sup> </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'></div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#select_op-class_method" title="select_op (class method)">.<strong>select_op</strong>(channels, probe = Promises.resolvable_future)  &#x21d2; Future(::Array(Channel, Object)) </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'></div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#try_select-class_method" title="try_select (class method)">.<strong>try_select</strong>(channels)  &#x21d2; ::Array(Channel, Object) </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'></div></span>
  
</li>

      
    </ul>
  
    <h2>
      Instance Method Summary
      <small><a href="#" class="summary_toggle">collapse</a></small>
    </h2>

    <ul class="summary">
      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#capacity-instance_method" title="#capacity (instance method)">#<strong>capacity</strong>  &#x21d2; Integer </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>Maximum capacity of the Channel.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#initialize-instance_method" title="#initialize (instance method)">#<strong>initialize</strong>(capacity = UNLIMITED_CAPACITY)  &#x21d2; Channel </a>
    

    
  </span>
  
  
    <span class="note title constructor">constructor</span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>Create channel.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#pop-instance_method" title="#pop (instance method)">#<strong>pop</strong>(timeout = nil)  &#x21d2; Object<sup>?</sup> </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>Blocks current thread until a message is available in the channel for popping.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#pop_op-instance_method" title="#pop_op (instance method)">#<strong>pop_op</strong>(probe = Promises.resolvable_future)  &#x21d2; Future(Object) </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>Returns a future witch will become fulfilled with a value from the channel when one is available.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#push-instance_method" title="#push (instance method)">#<strong>push</strong>(message, timeout = nil)  &#x21d2; self, true, false </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>Blocks current thread until the message is pushed into the channel.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#push_op-instance_method" title="#push_op (instance method)">#<strong>push_op</strong>(message)  &#x21d2; ResolvableFuture(self) </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>Returns future which will fulfill when the message is pushed to the channel.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#select-instance_method" title="#select (instance method)">#<strong>select</strong>(channels, timeout = nil)  &#x21d2; Object<sup>?</sup> </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>As <span class='object_link'><a href="#select_op-instance_method" title="Concurrent::Promises::Channel#select_op (method)">#select_op</a></span> but does not return future, it block current thread instead until there is a message available in the receiver or in any of the channels.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#select_op-instance_method" title="#select_op (instance method)">#<strong>select_op</strong>(channels, probe = Promises.resolvable_future)  &#x21d2; ResolvableFuture(::Array(Channel, Object)) </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>When message is available in the receiver or any of the provided channels the future is fulfilled with a channel message pair.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#size-instance_method" title="#size (instance method)">#<strong>size</strong>  &#x21d2; Integer </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>The number of messages currently stored in the channel.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#to_s-instance_method" title="#to_s (instance method)">#<strong>to_s</strong>  &#x21d2; String </a>
    

    
      (also: #inspect)
    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>Short string representation.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#try_pop-instance_method" title="#try_pop (instance method)">#<strong>try_pop</strong>  &#x21d2; Object<sup>?</sup> </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>Pop a message from the channel if there is one available.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#try_push-instance_method" title="#try_push (instance method)">#<strong>try_push</strong>(message)  &#x21d2; true, false </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>Push the message into the channel if there is space available.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#try_select-instance_method" title="#try_select (instance method)">#<strong>try_select</strong>(channels)  &#x21d2; ::Array(Channel, Object)<sup>?</sup> </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>If message is available in the receiver or any of the provided channels the channel message pair is returned.</p>
</div></span>
  
</li>

      
    </ul>
  


  
  <div id="constructor_details" class="method_details_list">
  <h2>Constructor Details</h2>
  
    <div class="method_details first">
  <h3 class="signature first" id="initialize-instance_method">
  
    #<strong>initialize</strong>(capacity = UNLIMITED_CAPACITY)  &#x21d2; <tt><span class='object_link'><a href="" title="Concurrent::Promises::Channel (class)">Channel</a></span></tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>Create channel.</p>


  </div>
</div>
<div class="tags">
  <p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>capacity</span>
      
      
        <span class='type'>(<tt>Integer</tt>, <tt><span class='object_link'><a href="#UNLIMITED_CAPACITY-constant" title="Concurrent::Promises::Channel::UNLIMITED_CAPACITY (constant)">UNLIMITED_CAPACITY</a></span></tt>)</span>
      
      
        <em class="default">(defaults to: <tt>UNLIMITED_CAPACITY</tt>)</em>
      
      
        &mdash;
        <div class='inline'><p>the maximum number of messages which can be stored in the channel.</p>
</div>
      
    </li>
  
</ul>


</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


48
49
50
51
52
53
54
55</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'lib-edge/concurrent/edge/channel.rb', line 48</span>

<span class='kw'>def</span> <span class='id identifier rubyid_initialize'>initialize</span><span class='lparen'>(</span><span class='id identifier rubyid_capacity'>capacity</span> <span class='op'>=</span> <span class='const'><span class='object_link'><a href="#UNLIMITED_CAPACITY-constant" title="Concurrent::Promises::Channel::UNLIMITED_CAPACITY (constant)">UNLIMITED_CAPACITY</a></span></span><span class='rparen'>)</span>
  <span class='kw'>super</span><span class='lparen'>(</span><span class='rparen'>)</span>
  <span class='ivar'>@Capacity</span>    <span class='op'>=</span> <span class='id identifier rubyid_capacity'>capacity</span>
  <span class='ivar'>@Mutex</span>       <span class='op'>=</span> <span class='const'>Mutex</span><span class='period'>.</span><span class='id identifier rubyid_new'>new</span>
  <span class='ivar'>@Probes</span>      <span class='op'>=</span> <span class='lbracket'>[</span><span class='rbracket'>]</span>
  <span class='ivar'>@Messages</span>    <span class='op'>=</span> <span class='lbracket'>[</span><span class='rbracket'>]</span>
  <span class='ivar'>@PendingPush</span> <span class='op'>=</span> <span class='lbracket'>[</span><span class='rbracket'>]</span>
<span class='kw'>end</span></pre>
    </td>
  </tr>
</table>
</div>
  
</div>


  <div id="class_method_details" class="method_details_list">
    <h2>Class Method Details</h2>

    
      <div class="method_details first">
  <h3 class="signature first" id="select-class_method">
  
    .<strong>select</strong>(channels, timeout = nil)  &#x21d2; <tt>Object</tt><sup>?</sup> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  
<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Object</tt>, <tt>nil</tt>)</span>
      
      
      
    </li>
  
</ul>

  <p class="tag_title">See Also:</p>
  <ul class="see">
    
      <li><span class='object_link'><a href="#select-instance_method" title="Concurrent::Promises::Channel#select (method)">#select</a></span></li>
    
  </ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


237
238
239</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'lib-edge/concurrent/edge/channel.rb', line 237</span>

<span class='kw'>def</span> <span class='id identifier rubyid_select'>select</span><span class='lparen'>(</span><span class='id identifier rubyid_channels'>channels</span><span class='comma'>,</span> <span class='id identifier rubyid_timeout'>timeout</span> <span class='op'>=</span> <span class='kw'>nil</span><span class='rparen'>)</span>
  <span class='id identifier rubyid_channels'>channels</span><span class='period'>.</span><span class='id identifier rubyid_first'>first</span><span class='period'>.</span><span class='id identifier rubyid_select'>select</span><span class='lparen'>(</span><span class='id identifier rubyid_channels'>channels</span><span class='lbracket'>[</span><span class='int'>1</span><span class='op'>..</span><span class='op'>-</span><span class='int'>1</span><span class='rbracket'>]</span><span class='comma'>,</span> <span class='id identifier rubyid_timeout'>timeout</span><span class='rparen'>)</span>
<span class='kw'>end</span></pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="select_op-class_method">
  
    .<strong>select_op</strong>(channels, probe = Promises.resolvable_future)  &#x21d2; <tt><span class='object_link'><a href="Future.html" title="Concurrent::Promises::Future (class)">Future</a></span>(::Array(<span class='object_link'><a href="" title="Concurrent::Promises::Channel (class)">Channel</a></span>, Object))</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  
<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt><span class='object_link'><a href="Future.html" title="Concurrent::Promises::Future (class)">Future</a></span>(::Array(<span class='object_link'><a href="" title="Concurrent::Promises::Channel (class)">Channel</a></span>, Object))</tt>)</span>
      
      
      
    </li>
  
</ul>

  <p class="tag_title">See Also:</p>
  <ul class="see">
    
      <li><span class='object_link'><a href="#select_op-instance_method" title="Concurrent::Promises::Channel#select_op (method)">#select_op</a></span></li>
    
  </ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


231
232
233</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'lib-edge/concurrent/edge/channel.rb', line 231</span>

<span class='kw'>def</span> <span class='id identifier rubyid_select_op'>select_op</span><span class='lparen'>(</span><span class='id identifier rubyid_channels'>channels</span><span class='comma'>,</span> <span class='id identifier rubyid_probe'>probe</span> <span class='op'>=</span> <span class='const'><span class='object_link'><a href="../Promises.html" title="Concurrent::Promises (module)">Promises</a></span></span><span class='period'>.</span><span class='id identifier rubyid_resolvable_future'><span class='object_link'><a href="FactoryMethods.html#resolvable_future-instance_method" title="Concurrent::Promises::FactoryMethods#resolvable_future (method)">resolvable_future</a></span></span><span class='rparen'>)</span>
  <span class='id identifier rubyid_channels'>channels</span><span class='period'>.</span><span class='id identifier rubyid_first'>first</span><span class='period'>.</span><span class='id identifier rubyid_select_op'>select_op</span><span class='lparen'>(</span><span class='id identifier rubyid_channels'>channels</span><span class='lbracket'>[</span><span class='int'>1</span><span class='op'>..</span><span class='op'>-</span><span class='int'>1</span><span class='rbracket'>]</span><span class='comma'>,</span> <span class='id identifier rubyid_probe'>probe</span><span class='rparen'>)</span>
<span class='kw'>end</span></pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="try_select-class_method">
  
    .<strong>try_select</strong>(channels)  &#x21d2; <tt>::Array(<span class='object_link'><a href="" title="Concurrent::Promises::Channel (class)">Channel</a></span>, Object)</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  
<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>::Array(<span class='object_link'><a href="" title="Concurrent::Promises::Channel (class)">Channel</a></span>, Object)</tt>)</span>
      
      
      
    </li>
  
</ul>

  <p class="tag_title">See Also:</p>
  <ul class="see">
    
      <li><span class='object_link'><a href="#try_select-instance_method" title="Concurrent::Promises::Channel#try_select (method)">#try_select</a></span></li>
    
  </ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


225
226
227</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'lib-edge/concurrent/edge/channel.rb', line 225</span>

<span class='kw'>def</span> <span class='id identifier rubyid_try_select'>try_select</span><span class='lparen'>(</span><span class='id identifier rubyid_channels'>channels</span><span class='rparen'>)</span>
  <span class='id identifier rubyid_channels'>channels</span><span class='period'>.</span><span class='id identifier rubyid_first'>first</span><span class='period'>.</span><span class='id identifier rubyid_try_select'>try_select</span><span class='lparen'>(</span><span class='id identifier rubyid_channels'>channels</span><span class='lbracket'>[</span><span class='int'>1</span><span class='op'>..</span><span class='op'>-</span><span class='int'>1</span><span class='rbracket'>]</span><span class='rparen'>)</span>
<span class='kw'>end</span></pre>
    </td>
  </tr>
</table>
</div>
    
  </div>

  <div id="instance_method_details" class="method_details_list">
    <h2>Instance Method Details</h2>

    
      <div class="method_details first">
  <h3 class="signature first" id="capacity-instance_method">
  
    #<strong>capacity</strong>  &#x21d2; <tt>Integer</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>Returns Maximum capacity of the Channel.</p>


  </div>
</div>
<div class="tags">
  
<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>Maximum capacity of the Channel.</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


210
211
212</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'lib-edge/concurrent/edge/channel.rb', line 210</span>

<span class='kw'>def</span> <span class='id identifier rubyid_capacity'>capacity</span>
  <span class='ivar'>@Capacity</span>
<span class='kw'>end</span></pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="pop-instance_method">
  
    #<strong>pop</strong>(timeout = nil)  &#x21d2; <tt>Object</tt><sup>?</sup> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    
  <div class="note notetag">
    <strong>Note:</strong>
    <div class='inline'><p>This function potentially blocks current thread until it can continue.
Be careful it can deadlock.</p>
</div>
  </div>

<p>Blocks current thread until a message is available in the channel for popping.</p>


  </div>
</div>
<div class="tags">
  <p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>timeout</span>
      
      
        <span class='type'>(<tt>Numeric</tt>)</span>
      
      
        <em class="default">(defaults to: <tt>nil</tt>)</em>
      
      
        &mdash;
        <div class='inline'><p>the maximum time in second to wait.</p>
</div>
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Object</tt>, <tt>nil</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>message or nil when timed out</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'lib-edge/concurrent/edge/channel.rb', line 139</span>

<span class='kw'>def</span> <span class='id identifier rubyid_pop'>pop</span><span class='lparen'>(</span><span class='id identifier rubyid_timeout'>timeout</span> <span class='op'>=</span> <span class='kw'>nil</span><span class='rparen'>)</span>
  <span class='comment'># TODO (pitr-ch 11-Dec-2018): disambiguation of message nil and timeout, allow to inject what should be returned when timed-out
</span>  <span class='id identifier rubyid_probe'>probe</span> <span class='op'>=</span> <span class='ivar'>@Mutex</span><span class='period'>.</span><span class='id identifier rubyid_synchronize'>synchronize</span> <span class='kw'>do</span>
    <span class='id identifier rubyid_message'>message</span> <span class='op'>=</span> <span class='id identifier rubyid_ns_shift_message'>ns_shift_message</span>
    <span class='kw'>if</span> <span class='id identifier rubyid_message'>message</span> <span class='op'>==</span> <span class='const'>NOTHING</span>
      <span class='id identifier rubyid_message'>message</span> <span class='op'>=</span> <span class='id identifier rubyid_ns_consume_pending_push'>ns_consume_pending_push</span>
      <span class='kw'>return</span> <span class='id identifier rubyid_message'>message</span> <span class='kw'>if</span> <span class='id identifier rubyid_message'>message</span> <span class='op'>!=</span> <span class='const'>NOTHING</span>
    <span class='kw'>else</span>
      <span class='id identifier rubyid_new_message'>new_message</span> <span class='op'>=</span> <span class='id identifier rubyid_ns_consume_pending_push'>ns_consume_pending_push</span>
      <span class='ivar'>@Messages</span><span class='period'>.</span><span class='id identifier rubyid_push'>push</span> <span class='id identifier rubyid_new_message'>new_message</span> <span class='kw'>unless</span> <span class='id identifier rubyid_new_message'>new_message</span> <span class='op'>==</span> <span class='const'>NOTHING</span>
      <span class='kw'>return</span> <span class='id identifier rubyid_message'>message</span>
    <span class='kw'>end</span>

    <span class='id identifier rubyid_probe'>probe</span> <span class='op'>=</span> <span class='const'><span class='object_link'><a href="../Promises.html" title="Concurrent::Promises (module)">Promises</a></span></span><span class='period'>.</span><span class='id identifier rubyid_resolvable_future'><span class='object_link'><a href="FactoryMethods.html#resolvable_future-instance_method" title="Concurrent::Promises::FactoryMethods#resolvable_future (method)">resolvable_future</a></span></span>
    <span class='ivar'>@Probes</span><span class='period'>.</span><span class='id identifier rubyid_push'>push</span> <span class='kw'>false</span><span class='comma'>,</span> <span class='id identifier rubyid_probe'>probe</span>
    <span class='id identifier rubyid_probe'>probe</span>
  <span class='kw'>end</span>

  <span class='id identifier rubyid_probe'>probe</span><span class='period'>.</span><span class='id identifier rubyid_value!'>value!</span><span class='lparen'>(</span><span class='id identifier rubyid_timeout'>timeout</span><span class='comma'>,</span> <span class='lbracket'>[</span><span class='kw'>true</span><span class='comma'>,</span> <span class='kw'>nil</span><span class='comma'>,</span> <span class='kw'>nil</span><span class='rbracket'>]</span><span class='rparen'>)</span>
<span class='kw'>end</span></pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="pop_op-instance_method">
  
    #<strong>pop_op</strong>(probe = Promises.resolvable_future)  &#x21d2; <tt><span class='object_link'><a href="Future.html" title="Concurrent::Promises::Future (class)">Future</a></span>(Object)</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>Returns a future witch will become fulfilled with a value from the channel when one is available.
If it is later waited on the operation with a timeout e.g.<code>channel.pop_op.wait(1)</code>
it will not prevent the channel to fulfill the operation later after the timeout.
The operation has to be either processed later</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_pop_op'>pop_op</span> <span class='op'>=</span> <span class='id identifier rubyid_channel'>channel</span><span class='period'>.</span><span class='id identifier rubyid_pop_op'>pop_op</span>
<span class='kw'>if</span> <span class='id identifier rubyid_pop_op'>pop_op</span><span class='period'>.</span><span class='id identifier rubyid_wait'>wait</span><span class='lparen'>(</span><span class='int'>1</span><span class='rparen'>)</span>
  <span class='id identifier rubyid_process_message'>process_message</span> <span class='id identifier rubyid_pop_op'>pop_op</span><span class='period'>.</span><span class='id identifier rubyid_value'>value</span>
<span class='kw'>else</span>
  <span class='id identifier rubyid_pop_op'>pop_op</span><span class='period'>.</span><span class='id identifier rubyid_then'>then</span> <span class='lbrace'>{</span> <span class='op'>|</span><span class='id identifier rubyid_message'>message</span><span class='op'>|</span> <span class='id identifier rubyid_log_unprocessed_message'>log_unprocessed_message</span> <span class='id identifier rubyid_message'>message</span> <span class='rbrace'>}</span>
<span class='kw'>end</span>
</code></pre>

<p>or the operation can be prevented from completion after timing out by using
<code>channel.pop_op.wait(1, [true, nil, nil])</code>.
It will fulfill the operation on timeout preventing channel from doing the operation,
e.g. popping a message.</p>


  </div>
</div>
<div class="tags">
  <p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>probe</span>
      
      
        <span class='type'>(<tt><span class='object_link'><a href="ResolvableFuture.html" title="Concurrent::Promises::ResolvableFuture (class)">ResolvableFuture</a></span></tt>)</span>
      
      
        <em class="default">(defaults to: <tt>Promises.resolvable_future</tt>)</em>
      
      
        &mdash;
        <div class='inline'><p>the future which will be fulfilled with a channel value</p>
</div>
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt><span class='object_link'><a href="Future.html" title="Concurrent::Promises::Future (class)">Future</a></span>(Object)</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>the probe, its value will be the message when available.</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


130
131
132</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'lib-edge/concurrent/edge/channel.rb', line 130</span>

<span class='kw'>def</span> <span class='id identifier rubyid_pop_op'>pop_op</span><span class='lparen'>(</span><span class='id identifier rubyid_probe'>probe</span> <span class='op'>=</span> <span class='const'><span class='object_link'><a href="../Promises.html" title="Concurrent::Promises (module)">Promises</a></span></span><span class='period'>.</span><span class='id identifier rubyid_resolvable_future'><span class='object_link'><a href="FactoryMethods.html#resolvable_future-instance_method" title="Concurrent::Promises::FactoryMethods#resolvable_future (method)">resolvable_future</a></span></span><span class='rparen'>)</span>
  <span class='ivar'>@Mutex</span><span class='period'>.</span><span class='id identifier rubyid_synchronize'>synchronize</span> <span class='lbrace'>{</span> <span class='id identifier rubyid_ns_pop_op'>ns_pop_op</span><span class='lparen'>(</span><span class='id identifier rubyid_probe'>probe</span><span class='comma'>,</span> <span class='kw'>false</span><span class='rparen'>)</span> <span class='rbrace'>}</span>
<span class='kw'>end</span></pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="push-instance_method">
  
    #<strong>push</strong>(message, timeout = nil)  &#x21d2; <tt>self</tt>, <tt>true</tt>, <tt>false</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    
  <div class="note notetag">
    <strong>Note:</strong>
    <div class='inline'><p>This function potentially blocks current thread until it can continue.
Be careful it can deadlock.</p>
</div>
  </div>

<p>Blocks current thread until the message is pushed into the channel.</p>


  </div>
</div>
<div class="tags">
  <p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>message</span>
      
      
        <span class='type'>(<tt>Object</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>timeout</span>
      
      
        <span class='type'>(<tt>Numeric</tt>)</span>
      
      
        <em class="default">(defaults to: <tt>nil</tt>)</em>
      
      
        &mdash;
        <div class='inline'><p>the maximum time in second to wait.</p>
</div>
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>self</tt>, <tt>true</tt>, <tt>false</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>self implies timeout was not used, true implies timeout was used
and it was pushed, false implies it was not pushed within timeout.</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


103
104
105
106
107
108
109
110
111
112
113
114
115</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'lib-edge/concurrent/edge/channel.rb', line 103</span>

<span class='kw'>def</span> <span class='id identifier rubyid_push'>push</span><span class='lparen'>(</span><span class='id identifier rubyid_message'>message</span><span class='comma'>,</span> <span class='id identifier rubyid_timeout'>timeout</span> <span class='op'>=</span> <span class='kw'>nil</span><span class='rparen'>)</span>
  <span class='id identifier rubyid_pushed_op'>pushed_op</span> <span class='op'>=</span> <span class='ivar'>@Mutex</span><span class='period'>.</span><span class='id identifier rubyid_synchronize'>synchronize</span> <span class='kw'>do</span>
    <span class='kw'>return</span> <span class='id identifier rubyid_timeout'>timeout</span> <span class='op'>?</span> <span class='kw'>true</span> <span class='op'>:</span> <span class='kw'>self</span> <span class='kw'>if</span> <span class='id identifier rubyid_ns_try_push'>ns_try_push</span><span class='lparen'>(</span><span class='id identifier rubyid_message'>message</span><span class='rparen'>)</span>

    <span class='id identifier rubyid_pushed'>pushed</span> <span class='op'>=</span> <span class='const'><span class='object_link'><a href="../Promises.html" title="Concurrent::Promises (module)">Promises</a></span></span><span class='period'>.</span><span class='id identifier rubyid_resolvable_future'><span class='object_link'><a href="FactoryMethods.html#resolvable_future-instance_method" title="Concurrent::Promises::FactoryMethods#resolvable_future (method)">resolvable_future</a></span></span>
    <span class='comment'># TODO (pitr-ch 06-Jan-2019): clear timed out pushes in @PendingPush, null messages
</span>    <span class='ivar'>@PendingPush</span><span class='period'>.</span><span class='id identifier rubyid_push'>push</span> <span class='id identifier rubyid_message'>message</span><span class='comma'>,</span> <span class='id identifier rubyid_pushed'>pushed</span>
    <span class='id identifier rubyid_pushed'>pushed</span>
  <span class='kw'>end</span>

  <span class='id identifier rubyid_result'>result</span> <span class='op'>=</span> <span class='id identifier rubyid_pushed_op'>pushed_op</span><span class='period'>.</span><span class='id identifier rubyid_wait!'>wait!</span><span class='lparen'>(</span><span class='id identifier rubyid_timeout'>timeout</span><span class='comma'>,</span> <span class='lbracket'>[</span><span class='kw'>true</span><span class='comma'>,</span> <span class='kw'>self</span><span class='comma'>,</span> <span class='kw'>nil</span><span class='rbracket'>]</span><span class='rparen'>)</span>
  <span class='id identifier rubyid_result'>result</span> <span class='op'>==</span> <span class='id identifier rubyid_pushed_op'>pushed_op</span> <span class='op'>?</span> <span class='kw'>self</span> <span class='op'>:</span> <span class='id identifier rubyid_result'>result</span>
<span class='kw'>end</span></pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="push_op-instance_method">
  
    #<strong>push_op</strong>(message)  &#x21d2; <tt><span class='object_link'><a href="ResolvableFuture.html" title="Concurrent::Promises::ResolvableFuture (class)">ResolvableFuture</a></span>(self)</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>Returns future which will fulfill when the message is pushed to the channel.
If it is later waited on the operation with a timeout e.g.<code>channel.pop_op.wait(1)</code>
it will not prevent the channel to fulfill the operation later after the timeout.
The operation has to be either processed later</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_pop_op'>pop_op</span> <span class='op'>=</span> <span class='id identifier rubyid_channel'>channel</span><span class='period'>.</span><span class='id identifier rubyid_pop_op'>pop_op</span>
<span class='kw'>if</span> <span class='id identifier rubyid_pop_op'>pop_op</span><span class='period'>.</span><span class='id identifier rubyid_wait'>wait</span><span class='lparen'>(</span><span class='int'>1</span><span class='rparen'>)</span>
  <span class='id identifier rubyid_process_message'>process_message</span> <span class='id identifier rubyid_pop_op'>pop_op</span><span class='period'>.</span><span class='id identifier rubyid_value'>value</span>
<span class='kw'>else</span>
  <span class='id identifier rubyid_pop_op'>pop_op</span><span class='period'>.</span><span class='id identifier rubyid_then'>then</span> <span class='lbrace'>{</span> <span class='op'>|</span><span class='id identifier rubyid_message'>message</span><span class='op'>|</span> <span class='id identifier rubyid_log_unprocessed_message'>log_unprocessed_message</span> <span class='id identifier rubyid_message'>message</span> <span class='rbrace'>}</span>
<span class='kw'>end</span>
</code></pre>

<p>or the operation can be prevented from completion after timing out by using
<code>channel.pop_op.wait(1, [true, nil, nil])</code>.
It will fulfill the operation on timeout preventing channel from doing the operation,
e.g. popping a message.</p>


  </div>
</div>
<div class="tags">
  <p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>message</span>
      
      
        <span class='type'>(<tt>Object</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt><span class='object_link'><a href="ResolvableFuture.html" title="Concurrent::Promises::ResolvableFuture (class)">ResolvableFuture</a></span>(self)</tt>)</span>
      
      
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


84
85
86
87
88
89
90
91
92
93
94</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'lib-edge/concurrent/edge/channel.rb', line 84</span>

<span class='kw'>def</span> <span class='id identifier rubyid_push_op'>push_op</span><span class='lparen'>(</span><span class='id identifier rubyid_message'>message</span><span class='rparen'>)</span>
  <span class='ivar'>@Mutex</span><span class='period'>.</span><span class='id identifier rubyid_synchronize'>synchronize</span> <span class='kw'>do</span>
    <span class='kw'>if</span> <span class='id identifier rubyid_ns_try_push'>ns_try_push</span><span class='lparen'>(</span><span class='id identifier rubyid_message'>message</span><span class='rparen'>)</span>
      <span class='const'><span class='object_link'><a href="../Promises.html" title="Concurrent::Promises (module)">Promises</a></span></span><span class='period'>.</span><span class='id identifier rubyid_fulfilled_future'><span class='object_link'><a href="FactoryMethods.html#fulfilled_future-instance_method" title="Concurrent::Promises::FactoryMethods#fulfilled_future (method)">fulfilled_future</a></span></span> <span class='kw'>self</span>
    <span class='kw'>else</span>
      <span class='id identifier rubyid_pushed'>pushed</span> <span class='op'>=</span> <span class='const'><span class='object_link'><a href="../Promises.html" title="Concurrent::Promises (module)">Promises</a></span></span><span class='period'>.</span><span class='id identifier rubyid_resolvable_future'><span class='object_link'><a href="FactoryMethods.html#resolvable_future-instance_method" title="Concurrent::Promises::FactoryMethods#resolvable_future (method)">resolvable_future</a></span></span>
      <span class='ivar'>@PendingPush</span><span class='period'>.</span><span class='id identifier rubyid_push'>push</span> <span class='id identifier rubyid_message'>message</span><span class='comma'>,</span> <span class='id identifier rubyid_pushed'>pushed</span>
      <span class='kw'>return</span> <span class='id identifier rubyid_pushed'>pushed</span>
    <span class='kw'>end</span>
  <span class='kw'>end</span>
<span class='kw'>end</span></pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="select-instance_method">
  
    #<strong>select</strong>(channels, timeout = nil)  &#x21d2; <tt>Object</tt><sup>?</sup> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    
  <div class="note notetag">
    <strong>Note:</strong>
    <div class='inline'><p>This function potentially blocks current thread until it can continue.
Be careful it can deadlock.</p>
</div>
  </div>

<p>As <span class='object_link'><a href="#select_op-instance_method" title="Concurrent::Promises::Channel#select_op (method)">#select_op</a></span> but does not return future,
it block current thread instead until there is a message available
in the receiver or in any of the channels.</p>


  </div>
</div>
<div class="tags">
  <p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>channels</span>
      
      
        <span class='type'>(<tt><span class='object_link'><a href="" title="Concurrent::Promises::Channel (class)">Channel</a></span></tt>, <tt>::Array&lt;<span class='object_link'><a href="" title="Concurrent::Promises::Channel (class)">Channel</a></span>&gt;</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>timeout</span>
      
      
        <span class='type'>(<tt>Numeric</tt>)</span>
      
      
        <em class="default">(defaults to: <tt>nil</tt>)</em>
      
      
        &mdash;
        <div class='inline'><p>the maximum time in second to wait.</p>
</div>
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Object</tt>, <tt>nil</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>message or nil when timed out</p>
</div>
      
    </li>
  
</ul>

  <p class="tag_title">See Also:</p>
  <ul class="see">
    
      <li><span class='object_link'><a href="#select_op-instance_method" title="Concurrent::Promises::Channel#select_op (method)">#select_op</a></span></li>
    
  </ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


199
200
201
202</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'lib-edge/concurrent/edge/channel.rb', line 199</span>

<span class='kw'>def</span> <span class='id identifier rubyid_select'>select</span><span class='lparen'>(</span><span class='id identifier rubyid_channels'>channels</span><span class='comma'>,</span> <span class='id identifier rubyid_timeout'>timeout</span> <span class='op'>=</span> <span class='kw'>nil</span><span class='rparen'>)</span>
  <span class='id identifier rubyid_probe'>probe</span> <span class='op'>=</span> <span class='id identifier rubyid_select_op'>select_op</span><span class='lparen'>(</span><span class='id identifier rubyid_channels'>channels</span><span class='rparen'>)</span>
  <span class='id identifier rubyid_probe'>probe</span><span class='period'>.</span><span class='id identifier rubyid_value!'>value!</span><span class='lparen'>(</span><span class='id identifier rubyid_timeout'>timeout</span><span class='comma'>,</span> <span class='lbracket'>[</span><span class='kw'>true</span><span class='comma'>,</span> <span class='kw'>nil</span><span class='comma'>,</span> <span class='kw'>nil</span><span class='rbracket'>]</span><span class='rparen'>)</span>
<span class='kw'>end</span></pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="select_op-instance_method">
  
    #<strong>select_op</strong>(channels, probe = Promises.resolvable_future)  &#x21d2; <tt><span class='object_link'><a href="ResolvableFuture.html" title="Concurrent::Promises::ResolvableFuture (class)">ResolvableFuture</a></span>(::Array(<span class='object_link'><a href="" title="Concurrent::Promises::Channel (class)">Channel</a></span>, Object))</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>When message is available in the receiver or any of the provided channels
the future is fulfilled with a channel message pair.
The returned channel is the origin of the message.
If it is later waited on the operation with a timeout e.g.<code>channel.pop_op.wait(1)</code>
it will not prevent the channel to fulfill the operation later after the timeout.
The operation has to be either processed later</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_pop_op'>pop_op</span> <span class='op'>=</span> <span class='id identifier rubyid_channel'>channel</span><span class='period'>.</span><span class='id identifier rubyid_pop_op'>pop_op</span>
<span class='kw'>if</span> <span class='id identifier rubyid_pop_op'>pop_op</span><span class='period'>.</span><span class='id identifier rubyid_wait'>wait</span><span class='lparen'>(</span><span class='int'>1</span><span class='rparen'>)</span>
  <span class='id identifier rubyid_process_message'>process_message</span> <span class='id identifier rubyid_pop_op'>pop_op</span><span class='period'>.</span><span class='id identifier rubyid_value'>value</span>
<span class='kw'>else</span>
  <span class='id identifier rubyid_pop_op'>pop_op</span><span class='period'>.</span><span class='id identifier rubyid_then'>then</span> <span class='lbrace'>{</span> <span class='op'>|</span><span class='id identifier rubyid_message'>message</span><span class='op'>|</span> <span class='id identifier rubyid_log_unprocessed_message'>log_unprocessed_message</span> <span class='id identifier rubyid_message'>message</span> <span class='rbrace'>}</span>
<span class='kw'>end</span>
</code></pre>

<p>or the operation can be prevented from completion after timing out by using
<code>channel.pop_op.wait(1, [true, nil, nil])</code>.
It will fulfill the operation on timeout preventing channel from doing the operation,
e.g. popping a message.</p>


  </div>
</div>
<div class="tags">
  <p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>channels</span>
      
      
        <span class='type'>(<tt><span class='object_link'><a href="" title="Concurrent::Promises::Channel (class)">Channel</a></span></tt>, <tt>::Array&lt;<span class='object_link'><a href="" title="Concurrent::Promises::Channel (class)">Channel</a></span>&gt;</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>probe</span>
      
      
        <span class='type'>(<tt><span class='object_link'><a href="ResolvableFuture.html" title="Concurrent::Promises::ResolvableFuture (class)">ResolvableFuture</a></span></tt>)</span>
      
      
        <em class="default">(defaults to: <tt>Promises.resolvable_future</tt>)</em>
      
      
        &mdash;
        <div class='inline'><p>the future which will be fulfilled with the message</p>
</div>
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt><span class='object_link'><a href="ResolvableFuture.html" title="Concurrent::Promises::ResolvableFuture (class)">ResolvableFuture</a></span>(::Array(<span class='object_link'><a href="" title="Concurrent::Promises::Channel (class)">Channel</a></span>, Object))</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>a future which is fulfilled with
pair [channel, message] when one of the channels is available for reading</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


185
186
187
188</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'lib-edge/concurrent/edge/channel.rb', line 185</span>

<span class='kw'>def</span> <span class='id identifier rubyid_select_op'>select_op</span><span class='lparen'>(</span><span class='id identifier rubyid_channels'>channels</span><span class='comma'>,</span> <span class='id identifier rubyid_probe'>probe</span> <span class='op'>=</span> <span class='const'><span class='object_link'><a href="../Promises.html" title="Concurrent::Promises (module)">Promises</a></span></span><span class='period'>.</span><span class='id identifier rubyid_resolvable_future'><span class='object_link'><a href="FactoryMethods.html#resolvable_future-instance_method" title="Concurrent::Promises::FactoryMethods#resolvable_future (method)">resolvable_future</a></span></span><span class='rparen'>)</span>
  <span class='lbracket'>[</span><span class='kw'>self</span><span class='comma'>,</span> <span class='op'>*</span><span class='id identifier rubyid_channels'>channels</span><span class='rbracket'>]</span><span class='period'>.</span><span class='id identifier rubyid_each'>each</span> <span class='lbrace'>{</span> <span class='op'>|</span><span class='id identifier rubyid_ch'>ch</span><span class='op'>|</span> <span class='id identifier rubyid_ch'>ch</span><span class='period'>.</span><span class='id identifier rubyid_partial_select_op'>partial_select_op</span> <span class='id identifier rubyid_probe'>probe</span> <span class='rbrace'>}</span>
  <span class='id identifier rubyid_probe'>probe</span>
<span class='kw'>end</span></pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="size-instance_method">
  
    #<strong>size</strong>  &#x21d2; <tt>Integer</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>Returns The number of messages currently stored in the channel.</p>


  </div>
</div>
<div class="tags">
  
<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>The number of messages currently stored in the channel.</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


205
206
207</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'lib-edge/concurrent/edge/channel.rb', line 205</span>

<span class='kw'>def</span> <span class='id identifier rubyid_size'>size</span>
  <span class='ivar'>@Mutex</span><span class='period'>.</span><span class='id identifier rubyid_synchronize'>synchronize</span> <span class='lbrace'>{</span> <span class='ivar'>@Messages</span><span class='period'>.</span><span class='id identifier rubyid_size'>size</span> <span class='rbrace'>}</span>
<span class='kw'>end</span></pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="to_s-instance_method">
  
    #<strong>to_s</strong>  &#x21d2; <tt>String</tt> 
  

  
    <span class="aliases">Also known as:
    <span class="names"><span id='inspect-instance_method'>inspect</span></span>
    </span>
  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>Returns Short string representation.</p>


  </div>
</div>
<div class="tags">
  
<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>String</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>Short string representation.</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


215
216
217</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'lib-edge/concurrent/edge/channel.rb', line 215</span>

<span class='kw'>def</span> <span class='id identifier rubyid_to_s'>to_s</span>
  <span class='id identifier rubyid_format'>format</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>%s capacity taken %s of %s&gt;</span><span class='tstring_end'>&#39;</span></span><span class='comma'>,</span> <span class='kw'>super</span><span class='lbracket'>[</span><span class='int'>0</span><span class='op'>..</span><span class='op'>-</span><span class='int'>2</span><span class='rbracket'>]</span><span class='comma'>,</span> <span class='id identifier rubyid_size'>size</span><span class='comma'>,</span> <span class='ivar'>@Capacity</span>
<span class='kw'>end</span></pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="try_pop-instance_method">
  
    #<strong>try_pop</strong>  &#x21d2; <tt>Object</tt><sup>?</sup> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>Pop a message from the channel if there is one available.</p>


  </div>
</div>
<div class="tags">
  
<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Object</tt>, <tt>nil</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>message or nil when there is no message</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


119
120
121
122
123</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'lib-edge/concurrent/edge/channel.rb', line 119</span>

<span class='kw'>def</span> <span class='id identifier rubyid_try_pop'>try_pop</span>
  <span class='comment'># TODO (pitr-ch 11-Dec-2018): disambiguation of no message and nil message
</span>  <span class='id identifier rubyid_message'>message</span> <span class='op'>=</span> <span class='id identifier rubyid_try_pop_disambiguated'>try_pop_disambiguated</span>
  <span class='id identifier rubyid_message'>message</span> <span class='op'>==</span> <span class='const'>NOTHING</span> <span class='op'>?</span> <span class='kw'>nil</span> <span class='op'>:</span> <span class='id identifier rubyid_message'>message</span>
<span class='kw'>end</span></pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="try_push-instance_method">
  
    #<strong>try_push</strong>(message)  &#x21d2; <tt>true</tt>, <tt>false</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>Push the message into the channel if there is space available.</p>


  </div>
</div>
<div class="tags">
  <p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>message</span>
      
      
        <span class='type'>(<tt>Object</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>true</tt>, <tt>false</tt>)</span>
      
      
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


60
61
62</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'lib-edge/concurrent/edge/channel.rb', line 60</span>

<span class='kw'>def</span> <span class='id identifier rubyid_try_push'>try_push</span><span class='lparen'>(</span><span class='id identifier rubyid_message'>message</span><span class='rparen'>)</span>
  <span class='ivar'>@Mutex</span><span class='period'>.</span><span class='id identifier rubyid_synchronize'>synchronize</span> <span class='lbrace'>{</span> <span class='id identifier rubyid_ns_try_push'>ns_try_push</span><span class='lparen'>(</span><span class='id identifier rubyid_message'>message</span><span class='rparen'>)</span> <span class='rbrace'>}</span>
<span class='kw'>end</span></pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="try_select-instance_method">
  
    #<strong>try_select</strong>(channels)  &#x21d2; <tt>::Array(<span class='object_link'><a href="" title="Concurrent::Promises::Channel (class)">Channel</a></span>, Object)</tt><sup>?</sup> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>If message is available in the receiver or any of the provided channels
the channel message pair is returned. If there is no message nil is returned.
The returned channel is the origin of the message.</p>


  </div>
</div>
<div class="tags">
  <p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>channels</span>
      
      
        <span class='type'>(<tt><span class='object_link'><a href="" title="Concurrent::Promises::Channel (class)">Channel</a></span></tt>, <tt>::Array&lt;<span class='object_link'><a href="" title="Concurrent::Promises::Channel (class)">Channel</a></span>&gt;</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>::Array(<span class='object_link'><a href="" title="Concurrent::Promises::Channel (class)">Channel</a></span>, Object)</tt>, <tt>nil</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>pair [channel, message] if one of the channels is available for reading</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


167
168
169
170
171
172
173
174</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'lib-edge/concurrent/edge/channel.rb', line 167</span>

<span class='kw'>def</span> <span class='id identifier rubyid_try_select'>try_select</span><span class='lparen'>(</span><span class='id identifier rubyid_channels'>channels</span><span class='rparen'>)</span>
  <span class='id identifier rubyid_message'>message</span> <span class='op'>=</span> <span class='kw'>nil</span>
  <span class='id identifier rubyid_channel'>channel</span> <span class='op'>=</span> <span class='lbracket'>[</span><span class='kw'>self</span><span class='comma'>,</span> <span class='op'>*</span><span class='id identifier rubyid_channels'>channels</span><span class='rbracket'>]</span><span class='period'>.</span><span class='id identifier rubyid_find'>find</span> <span class='kw'>do</span> <span class='op'>|</span><span class='id identifier rubyid_ch'>ch</span><span class='op'>|</span>
    <span class='id identifier rubyid_message'>message</span> <span class='op'>=</span> <span class='id identifier rubyid_ch'>ch</span><span class='period'>.</span><span class='id identifier rubyid_try_pop_disambiguated'>try_pop_disambiguated</span>
    <span class='id identifier rubyid_message'>message</span> <span class='op'>!=</span> <span class='const'>NOTHING</span>
  <span class='kw'>end</span>
  <span class='id identifier rubyid_channel'>channel</span> <span class='op'>?</span> <span class='lbracket'>[</span><span class='id identifier rubyid_channel'>channel</span><span class='comma'>,</span> <span class='id identifier rubyid_message'>message</span><span class='rbracket'>]</span> <span class='op'>:</span> <span class='kw'>nil</span>
<span class='kw'>end</span></pre>
    </td>
  </tr>
</table>
</div>
    
  </div>

</div>

      <div id="footer">
  Generated by <a href="http://yardoc.org" title="Yay! A Ruby Documentation Tool" target="_blank">yard</a>.
</div>

<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
          m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-57940973-1', 'auto');
  ga('send', 'pageview');

</script>

    </div>
  </body>
</html>